<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moss's Random Weather Forecast</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Wellfleet:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Base & Layout Styles --- */

        html,
        body {
            margin: 0;
            padding: 0;
        }

        :root {
            --color-bg: #f7fafc;
            --color-panel: #e3f0ff;
            --color-accent: #3bb273;
            --color-highlight: #ff914d;
            --color-primary: #234e70;
            --color-primary-hover: #1a3a56;
            --color-accent-hover: #2e8b57;
            --color-text-primary: #234e70;
            --color-text-secondary: #5a7a9a;
            --color-high-temp: var(--color-highlight);
            --color-low-temp: var(--color-primary);
            --color-border: #cddbf0;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -4px rgba(0, 0, 0, 0.07);
            --shadow-xl: 0 20px 25px -5px rgba(35, 78, 112, 0.1), 0 8px 10px -6px rgba(35, 78, 112, 0.1);
        }

        body {
            font-family: 'Wellfleet', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            display: flex;
            flex-direction: column;
            /* Keep this line */
            align-items: center;
            /* Keep this line */
            /* REMOVE this line: justify-content: center; */
            min-height: 100vh;
            min-height: 100dvh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }

        .container {
            width: 100%;
            max-width: 64rem;
            background-color: var(--color-panel);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--color-border);
            box-sizing: border-box;
            margin-top: 2rem;
        }




        .subheading-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .location-info p {
            font-size: 1.125rem;
            color: var(--color-text-secondary);
            margin: 0;
        }

        #local-time-display {
            font-size: 1rem;
            font-weight: 500;
            color: var(--color-primary);
            margin-top: 0.25rem;
            min-height: 1.5rem;
        }

        #location-display-clickable {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
        }

        #location-display-clickable:hover {
            color: var(--color-primary-hover);
        }

        .controls-row {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-end;
            gap: 1rem;
        }

        .search-container {
            flex: 1 1 200px;
        }

        .search-container label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-bottom: 0.25rem;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            background-color: #fff;
            border: 1px solid var(--color-border);
            padding-left: 0.75rem;
        }

        .input-wrapper:focus-within {
            box-shadow: 0 0 0 3px var(--color-accent);
        }

        .input-wrapper .search-icon-magnifying-glass {
            width: 1.5rem;
            height: 1.5rem;
            color: var(--color-text-secondary);
        }

        #search-input {
            width: 100%;
            box-sizing: border-box;
            padding: 0.75rem 0.5rem;
            border: none;
            background-color: transparent;
            outline: none;
            flex-grow: 1;
        }

        #search-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        #search-btn:hover {
            background-color: #e0e0e0;
        }

        #search-btn svg {
            width: 1.25rem;
            height: 1.25rem;
            color: var(--color-primary);
        }

        .unit-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #fff;
            padding: 0.25rem;
            border: 1px solid var(--color-border);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 2.5rem;
            height: 1.5rem;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 1.5rem;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 1.25rem;
            width: 1.25rem;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--color-accent);
        }

        input:checked+.slider:before {
            transform: translateX(1rem);
        }

        .settings-selector {
            display: flex;
            flex-direction: column;
            flex: 0 1 120px;
        }

        .settings-selector label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-bottom: 0.25rem;
        }

        .settings-selector select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--color-border);
            background-color: #fff;
        }

        /* --- Main Content --- */
        #loading {
            text-align: center;
            padding: 4rem 0;
        }

        #loading svg {
            animation: spin 1s linear infinite;
            margin: auto;
            height: 3rem;
            width: 3rem;
            color: var(--color-primary);
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        #loading p {
            font-size: 1.25rem;
            color: var(--color-text-secondary);
            font-weight: 500;
            margin-top: 1rem;
        }

        #error-message {
            background-color: #fee2e2;
            padding: 1.5rem;
            text-align: center;
        }

        #weather-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 1.5rem;
        }

        .weather-card {
            background-color: #fff;
            padding: 1.25rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--color-border);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        .weather-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .card-header h3 {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .card-header p {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
        }

        .card-header img {
            width: 4rem;
            height: 4rem;
        }

        .card-body {
            text-align: center;
            margin-bottom: 1rem;
        }

        .card-body .high-temp {
            font-size: 3rem;
            font-weight: 700;
            color: var(--color-highlight);
        }

        .card-body .low-temp {
            font-size: 1.875rem;
            font-weight: 500;
            color: var(--color-low-temp);
            margin-left: 0.5rem;
        }

        .card-body .unit {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--color-text-primary);
            text-align: left;
            /* Changed from 'center' */
            margin-bottom: 1rem;
            flex-grow: 1;
        }

        .card-footer {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
            text-align: center;
        }

        /* --- Wikipedia Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #fff;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-xl);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        #wiki-title {
            margin-bottom: 1rem;
        }

        #wiki-summary {
            max-height: 300px;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .attribution {
            margin-top: 0;
            font-size: 0.8rem;
            color: var(--color-text-secondary);
            text-align: center;
        }

        .attribution a {
            color: var(--color-primary);
            text-decoration: none;
        }

        .attribution a:hover {
            text-decoration: underline;
        }

        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }
        }

        .main-title {
            text-align: left;
        }

        .main-title h1 {
            font-size: 2.25rem;
            font-weight: 700;

        }

        .main-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
        }

        .action-button {
            padding: 1.75rem 2.75rem;
            background-color: var(--color-accent);
            color: white;
            font-weight: 600;
            font-family: 'Wellfleet';
            font-size:large;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .action-button:hover {
            background-color: var(--color-accent-hover);
        }

    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="main-title-row">

                
                <div class="main-title">
                    <h1>Moss's Random Weather Forecast!</h1>

                </div>

                <button id="random-btn" class="action-button">Random Location</button>
            </div>
            <div class="controls-row">
                <div class="search-container">
                    <label for="search-input">Search Location</label>
                    <div class="input-wrapper">
                        <svg class="search-icon-magnifying-glass" xmlns="http://www.w3.org/2000/svg" fill="none"
                            viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
                        </svg>
                        <input type="text" id="search-input" placeholder="Search any city...">
                        <button id="search-btn" aria-label="Search">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="settings-selector">
                    <label for="region-select">Region</label>
                    <select id="region-select">
                        <option value="world" selected>World</option>
                        <option value="contiguous_us">Contiguous US</option>
                    </select>
                </div>
                <div class="settings-selector">
                    <label for="days-select">Forecast Days</label>
                    <select id="days-select">
                        <option value="1">1 Day</option>
                        <option value="2">2 Days</option>
                        <option value="3">3 Days</option>
                        <option value="4">4 Days</option>
                        <option value="5">5 Days</option>
                        <option value="6">6 Days</option>
                        <option value="7">7 Days</option>
                        <option value="8">8 Days</option>
                        <option value="9">9 Days</option>
                    </select>
                </div>
            </div>
            <div class="subheading-row">
                <div class="location-info">
                    <p id="location-display">Finding a random location...</p>
                    <p id="local-time-display"></p>
                </div>
                <div class="unit-toggle">
                    <span>째C</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="unit-toggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span>째F</span>
                </div>
            </div>
        </header>

        <main id="main-content">
            <div id="loading"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                <p>Fetching weather data...</p>
            </div>
            <div id="error-message" class="hidden">
                <h3>Oops! Something went wrong.</h3>
                <p>Could not fetch weather details. Let's try somewhere else!</p>
            </div>
            <div id="weather-container" class="hidden"></div>
        </main>
    </div>

    <div id="wiki-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close">&times;</button>
            <h2 id="wiki-title">Loading...</h2>
            <div id="wiki-summary">
                <p>Fetching summary from Wikipedia...</p>
            </div>
        </div>
    </div>

    <footer class="attribution">
        <p>
            Weather data provided by the <a href="https://api.met.no" target="_blank"
                rel="noopener noreferrer">Norwegian Meteorological Institute</a>.
            Reverse-geocoding for random location provided via <a href="https://www.bigdatacloud.com/free-api"
                target="_blank" rel="noopener noreferrer">Big Data Cloud</a>.
        </p>
        <p>
            Reverse-geocoding for Search provided via <a href="https://nominatim.org" target="_blank"
                rel="noopener noreferrer">Nominatim</a>.
            Wikipedia summaries powered by <a href="https://www.wikipedia.org" target="_blank"
                rel="noopener noreferrer">Wikipedia</a>.
            Time zone data from <a href="https://open-meteo.com" target="_blank"
                rel="noopener noreferrer">Open-Meteo</a>
        </p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const elements = {
                loading: document.getElementById('loading'),
                errorMessage: document.getElementById('error-message'),
                weatherContainer: document.getElementById('weather-container'),
                locationDisplay: document.getElementById('location-display'),
                localTimeDisplay: document.getElementById('local-time-display'),
                searchInput: document.getElementById('search-input'),
                searchBtn: document.getElementById('search-btn'),
                randomBtn: document.getElementById('random-btn'),
                unitToggle: document.getElementById('unit-toggle'),
                regionSelect: document.getElementById('region-select'),
                daysSelect: document.getElementById('days-select'),
                wikiModal: document.getElementById('wiki-modal'),
                modalCloseBtn: document.getElementById('modal-close-btn'),
                wikiTitle: document.getElementById('wiki-title'),
                wikiSummary: document.getElementById('wiki-summary'),
            };

            const state = {
                isFahrenheit: true,
                forecastDays: 4,
                currentForecast: null,
                currentTimezone: null,
                currentLocationData: null,
                timeUpdater: null,
                landmasses: {
                    contiguous_us: { minLat: 24.52, maxLat: 49.38, minLon: -124.77, maxLon: -66.95 },
                    europe: { minLat: 36, maxLat: 71, minLon: -24, maxLon: 65 },
                    asia: { minLat: -10, maxLat: 82, minLon: 25, maxLon: 180 },
                    africa: { minLat: -35, maxLat: 38, minLon: -18, maxLon: 52 },
                    australia: { minLat: -44, maxLat: -10, minLon: 112, maxLon: 154 },
                    south_america: { minLat: -56, maxLat: 13, minLon: -82, maxLon: -34 },
                    oceania: { minLat: -50, maxLat: 20, minLon: 140, maxLon: -120 }
                }
            };

            const celsiusToFahrenheit = (celsius) => Math.round(celsius * 9 / 5 + 32);
            const mpsToMph = (mps) => (mps * 2.237);
            const mmToInches = (mm) => (mm * 0.0393701);

            const getRandomCoordinates = () => {
                const regionKey = elements.regionSelect.value;
                let region;

                if (regionKey === 'contiguous_us') {
                    region = state.landmasses.contiguous_us;
                } else {
                    const landmassKeys = Object.keys(state.landmasses);
                    const randomLandmassKey = landmassKeys[Math.floor(Math.random() * landmassKeys.length)];
                    region = state.landmasses[randomLandmassKey];
                }

                const latitude = Math.random() * (region.maxLat - region.minLat) + region.minLat;
                const longitude = Math.random() * (region.maxLon - region.minLon) + region.minLon;
                return { latitude: latitude.toFixed(4), longitude: longitude.toFixed(4) };
            };

            const showView = (view) => {
                elements.loading.classList.toggle('hidden', view !== 'loading');
                elements.errorMessage.classList.toggle('hidden', view !== 'error');
                elements.weatherContainer.classList.toggle('hidden', view !== 'content');
            };

            const getPrettyName = (symbolCode) => {
                const nameMap = {
                    'clearsky': 'Clear skies',
                    'fair': 'Fair',
                    'partlycloudy': 'Partly cloudy skies',
                    'cloudy': 'Cloudy skies',
                    'lightrainshowers': 'Light rain showers',
                    'rainshowers': 'Rain showers',
                    'heavyrainshowers': 'Heavy rain showers',
                    'lightrain': 'Light rain',
                    'rain': 'Rain',
                    'heavyrain': 'Heavy Rain',
                    'lightsnow': 'Light Snow',
                    'snow': 'Snow',
                    'heavysnow': 'Heavy snow',
                    'sleet': 'Sleet',
                    'thunder': 'Thunderstorms',
                    'fog': 'Foggy',
                    'default': '',
                };
                const baseCode = symbolCode.replace('_day', '').replace('_night', '');
                return nameMap[baseCode] || nameMap['default'];
            };

            const getEventFamily = (symbolCode) => {
                if (symbolCode.includes('rain') || symbolCode.includes('sleet') || symbolCode.includes('thunder')) {
                    return 'rain_or_similar';
                }
                if (symbolCode.includes('snow')) {
                    return 'snow';
                }
                if (symbolCode.includes('cloudy') || symbolCode.includes('fair')) {
                    return 'cloudy_or_clear';
                }
                return 'other';
            };

            const groupDailyPeriods = (hourlyData, timezone, eventSignificance) => {
                const periods = {
                    'morning': { name: 'Morning', startHour: 4, endHour: 12, entries: [] },
                    'afternoon': { name: 'Afternoon', startHour: 12, endHour: 18, entries: [] },
                    'evening': { name: 'Evening', startHour: 18, endHour: 22, entries: [] },
                    'night': { name: 'Night', startHour: 22, endHour: 4, entries: [] }
                };

                for (const entry of hourlyData) {
                    const utcDate = new Date(entry.time);
                    const localHour = utcDate.toLocaleTimeString('en-US', { timeZone: timezone, hour: 'numeric', hour12: false });
                    const hour = parseInt(localHour, 10);

                    if (hour >= periods.morning.startHour && hour < periods.morning.endHour) {
                        periods.morning.entries.push(entry);
                    } else if (hour >= periods.afternoon.startHour && hour < periods.afternoon.endHour) {
                        periods.afternoon.entries.push(entry);
                    } else if (hour >= periods.evening.startHour && hour < periods.evening.endHour) {
                        periods.evening.entries.push(entry);
                    }

                    if (hour >= periods.night.startHour || hour < periods.night.endHour) {
                        periods.night.entries.push(entry);
                    }
                }

                const summaries = [];
                for (const periodKey in periods) {
                    const period = periods[periodKey];
                    if (period.entries.length === 0) continue;

                    let mostSignificantEvent = { code: 'default', significance: 1, type: '' };
                    let totalPrecipitation = 0;
                    let maxWind = 0;

                    for (const entry of period.entries) {
                        const summary = entry.data?.next_1_hours?.summary;
                        if (!summary) continue;

                        const symbolCode = summary.symbol_code.replace('_day', '').replace('_night', '');
                        const significance = eventSignificance[symbolCode] || 1;
                        if (significance > mostSignificantEvent.significance) {
                            mostSignificantEvent.significance = significance;
                            mostSignificantEvent.type = symbolCode;
                        }

                        totalPrecipitation += summary.precipitation_amount || 0;
                        const windSpeed = entry.data.instant.details.wind_speed;
                        if (windSpeed > maxWind) {
                            maxWind = windSpeed;
                        }
                    }

                    // Only push a summary if a valid event was found
                    if (mostSignificantEvent.type !== '') {
                        summaries.push({
                            name: period.name,
                            type: mostSignificantEvent.type,
                            symbolCode: mostSignificantEvent.code,
                            totalPrecipitation: totalPrecipitation,
                            maxWind: maxWind
                        });
                    }
                }

                return summaries;
            };

            const generateDailyDescription = (dailyBucket, eventSignificance, timezone) => {
                const hasDetailedSummary = dailyBucket.hourlyData.some(entry => entry.data?.next_1_hours?.summary);

                if (hasDetailedSummary) {
                    const dailyPeriods = groupDailyPeriods(dailyBucket.hourlyData, timezone, eventSignificance);
                    if (dailyPeriods.length === 0) {
                        return '';
                    }
                    const summaryList = dailyPeriods.map(period => {
                        const prettyWeather = getPrettyName(period.type);
                        let part = `<strong>${period.name}:</strong> ${prettyWeather}`;

                        if (period.totalPrecipitation > 0 && period.totalPrecipitation < 0.01) {
                            part += `, Trace precipitation`;
                        } else if (period.totalPrecipitation >= 0.01) {
                            const precipDisplay = state.isFahrenheit ? `${mmToInches(period.totalPrecipitation).toFixed(2)} in` : `${period.totalPrecipitation.toFixed(2)} mm`;
                            part += `, ${precipDisplay} of rain`;
                        }

                        const windSpeed = state.isFahrenheit ? mpsToMph(period.maxWind) : period.maxWind;
                        if (windSpeed >= 25) {
                            const windDisplay = state.isFahrenheit ? `${Math.round(windSpeed)} mph` : `${Math.round(windSpeed)} m/s`;
                            part += `, Gusts up to ${windDisplay}`;
                        }
                        return part;
                    });
                    return summaryList.join('<br>');
                } else {
                    const dailySummaryCode = dailyBucket.mostSignificantEvent.type;
                    const prettyWeather = getPrettyName(dailySummaryCode);
                    if (prettyWeather) {
                        return `${prettyWeather} for the day.`;
                    }
                    return '';
                }
            };

            const processForecastData = (timeseries) => {
                if (!timeseries || timeseries.length === 0 || !state.currentTimezone) return [];

                const dailyBuckets = new Map();
                const dateFormatter = new Intl.DateTimeFormat('en-CA', {
                    timeZone: state.currentTimezone,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                });

                const eventSignificance = {
                    'thunder': 8,
                    'heavyrain': 7,
                    'rain': 6,
                    'sleet': 9,
                    'snow': 10,
                    'cloudy': 5,
                    'partlycloudy': 4,
                    'fair': 3,
                    'clearsky': 2,
                    'default': 1
                };

                for (const entry of timeseries) {
                    const utcDate = new Date(entry.time);
                    const localDateString = dateFormatter.format(utcDate);

                    if (!dailyBuckets.has(localDateString)) {
                        dailyBuckets.set(localDateString, {
                            date: new Date(localDateString),
                            highTemp: -Infinity,
                            lowTemp: Infinity,
                            maxWind: 0,
                            hourlyData: [],
                            mostSignificantEvent: { code: 'default', significance: 1, type: '' },
                        });
                    }

                    const bucket = dailyBuckets.get(localDateString);

                    const temp = entry.data?.instant?.details?.air_temperature;
                    if (temp !== undefined) {
                        bucket.highTemp = Math.max(bucket.highTemp, temp);
                        bucket.lowTemp = Math.min(bucket.lowTemp, temp);
                    }
                    const wind = entry.data?.instant?.details?.wind_speed;
                    if (wind !== undefined) {
                        bucket.maxWind = Math.max(bucket.maxWind, wind);
                    }

                    const summary = entry.data?.next_6_hours?.summary || entry.data?.next_1_hours?.summary;
                    if (summary) {
                        const symbolCode = summary.symbol_code.replace('_day', '').replace('_night', '');
                        const significance = eventSignificance[symbolCode] || 1;
                        if (significance > bucket.mostSignificantEvent.significance) {
                            bucket.mostSignificantEvent.code = summary.symbol_code;
                            bucket.mostSignificantEvent.significance = significance;
                            bucket.mostSignificantEvent.type = symbolCode;
                        }
                    }
                    bucket.hourlyData.push(entry);
                }

                const finalSummary = [];
                const todayDateString = dateFormatter.format(new Date());
                const today = new Date(todayDateString);

                for (const [localDateString, bucket] of dailyBuckets.entries()) {
                    if (bucket.highTemp === -Infinity || bucket.hourlyData.length === 0) continue;

                    const descriptionText = generateDailyDescription(bucket, eventSignificance, state.currentTimezone);

                    finalSummary.push({
                        date: bucket.date,
                        high: Math.round(bucket.highTemp),
                        low: Math.round(bucket.lowTemp),
                        wind: Math.round(bucket.maxWind),
                        symbolCode: bucket.mostSignificantEvent.code,
                        description: descriptionText,
                    });
                }

                return finalSummary
                    .filter(day => day.date >= today)
                    .sort((a, b) => a.date - b.date);
            };

            const renderForecast = () => {
                if (!state.currentForecast) return;
                const dailySummaries = processForecastData(state.currentForecast.properties.timeseries);
                elements.weatherContainer.innerHTML = '';
                dailySummaries.slice(0, state.forecastDays).forEach(day => {
                    const highTemp = state.isFahrenheit ? celsiusToFahrenheit(day.high) : day.high;
                    const lowTemp = state.isFahrenheit ? celsiusToFahrenheit(day.low) : day.low;
                    const unit = state.isFahrenheit ? 'F' : 'C';

                    const dayName = day.date.toLocaleDateString('en-US', { timeZone: state.currentTimezone, weekday: 'long' });
                    const dateString = day.date.toLocaleDateString('en-US', { timeZone: state.currentTimezone });

                    const card = document.createElement('div');
                    card.className = 'weather-card';
                    card.innerHTML = `
                        <div class="card-header">
                            <div><h3>${dayName}</h3><p>${dateString}</p></div>
                            <img src="https://api.met.no/images/weathericons/svg/${day.symbolCode}.svg" alt="${day.symbolCode}" onerror="this.src='https://placehold.co/64x64/e2e8f0/94a3b8?text=Icon'; this.onerror=null;">
                        </div>
                        <div class="card-body">
                            <span class="high-temp">${highTemp}째</span><span class="low-temp">${lowTemp}째</span><span class="unit">${unit}</span>
                        </div>
                        <p class="card-description">${day.description}</p>
                    `;
                    elements.weatherContainer.appendChild(card);
                });
            };

            const startClock = (timezone) => {
                if (state.timeUpdater) clearInterval(state.timeUpdater);
                if (!timezone) {
                    elements.localTimeDisplay.textContent = '';
                    return;
                };
                state.currentTimezone = timezone;

                const timeFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: timezone,
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                });

                const updateTime = () => {
                    elements.localTimeDisplay.textContent = `Local Time: ${timeFormatter.format(new Date())}`;
                };

                updateTime();
                state.timeUpdater = setInterval(updateTime, 1000);
            };

            const fetchWeather = async (coords, locationData) => {
                elements.weatherContainer.innerHTML = '';
                showView('loading');

                state.currentCoords = coords;
                state.currentLocationData = locationData;
                elements.locationDisplay.innerHTML = `Forecast for <span id="location-display-clickable" title="Click for more info">${locationData.displayName}</span>`;


                try {
                    const timezoneApiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.latitude}&longitude=${coords.longitude}&current_weather=false&hourly=temperature_2m&forecast_days=1&timezone=auto`;
                    const timezoneResponse = await fetch(timezoneApiUrl);
                    if (!timezoneResponse.ok) throw new Error('Open-Meteo timezone fetch failed');

                    const timezoneData = await timezoneResponse.json();
                    if (timezoneData.timezone) {
                        console.log(`Timezone resolved to '${timezoneData.timezone}' via Open-Meteo.`);
                        state.currentTimezone = timezoneData.timezone;
                    } else {
                        throw new Error('Timezone not found in Open-Meteo response');
                    }
                } catch (tzError) {
                    console.warn(`Could not fetch timezone from Open-Meteo, falling back. Error:`, tzError.message);
                    state.currentTimezone = locationData.timezone;
                }

                startClock(state.currentTimezone);

                try {
                    const apiUrl = `https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${coords.latitude}&lon=${coords.longitude}`;
                    const response = await fetch(apiUrl, { headers: { 'User-Agent': 'MossRandomWeather/1.0' } });
                    if (!response.ok) throw new Error(`API error! Status: ${response.status}`);
                    state.currentForecast = await response.json();
                    renderForecast();
                    showView('content');
                } catch (error) {
                    console.error(`Fetch failed:`, error);
                    showView('error');
                }
            }

            const geocodeAndFetch = async (query) => {
                if (!query) return;
                elements.weatherContainer.innerHTML = '';
                showView('loading');
                elements.locationDisplay.textContent = `Searching for "${query}"...`;
                elements.localTimeDisplay.textContent = '';
                try {
                    const geocodeUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`;

                    const response = await fetch(geocodeUrl, {
                        headers: { 'User-Agent': 'MossRandomWeather/1.0' }
                    });
                    if (!response.ok) throw new Error('Geocoding failed');

                    const data = await response.json();

                    if (data && data.length > 0) {
                        const { lat, lon, display_name } = data[0];

                        const queryName = display_name.split(',')[0].trim();
                        const fullName = display_name;

                        const locationData = {
                            displayName: display_name,
                            queryNames: [display_name, queryName],
                            timezone: 'UTC'
                        };

                        fetchWeather({ latitude: lat, longitude: lon }, locationData);
                    } else {
                        elements.locationDisplay.textContent = `Could not find "${query}"`;
                        showView('error');
                    }


                } catch (error) {
                    console.error("Geocoding error:", error);
                    showView('error');
                }
            }

            const findRandomNamedLocation = async () => {
                elements.weatherContainer.innerHTML = '';
                elements.searchInput.value = '';
                showView('loading');
                elements.locationDisplay.textContent = `Finding a random named location...`;
                elements.localTimeDisplay.textContent = '';

                const EXCLUDED_LOCATIONS = [" ocean", " sea", " bay", "strait ", " sound", "gulf ", " channel", " river", " channel", " bight"];

                const isExcluded = (data) => {
                    // Check multiple fields that may contain the location name
                    const namesToCheck = [data.displayName, data.locality, data.city, data.principalSubdivision];

                    return namesToCheck.some(name => {
                        if (typeof name !== 'string') {
                            return false;
                        }
                        const lowerCaseName = name.toLowerCase();
                        return EXCLUDED_LOCATIONS.some(term => lowerCaseName.includes(term));
                    });
                };

                const MAX_ATTEMPTS = 15;
                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    try {
                        const coords = getRandomCoordinates();
                        const reverseGeocodeUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${coords.latitude}&longitude=${coords.longitude}&localityLanguage=en`;
                        const response = await fetch(reverseGeocodeUrl);
                        if (!response.ok) continue;
                        const data = await response.json();

                        // Corrected Logic: Always check for excluded terms using all relevant data fields.
                        if (isExcluded(data)) {
                            console.warn(`Attempt ${i + 1} filtered out: ${data.displayName || data.locality || "Unnamed Location"}`);
                            continue;
                        }

                        // After passing the exclusion check, verify that it's a named location.
                        const isNamedLocation = data.locality || data.city;
                        if (isNamedLocation) {
                            const locationParts = [data.locality, data.city, data.principalSubdivision, data.countryName];
                            const uniqueParts = [...new Set(locationParts.filter(Boolean))];
                            const displayName = uniqueParts.join(', ');
                            const timezone = data.localityInfo?.informative?.find(i => i.description === 'time-zone')?.name || 'UTC';

                            const searchQueries = [
                                `${data.city || data.locality}, ${data.principalSubdivision}, ${data.countryName}`,
                                `${data.city || data.locality}, ${data.countryName}`,
                                `${data.city || data.locality}`
                            ].filter(query => query.trim() !== "");

                            fetchWeather(
                                { latitude: data.latitude, longitude: data.longitude },
                                { displayName, queryNames: searchQueries, timezone }
                            );
                            return;
                        }
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed, retrying.`, error);
                    }
                }

                console.error("Failed to find a named location after several attempts.");
                showView('error');
                elements.locationDisplay.textContent = 'Could not find a random location.';
            };
            async function fetchWikipediaSummary(locationData) {
                if (!locationData || !locationData.queryNames || locationData.queryNames.length === 0) return;

                elements.wikiModal.classList.add('visible');
                elements.wikiTitle.textContent = `Finding info for ${locationData.displayName}...`;
                elements.wikiSummary.innerHTML = '<p>Searching Wikipedia...</p>';

                // Prioritize the simpler queries first, which are more likely to be direct article titles
                const prioritizedQueries = locationData.queryNames;

                console.log(`Searching Wikipedia for: "${prioritizedQueries.join('", "')}"`);

                for (const query of prioritizedQueries) {
                    try {
                        const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&format=json&origin=*&srlimit=1`;
                        const searchResponse = await fetch(searchUrl);
                        const searchData = await searchResponse.json();
                        const searchResults = searchData?.query?.search;

                        if (searchResults && searchResults.length > 0) {
                            const articleTitle = searchResults[0].title;
                            const summaryUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(articleTitle)}`;
                            const summaryResponse = await fetch(summaryUrl);
                            const summaryData = await summaryResponse.json();

                            if (summaryData.type !== 'disambiguation' && summaryData.type !== 'no-summary') {
                                elements.wikiTitle.textContent = `About ${articleTitle}`;
                                elements.wikiSummary.innerHTML = summaryData.extract_html;
                                return; // Exit after the first successful search
                            }
                        }
                    } catch (error) {
                        console.error(`Attempt to search for "${query}" failed.`, error);
                    }
                }

                elements.wikiTitle.textContent = 'Information Unavailable';
                elements.wikiSummary.innerHTML = `<p>Sorry, no Wikipedia summary could be found for this location.</p>`;
            }

            const handleUnitToggle = () => { state.isFahrenheit = elements.unitToggle.checked; renderForecast(); };
            const handleSearch = () => {
                const query = elements.searchInput.value.trim();
                if (query) geocodeAndFetch(query);
            };
            const handleDaysChange = () => {
                state.forecastDays = parseInt(elements.daysSelect.value, 10);
                localStorage.setItem('forecastDays', state.forecastDays);
                renderForecast();
            };

            const initialize = () => {
                const savedDays = localStorage.getItem('forecastDays');
                state.forecastDays = savedDays ? parseInt(savedDays, 10) : 4;
                elements.daysSelect.value = state.forecastDays;
                state.isFahrenheit = elements.unitToggle.checked;

                elements.unitToggle.addEventListener('change', handleUnitToggle);
                elements.randomBtn.addEventListener('click', findRandomNamedLocation);
                elements.searchInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleSearch(); });
                elements.searchBtn.addEventListener('click', handleSearch);
                elements.daysSelect.addEventListener('change', handleDaysChange);
                elements.modalCloseBtn.addEventListener('click', () => elements.wikiModal.classList.remove('visible'));
                elements.wikiModal.addEventListener('click', (e) => { if (e.target === elements.wikiModal) { elements.wikiModal.classList.remove('visible'); } });
                elements.locationDisplay.addEventListener('click', (event) => {
                    // Check if the clicked element or its parent has the specific ID
                    const clickableSpan = event.target.closest('#location-display-clickable');
                    if (clickableSpan) {
                        // Use the saved locationData from the state
                        fetchWikipediaSummary(state.currentLocationData);
                    }
                });
                findRandomNamedLocation();
            };

            initialize();
        });
    </script>

</body>

</html>