<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moss's Random Weather Forecast</title>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Wellfleet:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Base & Layout Styles --- */
        :root {
            --color-bg: #f7fafc;
            --color-panel: #e3f0ff;
            --color-accent: #3bb273;
            --color-highlight: #ff914d;
            --color-primary: #234e70;
            --color-primary-hover: #1a3a56;
            --color-accent-hover: #2e8b57;
            --color-text-primary: #234e70;
            --color-text-secondary: #5a7a9a;
            --color-high-temp: var(--color-highlight);
            --color-low-temp: var(--color-primary);
            --color-border: #cddbf0;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -4px rgba(0, 0, 0, 0.07);
            --shadow-xl: 0 20px 25px -5px rgba(35, 78, 112, 0.1), 0 8px 10px -6px rgba(35, 78, 112, 0.1);
        }

        body {
            font-family: 'Wellfleet', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
    width: 100%; /* Ensures the container always uses 100% of the available width */
    max-width: 64rem;
    margin: auto;
    background-color: var(--color-panel);
    box-shadow: var(--shadow-xl);
    padding: 1.5rem; /* This padding can cause overflow on small screens */
    border: 1px solid var(--color-border);
    box-sizing: border-box; /* This is the key fix */
}

        /* --- Header & Controls --- */
        header {
            margin-bottom: 2rem;
        }

        .main-title {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .main-title h1 {
            font-size: 2.25rem;
            font-weight: 700;
        }

        .subheading-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .location-info p {
            font-size: 1.125rem;
            color: var(--color-text-secondary);
            margin: 0;
        }

        #local-time-display {
            font-size: 1rem;
            font-weight: 500;
            color: var(--color-primary);
            margin-top: 0.25rem;
            min-height: 1.5rem;
        }

        #location-display-clickable {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
        }

        #location-display-clickable:hover {
            color: var(--color-primary-hover);
        }

        .controls-row {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-end;
            gap: 1rem;
        }

        .search-container {
            flex: 1 1 200px;
        }

        .search-container label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-bottom: 0.25rem;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            background-color: #fff;
            border: 1px solid var(--color-border);
            padding-left: 0.75rem;
        }

        .input-wrapper:focus-within {
            box-shadow: 0 0 0 3px var(--color-accent);
        }

        .input-wrapper .search-icon-magnifying-glass {
            width: 1.5rem;
            height: 1.5rem;
            color: var(--color-text-secondary);
        }

        #search-input {
            width: 100%;
            box-sizing: border-box;
            padding: 0.75rem 0.5rem;
            border: none;
            background-color: transparent;
            outline: none;
            flex-grow: 1;
        }

        #search-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        #search-btn:hover {
            background-color: #e0e0e0;
        }

        #search-btn svg {
            width: 1.25rem;
            height: 1.25rem;
            color: var(--color-primary);
        }

        .action-button {
            padding: 0.75rem 1.5rem;
            background-color: var(--color-accent);
            color: white;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .action-button:hover {
            background-color: var(--color-accent-hover);
        }

        .unit-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #fff;
            padding: 0.25rem;
            border: 1px solid var(--color-border);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 2.5rem;
            height: 1.5rem;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 1.5rem;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 1.25rem;
            width: 1.25rem;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--color-accent);
        }

        input:checked+.slider:before {
            transform: translateX(1rem);
        }

        .settings-selector {
            display: flex;
            flex-direction: column;
            flex: 0 1 120px;
        }

        .settings-selector label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-bottom: 0.25rem;
        }

        .settings-selector select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--color-border);
            background-color: #fff;
        }

        /* --- Main Content --- */
        #loading {
            text-align: center;
            padding: 4rem 0;
        }

        #loading svg {
            animation: spin 1s linear infinite;
            margin: auto;
            height: 3rem;
            width: 3rem;
            color: var(--color-primary);
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        #loading p {
            font-size: 1.25rem;
            color: var(--color-text-secondary);
            font-weight: 500;
            margin-top: 1rem;
        }

        #error-message {
            background-color: #fee2e2;
            padding: 1.5rem;
            text-align: center;
        }

        #weather-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 1.5rem;
        }

        .weather-card {
            background-color: #fff;
            padding: 1.25rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--color-border);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
        }

        .weather-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .card-header h3 {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .card-header p {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
        }

        .card-header img {
            width: 4rem;
            height: 4rem;
        }

        .card-body {
            text-align: center;
            margin-bottom: 1rem;
        }

        .card-body .high-temp {
            font-size: 3rem;
            font-weight: 700;
            color: var(--color-highlight);
        }

        .card-body .low-temp {
            font-size: 1.875rem;
            font-weight: 500;
            color: var(--color-low-temp);
            margin-left: 0.5rem;
        }

        .card-body .unit {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--color-text-primary);
            text-align: center;
            margin-bottom: 1rem;
            flex-grow: 1;
        }

        .card-footer {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
            text-align: center;
        }

        /* --- Wikipedia Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #fff;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-xl);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        #wiki-title {
            margin-bottom: 1rem;
        }

        #wiki-summary {
            max-height: 300px;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .attribution {
            margin-top: 2rem;
            font-size: 0.8rem;
            color: var(--color-text-secondary);
            text-align: center;
        }

        .attribution a {
            color: var(--color-primary);
            text-decoration: none;
        }

        .attribution a:hover {
            text-decoration: underline;
        }

        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <div class="main-title">
                <h1>Moss's Random Weather Forecast!</h1>
            </div>
            <div class="controls-row">
                <div class="search-container">
                    <label for="search-input">Search Location</label>
                    <div class="input-wrapper">
                        <svg class="search-icon-magnifying-glass" xmlns="http://www.w3.org/2000/svg" fill="none"
                            viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
                        </svg>
                        <input type="text" id="search-input" placeholder="Search any city...">
                        <button id="search-btn" aria-label="Search">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
                            </svg>
                        </button>
                    </div>
                </div>
                <button id="random-btn" class="action-button">Random Location</button>
                <div class="settings-selector">
                    <label for="region-select">Region</label>
                    <select id="region-select">
                        <option value="world" selected>World</option>
                        <option value="contiguous_us">Contiguous US</option>
                    </select>
                </div>
                <div class="settings-selector">
                    <label for="days-select">Forecast Days</label>
                    <select id="days-select">
                        <option value="1">1 Day</option>
                        <option value="2">2 Days</option>
                        <option value="3">3 Days</option>
                        <option value="4">4 Days</option>
                        <option value="5">5 Days</option>
                        <option value="6">6 Days</option>
                        <option value="7">7 Days</option>
                        <option value="8">8 Days</option>
                        <option value="9">9 Days</option>
                    </select>
                </div>
            </div>
            <div class="subheading-row">
                <div class="location-info">
                    <p id="location-display">Finding a random location...</p>
                    <p id="local-time-display"></p>
                </div>
                <div class="unit-toggle">
                    <span>째C</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="unit-toggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span>째F</span>
                </div>
            </div>
        </header>

        <main id="main-content">
            <div id="loading"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                <p>Fetching weather data...</p>
            </div>
            <div id="error-message" class="hidden">
                <h3>Oops! Something went wrong.</h3>
                <p>Could not fetch weather details. Let's try somewhere else!</p>
            </div>
            <div id="weather-container" class="hidden"></div>
        </main>
    </div>

    <!-- Wikipedia Modal -->
    <div id="wiki-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close">&times;</button>
            <h2 id="wiki-title">Loading...</h2>
            <div id="wiki-summary">
                <p>Fetching summary from Wikipedia...</p>
            </div>
        </div>
    </div>

    <!-- Attribution Footer -->
    <footer class="attribution">
        <p>Weather data provided by the <a href="https://api.met.no" target="_blank" rel="noopener noreferrer">Norwegian
                Meteorological Institute</a>.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const elements = {
                loading: document.getElementById('loading'),
                errorMessage: document.getElementById('error-message'),
                weatherContainer: document.getElementById('weather-container'),
                locationDisplay: document.getElementById('location-display'),
                localTimeDisplay: document.getElementById('local-time-display'),
                searchInput: document.getElementById('search-input'),
                searchBtn: document.getElementById('search-btn'),
                randomBtn: document.getElementById('random-btn'),
                unitToggle: document.getElementById('unit-toggle'),
                regionSelect: document.getElementById('region-select'),
                daysSelect: document.getElementById('days-select'),
                wikiModal: document.getElementById('wiki-modal'),
                modalCloseBtn: document.getElementById('modal-close-btn'),
                wikiTitle: document.getElementById('wiki-title'),
                wikiSummary: document.getElementById('wiki-summary'),
            };

            const state = {
                isFahrenheit: true,
                forecastDays: 4,
                currentForecast: null,
                currentTimezone: null,
                timeUpdater: null,
                landmasses: {
                    contiguous_us: { minLat: 24.52, maxLat: 49.38, minLon: -124.77, maxLon: -66.95 },
                    europe: { minLat: 36, maxLat: 71, minLon: -24, maxLon: 65 },
                    asia: { minLat: -10, maxLat: 82, minLon: 25, maxLon: 180 },
                    africa: { minLat: -35, maxLat: 38, minLon: -18, maxLon: 52 },
                    australia: { minLat: -44, maxLat: -10, minLon: 112, maxLon: 154 },
                    south_america: { minLat: -56, maxLat: 13, minLon: -82, maxLon: -34 }
                }
            };

            const celsiusToFahrenheit = (celsius) => Math.round(celsius * 9 / 5 + 32);
            const mpsToMph = (mps) => Math.round(mps * 2.237);
            const mmToInches = (mm) => (mm * 0.0393701).toFixed(2);

            const getRandomCoordinates = () => {
                const regionKey = elements.regionSelect.value;
                let region;

                if (regionKey === 'contiguous_us') {
                    region = state.landmasses.contiguous_us;
                } else {
                    const landmassKeys = Object.keys(state.landmasses).filter(k => k !== 'contiguous_us');
                    const randomLandmassKey = landmassKeys[Math.floor(Math.random() * landmassKeys.length)];
                    region = state.landmasses[randomLandmassKey];
                }

                const latitude = Math.random() * (region.maxLat - region.minLat) + region.minLat;
                const longitude = Math.random() * (region.maxLon - region.minLon) + region.minLon;
                return { latitude: latitude.toFixed(4), longitude: longitude.toFixed(4) };
            };

            const showView = (view) => {
                elements.loading.classList.toggle('hidden', view !== 'loading');
                elements.errorMessage.classList.toggle('hidden', view !== 'error');
                elements.weatherContainer.classList.toggle('hidden', view !== 'content');
            };

            /**
             * REFACTORED: Definitive fix for timezone handling.
             * This function now uses Intl.DateTimeFormat to reliably determine the local date
             * for each UTC timestamp, ensuring accurate daily grouping.
             */
            const processForecastData = (timeseries) => {
                if (!timeseries || timeseries.length === 0 || !state.currentTimezone) return [];

                // This formatter is correct and remains unchanged. It reliably gets the local date.
                const dateFormatter = new Intl.DateTimeFormat('en-CA', {
                    timeZone: state.currentTimezone,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                });

                const dailyBuckets = new Map();

                for (const entry of timeseries) {
                    const utcDate = new Date(entry.time);
                    const localDateString = dateFormatter.format(utcDate); // e.g., "2025-08-21"

                    if (!dailyBuckets.has(localDateString)) {
                        dailyBuckets.set(localDateString, {
                            // FIX: Create a reliable Date object. It represents midnight UTC
                            // on that specific local date, which is perfect for sorting and filtering.
                            date: new Date(localDateString),
                            entries: [],
                            temps: [],
                            windSpeeds: [],
                        });
                    }

                    const bucket = dailyBuckets.get(localDateString);
                    bucket.entries.push(entry);
                    if (entry.data?.instant?.details?.air_temperature !== undefined) {
                        bucket.temps.push(entry.data.instant.details.air_temperature);
                    }
                    if (entry.data?.instant?.details?.wind_speed !== undefined) {
                        bucket.windSpeeds.push(entry.data.instant.details.wind_speed);
                    }
                }

                const finalSummary = [];
                for (const [localDateString, bucket] of dailyBuckets.entries()) {
                    if (bucket.entries.length === 0) continue;

                    let representativeEntry = null;

// Find a forecast that represents a mid-day period (12 PM - 6 PM)
representativeEntry = bucket.entries.find(e => {
    const localHour = new Date(e.time).toLocaleTimeString('en-US', {
        timeZone: state.currentTimezone,
        hour: 'numeric',
        hour12: false
    });
    return parseInt(localHour, 10) >= 12 && parseInt(localHour, 10) <= 18;
});

// Fallback to the entry with the most significant weather event
if (!representativeEntry) {
    representativeEntry = bucket.entries.reduce((bestEntry, currentEntry) => {
        const currentPrecip = currentEntry.data?.next_6_hours?.summary?.precipitation_amount || 0;
        const bestPrecip = bestEntry.data?.next_6_hours?.summary?.precipitation_amount || 0;
        
        // If the current entry has more precipitation, or a better icon, select it.
        // You could add more complex logic here (e.g., prioritize storms, then showers, then clear skies)
        if (currentPrecip > bestPrecip) {
            return currentEntry;
        }
        return bestEntry;
    }, bucket.entries[0]);
}
                    let symbolCode = 'default', description = 'Forecast unavailable.', precipitation = 0;

                    if (representativeEntry) {
                        const summary = representativeEntry.data.next_6_hours?.summary || representativeEntry.data.next_1_hours?.summary;
                        if (summary) {
                            symbolCode = summary.symbol_code;
                            precipitation = summary.precipitation_amount || 0;
                        }
                        const details = representativeEntry.data.next_1_hours?.details || representativeEntry.data.instant?.details;
                        if (details) {
                            description = `Humidity: ${details.relative_humidity?.toFixed(0) || 'N/A'}%.`;
                        }
                    }

                    finalSummary.push({
                        date: bucket.date,
                        high: bucket.temps.length > 0 ? Math.round(Math.max(...bucket.temps)) : 'N/A',
                        low: bucket.temps.length > 0 ? Math.round(Math.min(...bucket.temps)) : 'N/A',
                        wind: bucket.windSpeeds.length > 0 ? Math.max(...bucket.windSpeeds) : 0,
                        symbolCode, description, precipitation
                    });
                }

                // FIX: Get today's date in the target timezone without unreliable parsing.
                const todayDateString = dateFormatter.format(new Date());
                const today = new Date(todayDateString);

                return finalSummary
                    .filter(day => day.date >= today) // Now the filter works correctly.
                    .sort((a, b) => a.date - b.date);
            };

            const renderForecast = () => {
                if (!state.currentForecast) return;
                const dailySummaries = processForecastData(state.currentForecast.properties.timeseries);
                elements.weatherContainer.innerHTML = '';
                dailySummaries.slice(0, state.forecastDays).forEach(day => {
                    const highTemp = state.isFahrenheit ? celsiusToFahrenheit(day.high) : day.high;
                    const lowTemp = state.isFahrenheit ? celsiusToFahrenheit(day.low) : day.low;
                    const windSpeedMph = mpsToMph(day.wind);
                    const precip = state.isFahrenheit ? `${mmToInches(day.precipitation)} in` : `${day.precipitation} mm`;
                    const unit = state.isFahrenheit ? 'F' : 'C';

                    // Use the correct timezone for display
                    const dayName = day.date.toLocaleDateString('en-US', { timeZone: state.currentTimezone, weekday: 'long' });
                    const dateString = day.date.toLocaleDateString('en-US', { timeZone: state.currentTimezone });

                    const card = document.createElement('div');
                    card.className = 'weather-card';
                    card.innerHTML = `
                        <div class="card-header">
                            <div><h3>${dayName}</h3><p>${dateString}</p></div>
                            <img src="https://api.met.no/images/weathericons/svg/${day.symbolCode}.svg" alt="${day.symbolCode}" onerror="this.src='https://placehold.co/64x64/e2e8f0/94a3b8?text=Icon'; this.onerror=null;">
                        </div>
                        <div class="card-body">
                            <span class="high-temp">${highTemp}째</span><span class="low-temp">${lowTemp}째</span><span class="unit">${unit}</span>
                        </div>
                        <p class="card-description">Precipitation: ${precip}<br>${day.description}</p>
                        <div class="card-footer"><p><strong>Wind:</strong> ${windSpeedMph} mph</p></div>
                    `;
                    elements.weatherContainer.appendChild(card);
                });
            };

            const startClock = (timezone) => {
                if (state.timeUpdater) clearInterval(state.timeUpdater);
                if (!timezone) {
                    elements.localTimeDisplay.textContent = '';
                    return;
                };
                state.currentTimezone = timezone;

                // Use Intl.DateTimeFormat for reliable time display
                const timeFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: timezone,
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                });

                const updateTime = () => {
                    elements.localTimeDisplay.textContent = `Local Time: ${timeFormatter.format(new Date())}`;
                };

                updateTime();
                state.timeUpdater = setInterval(updateTime, 1000);
            };

            const fetchWeather = async (coords, locationData) => {
                elements.weatherContainer.innerHTML = '';
                showView('loading');



                state.currentCoords = coords; // Save the current coordinates
                elements.locationDisplay.innerHTML = `Forecast for <span id="location-display-clickable" title="Click for more info">${locationData.displayName}</span>`;
                const clickableSpan = document.getElementById('location-display-clickable');
                if (clickableSpan) {
                    clickableSpan.addEventListener('click', () => fetchWikipediaSummary(locationData));
                }

                // This block fetches a precise timezone from Open-Meteo before getting weather data.
                try {
                    // We ask for minimal forecast data just to get the timezone information.
                    const timezoneApiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.latitude}&longitude=${coords.longitude}&current_weather=false&hourly=temperature_2m&forecast_days=1&timezone=auto`;
                    const timezoneResponse = await fetch(timezoneApiUrl);
                    if (!timezoneResponse.ok) throw new Error('Open-Meteo timezone fetch failed');

                    const timezoneData = await timezoneResponse.json();
                    if (timezoneData.timezone) {
                        console.log(`Timezone resolved to '${timezoneData.timezone}' via Open-Meteo.`);
                        state.currentTimezone = timezoneData.timezone; // Use the more accurate timezone
                    } else {
                        throw new Error('Timezone not found in Open-Meteo response');
                    }
                } catch (tzError) {
                    console.warn(`Could not fetch timezone from Open-Meteo, falling back. Error:`, tzError.message);
                    state.currentTimezone = locationData.timezone; // Fallback to the less reliable timezone
                }

                // The clock is now started with the best available timezone.
                startClock(state.currentTimezone);

                try {
                    const apiUrl = `https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${coords.latitude}&lon=${coords.longitude}`;
                    const response = await fetch(apiUrl, { headers: { 'User-Agent': 'MossRandomWeather/1.0' } });
                    if (!response.ok) throw new Error(`API error! Status: ${response.status}`);
                    state.currentForecast = await response.json();
                    renderForecast();
                    showView('content');
                } catch (error) {
                    console.error(`Fetch failed:`, error);
                    showView('error');
                }
            }

            const geocodeAndFetch = async (query) => {
                if (!query) return;
                elements.weatherContainer.innerHTML = '';
                showView('loading');
                elements.locationDisplay.textContent = `Searching for "${query}"...`;
                elements.localTimeDisplay.textContent = '';
                try {
                    // --- CHANGED: Using OpenStreetMap's Nominatim API ---
                    const geocodeUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`;

                    const response = await fetch(geocodeUrl, {
                        headers: { 'User-Agent': 'MossRandomWeather/1.0' }
                    });
                    if (!response.ok) throw new Error('Geocoding failed');

                    const data = await response.json();

                    // --- CHANGED: Parsing the new API response format ---
                    if (data && data.length > 0) {
                        const { lat, lon, display_name } = data[0];

                        // For the Wikipedia search, let's grab the first part of the display name.
                        const queryName = display_name.split(',')[0];

                        // OpenStreetMap doesn't provide a timezone, so we'll default to UTC.
                        // This is fine because our app already fetches the correct timezone from Open-Meteo.
                        const locationData = {
                            displayName: display_name,
                            queryName: queryName,
                            timezone: 'UTC'
                        };

                        fetchWeather({ latitude: lat, longitude: lon }, locationData);
                    } else {
                        elements.locationDisplay.textContent = `Could not find "${query}"`;
                        showView('error');
                    }
                } catch (error) {
                    console.error("Geocoding error:", error);
                    showView('error');
                }
            }

            const findRandomNamedLocation = async () => {
                elements.weatherContainer.innerHTML = '';
                showView('loading');
                elements.locationDisplay.textContent = `Finding a random named location...`;
                elements.localTimeDisplay.textContent = '';

                const MAX_ATTEMPTS = 15;
                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    try {
                        const coords = getRandomCoordinates();
                        const reverseGeocodeUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${coords.latitude}&longitude=${coords.longitude}&localityLanguage=en`;
                        const response = await fetch(reverseGeocodeUrl);
                        if (!response.ok) continue;
                        const data = await response.json();

                        if (data.locality || data.city) {
                            const locationParts = [data.locality, data.city, data.principalSubdivision, data.countryName];
                            const uniqueParts = [...new Set(locationParts.filter(Boolean))];
                            const displayName = uniqueParts.join(', ');
                            const timezone = data.localityInfo?.informative?.find(i => i.description === 'time-zone')?.name || 'UTC';

                            // Create a list of prioritized search queries
                            const searchQueries = [
                                // Most specific: "City, State/Subdivision, Country"
                                `${data.city || data.locality}, ${data.principalSubdivision}, ${data.countryName}`,
                                // Less specific: "City, Country"
                                `${data.city || data.locality}, ${data.countryName}`,
                                // Least specific: just "City"
                                `${data.city || data.locality}`
                            ].filter(query => query.trim() !== ""); // Filter out empty strings

                            fetchWeather(
                                { latitude: data.latitude, longitude: data.longitude },
                                { displayName, queryNames: searchQueries, timezone }
                            );
                            return;
                        }
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed, retrying.`, error);
                    }
                }

                console.error("Failed to find a named location after several attempts.");
                showView('error');
                elements.locationDisplay.textContent = 'Could not find a random location.';
            };

            async function fetchWikipediaSummary(locationData) {
                if (!locationData || !locationData.queryNames || locationData.queryNames.length === 0) return;

                elements.wikiModal.classList.add('visible');
                elements.wikiTitle.textContent = `Finding info for ${locationData.displayName}...`;
                elements.wikiSummary.innerHTML = '<p>Searching Wikipedia...</p>';

                for (const query of locationData.queryNames) {
                    try {
                        const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&format=json&origin=*&srlimit=1`;
                        const searchResponse = await fetch(searchUrl);
                        const searchData = await searchResponse.json();
                        const searchResults = searchData?.query?.search;

                        // If an article is found, proceed to fetch the summary and stop the loop.
                        if (searchResults && searchResults.length > 0) {
                            const articleTitle = searchResults[0].title;
                            const summaryUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(articleTitle)}`;
                            const summaryResponse = await fetch(summaryUrl);
                            const summaryData = await summaryResponse.json();

                            elements.wikiTitle.textContent = `About ${articleTitle}`;
                            elements.wikiSummary.innerHTML = summaryData.type === 'disambiguation'
                                ? `<p>The search result "${articleTitle}" is a disambiguation page. No specific summary is available.</p>`
                                : summaryData.extract_html;

                            return; // Exit the function after a successful find.
                        }
                    } catch (error) {
                        console.error(`Attempt to search for "${query}" failed.`, error);
                        // Continue the loop to try the next, less specific query.
                    }
                }

                // If the loop completes without finding an article.
                elements.wikiTitle.textContent = 'Information Unavailable';
                elements.wikiSummary.innerHTML = `<p>Sorry, no Wikipedia summary could be found for this location.</p>`;
            }

            const handleUnitToggle = () => { state.isFahrenheit = elements.unitToggle.checked; renderForecast(); };
            const handleSearch = () => {
                const query = elements.searchInput.value.trim();
                if (query) geocodeAndFetch(query);
            };
            const handleDaysChange = () => {
                state.forecastDays = parseInt(elements.daysSelect.value, 10);
                localStorage.setItem('forecastDays', state.forecastDays);
                renderForecast();
            };

            const initialize = () => {
                const savedDays = localStorage.getItem('forecastDays');
                state.forecastDays = savedDays ? parseInt(savedDays, 10) : 4;
                elements.daysSelect.value = state.forecastDays;
                state.isFahrenheit = elements.unitToggle.checked;

                elements.unitToggle.addEventListener('change', handleUnitToggle);
                elements.randomBtn.addEventListener('click', findRandomNamedLocation);
                elements.searchInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleSearch(); });
                elements.searchBtn.addEventListener('click', handleSearch);
                elements.daysSelect.addEventListener('change', handleDaysChange);
                elements.modalCloseBtn.addEventListener('click', () => elements.wikiModal.classList.remove('visible'));
                elements.wikiModal.addEventListener('click', (e) => { if (e.target === elements.wikiModal) { elements.wikiModal.classList.remove('visible'); } });

                findRandomNamedLocation();
            };

            initialize();
        });
    </script>

</body>

</html>