<!DOCTYPE html>
<html lang="en">

<head>

    <meta property="og:title" content="Bug & Moss Really Simple Soundboard">
    <meta property="og:description"
        content="A simple, feature-rich, fully-local, offline-capable infinite soundboard app for broad (and pod) casting.">
    <meta property="og:image" content="https://bugandmoss.com/images/soundboardscreenshot.jpg">
    <meta property="og:url" content="https://bugandmoss.com/soundboard.html">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Soundboard | B&M Really Simple Soundboard</title>
<style>
/* =================================================================== */
/* CORE LAYOUT & THEMING
/* =================================================================== */
:root {
    /* Base Color Palette */
    --background-color: #f7fafc;
    --panel-color: #95c7ff;
    --accent-color: #3bb273;
    --highlight-color: #ff914d;
    
    /* Text Colors (Static) */
    --primary-color: #234e70;   /* Dark Text */
    --secondary-color: #cce0ec; /* Light Text */

    /* Dynamic Text Colors (Set by JS) */
    --panel-color-text: #234e70;
    --accent-color-text: #234e70;
    --highlight-color-text: #234e70;
    --primary-color-text: #cce0ec;
    --background-color-text: #234e70;

    /* Typography */
    --font-family-primary: 'Wellfleet', sans-serif;
}

body {
    font-family: var(--font-family-primary);
    background-color: var(--background-color);
    color: var(--background-color-text);
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    padding: 2rem;
    box-sizing: border-box;
    touch-action: manipulation;
}

.container {
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
}

#soundboard-title {
    text-align: center;
    cursor: pointer;
    padding: 1rem;
    transition: background-color 0.3s ease;
}

#soundboard-title:hover,
#soundboard-title:focus {
    background-color: var(--panel-color);
    outline: none;
}

/* =================================================================== */
/* BUTTONS & GENERAL CONTROLS
/* =================================================================== */
button {
    font-family: var(--font-family-primary);
    border: none;
    cursor: pointer;
    transition: filter 0.3s ease;
}

#button-color-picker {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 40px;
    height: 40px;
    padding: 0;
    border: 2px solid var(--primary-color);
    background-color: transparent;
    cursor: pointer;
}

.title-and-color {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.title-and-color input[type="text"] {
    flex-grow: 1; /* Allows the text input to fill available space */
}

button:hover {
    filter: brightness(90%);
}

.danger {
    background-color: #d9534f!important; /* A consistent red for danger actions */
    color: white!important;
    padding: 1rem;
}

.slider-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.slider-group label {
    width: 60px;
    font-size: 0.875rem;
    color: var(--panel-color-text);
}

input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    height: 4px;
    background: var(--secondary-color);
    outline: none;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    background: var(--accent-color);
    cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: var(--accent-color);
    cursor: pointer;
}

/* =================================================================== */
/* GRIDS & CARDS
/* =================================================================== */
.soundboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
}

.sound-card {
    background-color: var(--panel-color);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    align-self: start; /* Prevents cards from stretching vertically */
}

.hover-glow {
    box-shadow: 0px 0px 8px var(--highlight-color) !important;
}

/* --- Drag & Drop Styles --- */
.soundboard-grid.rearrange-mode {
    cursor: grab;
}

.soundboard-grid.rearrange-mode .sound-card {
    transform: rotate(1deg);
    border: 2px solid var(--highlight-color);
    cursor: grab;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.soundboard-grid.rearrange-mode .sound-card:hover {
    transform: scale(1.02);
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
}

.sound-card.dragging {
    opacity: 0.5;
}

.soundboard-grid.rearrange-mode .sound-card.drag-over {
    border: 2px dashed var(--highlight-color);
    transform: scale(1.05);
}

/* =================================================================== */
/* SOUND BUTTON CARDS
/* =================================================================== */
.sound-button {
    position: relative;
    width: 100%;
    height: 100px;
    background-color: var(--accent-color);
    color: var(--accent-color-text);
    font-size: 1.25rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-overlay {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.2);
    transition: width 0.1s linear;
}

.button-text {
    position: relative;
    z-index: 1;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.settings-triangle-btn {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 0;
    height: 0;
    border-bottom: 40px solid var(--highlight-color);
    border-left: 40px solid transparent;
    z-index: 2;
}

.settings-triangle-btn svg {
    position: absolute;
    top: -30px;
    left: 10px;
    z-index: 3;
    width: 20px;
    height: 20px;
    color: var(--highlight-color-text);
}

.sound-controls .speed-display {
    color: var(--panel-color-text);
}

/* =================================================================== */
/* CONTROL CARD
/* =================================================================== */
#control-card-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
}

.span-two-columns {
    grid-column: span 2;
}

/* General button style within the control card */
#control-card-actions button {
    padding: 0.75rem;
    font-size: 1.2rem;
    font-weight: 500;
    text-align: center;
    background-color: var(--accent-color);
    color: var(--accent-color-text);
}

/* Specific overrides for uniquely colored buttons */
#rearrange-mode-btn {
    background-color: var(--highlight-color)!important;
    color: var(--highlight-color-text)!important;
}

#switch-board-btn {
    background-color: var(--primary-color)!important;
    color: var(--primary-color-text)!important;
}

/* =================================================================== */
/* TIMER CARDS
/* =================================================================== */


.timer-title {
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    color: var(--panel-color-text);
    border: 2px solid transparent;
    transition: border-color 0.2s ease;
}

.timer-title[contenteditable="true"] {
    background-color: var(--background-color);
    border-color: var(--highlight-color);
    outline: none;
    cursor: text;
}

.timer-display {
    font-size: 2.5rem;
    font-weight: bold;
    text-align: center;
    padding: 0.5rem;
    background-color: var(--panel-color);
    color: var(--panel-color-text);
    border: 2px solid var(--secondary-color);
        /* Creates a darkening overlay on top of the panel color */
    background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2));
}

.timer-display.running {
    color: var(--accent-color);
}

.timer-options-toggle label,
.timer-mode-selector label,
.timer-sound-select label {
    color: var(--panel-color-text);
    user-select: none;
}

.timer-options-toggle{
    margin-bottom: 1rem;
}
.timer-sound-select {
    padding-top:0.5rem;
    padding-bottom:0.5rem;
}

.timer-controls .slider-group span {
    min-width: 25px;
    text-align: center;
    color: var(--panel-color-text);
}

.timer-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
}

.timer-buttons button {
    flex-grow: 1;
    font-weight: bold;
    padding: 0.75rem 1.5rem;
    background-color: var(--accent-color);
    color: var(--accent-color-text);
}

.timer-buttons .reset-timer-btn {
    background-color: var(--highlight-color);
    color: var(--highlight-color-text);
}

.remove-timer-btn {
    width: 100%;
    margin-top: 1rem;
    padding: 0.75rem;
    background-color: var(--highlight-color);
    color: var(--highlight-color-text);
}

.timer-options-container.hidden-options {
    display: none;
}

/* =================================================================== */
/* NOTEPAD CARDS
/* =================================================================== */
.notepad-card {
    align-self: stretch; /* Allows notepad to fill vertical space, overriding .sound-card */
}

.notepad-tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--secondary-color);
}

.notepad-tab, .add-page-btn {
    border: 1px solid var(--secondary-color);
    background-color: var(--background-color);
    padding: 0.1rem 0.4rem;
    cursor: pointer;
    font-size: 0.8rem;
    border-radius: 4px;
}

.notepad-tab-title {
    cursor: pointer;
    outline: none;
    font-size: 1rem;
    white-space: nowrap;
    user-select: none;
}

.notepad-tab.active {
    background-color: var(--accent-color);
    color: var(--accent-color-text);
    font-weight: bold;
    border-color: var(--accent-color);
}

.delete-page-btn {
    color: darkred;
    font-weight: bold;
    cursor: pointer;
}

.notepad-content {
    flex-grow: 1;
    width: 100%;
    border: none;
    background-color: var(--background-color);
    padding: 0.5rem;
    font-family: sans-serif;
    font-size: 1rem;
    color: var(--background-color-text);
    resize: vertical;
    box-sizing: border-box;
    min-height: 150px;
}

.notepad-content:focus {
    outline: 1px solid var(--highlight-color);
}

/* =================================================================== */
/* MODALS
/* =================================================================== */
.modal, .confirm-modal {
    display: none;
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(3px);
    align-items: center;
    justify-content: center;
}

.modal-content, .confirm-modal-content {
    background-color: var(--panel-color);
    color: var(--panel-color-text);
    padding: 2rem;
    width: 90%;
    max-width: 600px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-height: 80vh;
    overflow-y: auto;
}

.modal-section {
    margin-bottom: 1.5rem;
}

.modal-section h3, .modal-section h4 {
    margin-bottom: 0.75rem;
    border-bottom: 1px solid var(--secondary-color);
    padding-bottom: 0.25rem;
}

.modal-section label {
    display: block;
    margin-bottom: 0.5rem;
}

.modal-section input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    background-color: var(--background-color);
    border: 1px solid var(--primary-color);
    color: var(--background-color-text);
}

.modal-actions-row {
    display: flex;
    justify-content: space-between;
}

/* --- Specific Modal Buttons --- */
.file-input-container label, .modal-actions-row button, #create-new-board-btn {
    background-color: var(--accent-color);
    color: var(--accent-color-text);
    padding: 0.75rem 1.5rem;
    text-align: center;
}

#clear-files-btn {
    background-color: var(--highlight-color);
    color: var(--highlight-color-text);
}

/* --- File List --- */
.file-list {
    list-style: none;
    padding: 0;
}

.file-list li {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background-color: var(--background-color);
    color: var(--background-color-text);
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    border: 1px solid var(--panel-color);
}

.file-list button {
    background-color: var(--highlight-color);
    color: var(--highlight-color-text);
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
}

/* --- Checkboxes --- */
.modal-checkbox-group label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
}

.modal-checkbox-group input[type="checkbox"] {
    appearance: none;
    width: 1.25rem;
    height: 1.25rem;
    border: 2px solid var(--primary-color);
    cursor: pointer;
    position: relative;
     display: flex;

}


        .modal-actions-row {
            display: flex;
            justify-content: space-between;

        }

        .modal-checkbox-group {
            display: flex;
            gap: 1.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

.modal-checkbox-group input[type="checkbox"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}

.modal-checkbox-group input[type="checkbox"]:checked::after {
    content: 'âœ”';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--accent-color-text);
    font-size: 1rem;
}

/* --- Color Pickers --- */
.color-palette-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 1rem;
}

.color-box {
    position: relative;
    width: 100%;
    padding-top: 100%; /* Creates a square aspect ratio */
}

.color-box input[type="color"] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    border: none;
    cursor: pointer;
}

.color-box label {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    text-align: center;
    padding: 0.25rem;
    font-size: 0.75rem;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    pointer-events: none; /* Allows clicks to go through to the color input */
}

/* --- Confirmation Modal --- */
.confirm-modal-content {
    text-align: center;
    max-width: 400px;
}

.confirm-modal-actions {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
}

.confirm-modal-actions button {
    padding: 0.75rem 1.5rem;
    font-weight: bold;
}

.confirm-yes-btn {
    background-color: var(--accent-color);
    color: var(--accent-color-text);
}

.confirm-no-btn {
    background-color: var(--highlight-color);
    color: var(--highlight-color-text);
}

/* =================================================================== */
/* HELPER BUG & ACCORDION
/* =================================================================== */
#help-bug-btn {
    position: fixed;
    bottom: 1rem;
    left: 1rem;
    z-index: 50;
    width: 50px;
    height: 50px;
    background: transparent;
}

.bug-moving {
    animation: skitter 8s ease-in-out infinite;
}

.accordion-header {
    width: 100%;
    background-color: transparent;
    text-align: left;
    padding: 1rem;
    font-size: 1.1rem;
    font-weight: bold;
    position: relative;
    color: var(--panel-color-text);
}

.accordion-header::after {
    content: '+';
    position: absolute;
    right: 1rem;
    font-size: 1.5rem;
    transition: transform 0.2s ease;
}

.accordion-header.active::after {
    transform: rotate(45deg);
}

.accordion-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    background-color: var(--background-color);
    padding: 0 1rem;
    white-space: pre-line;
}

.accordion-content.active {
    max-height: 200px; /* Adjust as needed */
    overflow-y: auto;
    padding: 1rem;
}

@keyframes skitter {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    4% { transform: translate(15px, 5px) rotate(25deg); }
    8% { transform: translate(15px, 5px) rotate(25deg); }
    15% { transform: translate(-10px, -10px) rotate(-15deg); }
    18% { transform: translate(-8px, -12px) rotate(-20deg); }
    20% { transform: translate(-10px, -10px) rotate(-15deg); }
    28% { transform: translate(20px, -5px) rotate(40deg); }
    35% { transform: translate(20px, -5px) rotate(40deg); }
    50% { transform: translate(-15px, 20px) rotate(-30deg); }
    60% { transform: translate(-15px, 20px) rotate(-30deg); }
    63% { transform: translate(-12px, 22px) rotate(-35deg); }
    65% { transform: translate(-15px, 20px) rotate(-30deg); }
    75% { transform: translate(10px, 10px) rotate(15deg); }
    85% { transform: translate(10px, 10px) rotate(15deg); }
    95% { transform: translate(2px, 2px) rotate(5deg); }
}
</style>
</head>

<body>
    <div class="container">
        <h1 id="soundboard-title" contenteditable="true">Bug & Moss Really Simple Soundboard</h1>

        <div id="soundboard-grid" class="soundboard-grid">
        </div>

    </div>

    <template id="notepad-card-template">
        <div class="sound-card special-function-card notepad-card">
            <div class="notepad-tabs">
                <button class="add-page-btn">+</button>
            </div>
            <textarea class="notepad-content" placeholder="Type your notes here..."></textarea>
        </div>
    </template>

    <template id="timer-card-template">
    <div class="sound-card special-function-card timer-card">
        <div class="timer-title" contenteditable="false">New Timer</div>
        <div class="timer-display">00:00</div>
        <div class="timer-controls">
            <div class="timer-options-toggle">
                <label>
                    <input type="checkbox" class="hide-timer-options-toggle" value="false">
                    Lock Timer Settings
                </label>
            </div>
            <div class="timer-options-container">
                <!-- New: Mode Selection -->
                <div class="timer-mode-selector" style="display: flex; justify-content: center; gap: 1rem; margin-bottom: 0.75rem;">
                    <label>
                        <input type="radio" name="timer-mode" class="timer-mode-radio" value="timer" checked> Timer
                    </label>
                    <label>
                        <input type="radio" name="timer-mode" class="timer-mode-radio" value="stopwatch"> Stopwatch
                    </label>
                </div>

                <div class="slider-group">
                    <label>Minutes:</label>
                    <input type="range" class="timer-minutes-range" min="0" max="90" value="0">
                    <span class="timer-minutes-value">0</span>
                </div>
                <div class="slider-group">
                    <label>Seconds:</label>
                    <input type="range" class="timer-seconds-range" min="0" max="59" value="30">
                    <span class="timer-seconds-value">0</span>
                </div>

                <!-- New: Loop Option -->
                <div class="timer-sound-select">
                    <label>
                        <input type="checkbox" class="timer-loop-checkbox" style="margin-right: 0.5rem;">Loop
                    </label>
                </div>

                <div class="timer-sound-select start-sound-container">
                    <label class="start-sound-label">Start with:</label>
                    <select class="timer-start-sound"></select>
                </div>
                <div class="timer-sound-select end-sound-container">
                    <label>End with:</label>
                    <select class="timer-end-sound"></select>
                </div>
            </div>
            <div class="timer-buttons">
                <button class="start-pause-timer-btn">Start</button>
                <button class="reset-timer-btn">Reset</button>
            </div>

            <div class="timer-options-container">
                
                <button class="remove-timer-btn danger">Remove Timer</button>
            </div>
        </div>
    </div>
</template>

    <div id="control-card" class="sound-card special-function-card" data-card-type="control" data-card-id="control-card"
        style="display: none;">
        <div id="control-card-actions">
            <button id="add-btn-plus" title="Add a new button" class="span-two-columns">Add Sound</button>
            <button id="add-timer-btn">Add Timer</button>
            <button id="add-notepad-btn">Add Note</button>
            <button id="rearrange-mode-btn"
                class="span-two-columns">Rearrange</button>
            <button id="upload-config-btn">Upload</button>
            <button id="download-config-btn">Download</button>
            <button id="switch-board-btn" class="span-two-columns">Switch
                Board</button>
            <button id="cosmetics-btn">Cosmetics</button>
            <button id="db-manager-btn">Storage</button>
            

        </div>
    </div>


    <input type="file" id="upload-config-input" accept="application/json" style="display: none;">

    <div id="confirm-modal" class="confirm-modal">
        <div class="confirm-modal-content">
            <p id="confirm-modal-message"></p>
            <div class="confirm-modal-actions">
                <button id="confirm-yes-btn" class="confirm-yes-btn">Yes</button>
                <button id="confirm-no-btn" class="confirm-no-btn">No</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div id="modal-content" class="modal-content">


            <div class="modal-section">
                <h3>Button Settings</h3>
                <div class="title-and-color">
                    <input type="color" id="button-color-picker">
                    <input type="text" style="font-size: 1rem;" id="button-name-input">
                </div>
            </div>


            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <label>
                        <input type="checkbox" id="shuffle-checkbox">
                        Random
                    </label>
                    <label>
                        <input type="checkbox" id="autoplay-checkbox">
                        Autoplay
                    </label>
                    <label>
                        <input type="checkbox" id="priority-checkbox">
                        Priority
                    </label>
                    <label>
                        <input type="checkbox" id="loop-checkbox">
                        Loop
                    </label>

                </div>
            </div>

            <div class="modal-section">
                <h3>Audio Files</h3>
                <div class="file-input-container">
                    <label for="add-file-input" class="file-input-label">Add Audio File</label>
                    <input type="file" id="add-file-input" accept="audio/*" multiple style="display: none;">
                </div>
                <ul id="file-list" class="file-list"></ul>
                <div class="modal-actions-row">
                    <button id="remove-button-modal" class="danger">Delete Button</button>
                    <button id="clear-files-btn"
                        style="margin-left:auto; background-color:var(--highlight-color); color:var(--primary-color)">Clear
                        All</button>
                </div>
            </div>



        </div>
    </div>



    <div id="db-manager-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Local Database Manager</h3>
            </div>
            <div class="modal-section">
                <div id="db-stats-container">
                    <div class="stat-line">
                        <span>Total Buttons:</span> <span id="db-button-count">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>IndexedDB Usage:</span> <span id="db-usage">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>Available Quota:</span> <span id="db-quota">Calculating...</span>
                    </div>
                </div>
            </div>
            <div class="modal-section">
                <h3>Stored Sounds</h3>
                <ul id="db-file-list">
                    <li><small>No sounds found.</small></li>
                </ul>
            </div>
            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <input type="checkbox" id="persistent-storage-checkbox">
                    <h4>Storage Durability</h4>
                </div>
                <small>Recommended for offline use. Your browser may ask for permission.</small>
            </div>

            <div class="modal-section">
        </div>

            <div class="modal-section">
                <button id="clear-database-btn" class="danger">Delete Everything & Try Again</button>
            </div>
        </div>
    </div>

    <div id="cosmetics-modal" class="modal">
        <div class="modal-content">
            <div class="modal-section">
                <h4>Font Selection</h4>
                <label for="font-input">Enter a font name:</label>
                <input type="text" id="font-input" placeholder="Wellfleet">
                <small>You can use any font from <a href="https://fonts.google.com/" target="_blank"
                        rel="noopener noreferrer">Google
                        Fonts</a>.</small>
            </div>
            <div class="modal-section">
                <h4>Color Palette</h4>
                <div class="color-palette-grid">

                    <div class="color-picker-group color-box">
                        <input type="color" id="primary-color-picker" data-css-var="--primary-color">
                        <label for="primary-color-picker">Dark Text</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="secondary-color-picker" data-css-var="--secondary-color">
                        <label for="secondary-color-picker">Light Text</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="panel-color-picker" data-css-var="--panel-color">
                        <label for="panel-color-picker">Panel</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="background-color-picker" data-css-var="--background-color">
                        <label for="background-color-picker">Background</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="accent-color-picker" data-css-var="--accent-color">
                        <label for="accent-color-picker">Accent</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="highlight-color-picker" data-css-var="--highlight-color">
                        <label for="highlight-color-picker">Highlight</label>
                    </div>
                    <button id="delete-cosmetics-key-btn" class="danger">Reset Appearance</button>
                </div>
            </div>
        </div>

    </div>
    <div id="board-switcher-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Switch Soundboard</h3>
            </div>
            <div class="modal-section">
                <ul id="board-list" class="file-list">
                </ul>
            </div>

            <div class="modal-section" style="border-top: 1px solid var(--secondary-color); padding-top: 1.5rem;">
                <h4>Create New Board</h4>
                <div class="title-and-color">
                    <input type="text" id="new-board-name-input" placeholder="New board name...">
                    <button id="create-new-board-btn">Create</button>
                </div>
            </div>

        </div>
    </div>
    <script>

        function formatIdAsTitle(id) {
            if (!id) return '';
            return id
                .replace(/-/g, ' ') // my-gaming-sounds -> my gaming sounds
                .split(' ')          // -> ['my', 'gaming', 'sounds']
                .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // -> ['My', 'Gaming', 'Sounds']
                .join(' ');          // -> "My Gaming Sounds"
        }

        function debounce(func, delay) {
                let timeoutId;
                return function (...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            }

        function slugify(text) {
            return text.toString().toLowerCase().trim()
                .replace(/\s+/g, '-')           // Replace spaces with -
                .replace(/[^\w\-]+/g, '')       // Remove all non-word chars except -
                .replace(/\-\-+/g, '-');          // Replace multiple - with single -
        }

        function loadGoogleFonts(fontNames) {
                if (!fontNames || fontNames.length === 0) {
                    console.warn("No font names provided to loadGoogleFonts.");
                    return;
                }

                const FONT_STYLESHEET_ID = 'google-fonts-stylesheet';

                // Check for and remove the old font link, if it exists
                const oldLink = document.getElementById(FONT_STYLESHEET_ID);
                if (oldLink) {
                    oldLink.remove();
                }

                // Create and add the new font link
                const formattedNames = fontNames.map(name => name.replace(/\s+/g, '+'));
                const fontUrl = `https://fonts.googleapis.com/css?family=${formattedNames.join('|')}&display=swap`;
                const link = document.createElement('link');
                link.id = FONT_STYLESHEET_ID; // Give the new link a consistent ID
                link.href = fontUrl;
                link.rel = 'stylesheet';
                document.head.appendChild(link);
            };

        function getContrastColor(hexColor) {
            // 1. Remove '#' and convert hex to R, G, B numbers
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            // 2. Calculate the luminance using the standard formula
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // 3. Return dark or light color based on a threshold
            return luminance > 0.45 ? 'var(--primary-color)' : 'var(--secondary-color)'; // Returns dark for light backgrounds, and vice-versa
        }

        document.addEventListener('DOMContentLoaded', () => {

            // --- PWA INSTALL HANDLER ---
            let deferredPrompt; // This variable will save the event
            const installButton = document.getElementById('install-pwa-btn');

            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent the mini-infobar from appearing on mobile
                e.preventDefault();
                // Stash the event so it can be triggered later.
                deferredPrompt = e;
                // Update UI to notify the user they can install the PWA
                if (installButton) {
                    installButton.disabled = false;
                }
            });

            if (installButton) {
                installButton.addEventListener('click', async () => {
                    if (!deferredPrompt) {
                        return; // The prompt isn't available
                    }
                    // Show the install prompt
                    deferredPrompt.prompt();
                    // Wait for the user to respond to the prompt
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    // We've used the prompt, and can't use it again, throw it away
                    deferredPrompt = null;
                    // Hide the button
                    installButton.disabled = true;
                });
            }

            // Listen for the appinstalled event to know when the PWA was successfully installed
            window.addEventListener('appinstalled', () => {
                // Clear the deferredPrompt so it can be garbage collected
                deferredPrompt = null;
                console.log('PWA was installed');
            });

            function getRandom(min, max) {
                const minCeiled = Math.ceil(min);
                const maxFloored = Math.floor(max);
                let value = Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
                return value // The maximum is exclusive and the minimum is inclusive
            }

            function randomButNot(min, max, notThis) {
                const minCeiled = Math.ceil(min);
                const maxFloored = Math.floor(max);

                // If the range of possible numbers is 1 or less,
                // we might get an infinite loop.
                if (maxFloored - minCeiled <= 1) {
                    // If the only possible value is the one we're trying to avoid,
                    // we have no choice but to return it (or a default).
                    if (minCeiled === notThis) {
                        // This scenario should be handled based on desired behavior.
                        // Returning `notThis` is one option, returning null is another.
                        return notThis;
                    }
                    return minCeiled;
                }

                let value;
                do {
                    value = getRandom(min, max);
                } while (value === notThis);
                return value;
            }


            // ====================================================================
            // SECTION: Audio Player Class
            // I'm so fucking tired ddude
            // ====================================================================

            class AudioPlayer {
                constructor(audioElement) {
                    this.audio = audioElement || new Audio();
                    this.isPlaying = false;
                    this.duckAmount = 0.4;
                    this.fadeSpeed = 200;
                    this.playback = {
                        currentFileIndex: 0,
                    };
                    this.progressOverlay = null; // A reference to the progress bar element
                    this.card = null; // a reference to the card itself
                    this.setupListeners();
                }

                setupListeners() {
                    this.audio.onplaying = () => {
                        this.isPlaying = true;
                        if (this.card) {
                            this.card.classList.add('hover-glow');
                        }
                    };
                    this.audio.onpause = () => {
                        this.isPlaying = false;
                        this.resetProgress();
                    };
                    this.audio.onended = () => {
                        // This is for local cleanup ONLY
                        this.isPlaying = false;
                        this.resetProgress();
                        this.audio.currentTime = 0; // Rewind the audio element
                    };
                    this.audio.ontimeupdate = () => this.updateProgress();
                }

                updateProgress() {
                    if (this.progressOverlay && this.audio.duration > 0) {
                        const progress = (this.audio.currentTime / this.audio.duration) * 100;
                        this.progressOverlay.style.width = `${progress}%`;
                    }
                }

                resetProgress() {
                    if (this.progressOverlay) {
                        this.progressOverlay.style.width = '0%';
                    }
                    if (this.card) {
                        this.card.classList.remove('hover-glow');
                    }
                }

                // A method to properly clean up the audio object and its URL
                cleanup() {
                    this.audio.pause();
                    if (this.audio.src) {
                        URL.revokeObjectURL(this.audio.src);
                        this.audio.src = '';
                        this.audio.load();
                    }
                    this.isPlaying = false;
                    this.resetProgress();
                }
            }

            class BoardManager {
                // A helper to temporarily open a connection to the default DB
                static _getDefaultDB() {
                    const db = new SoundboardDB('default');
                    return db.openDB().then(() => db);
                }

                // Gets the list of board IDs from the default DB
                static async getBoardList() {
                    const defaultDB = await this._getDefaultDB();
                    const listData = await defaultDB.get('board-list');
                    return listData ? listData.ids : [];
                }

                // Adds a new board ID to the list in the default DB
                static async addBoardId(boardId) {
                    const defaultDB = await this._getDefaultDB();
                    const boardIds = await this.getBoardList();
                    if (!boardIds.includes(boardId)) {
                        boardIds.push(boardId);
                        await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                    }
                }

                static async saveBoardList(boardIds) {
                    const defaultDB = await this._getDefaultDB();
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }

                static async removeBoardId(boardIdToRemove) {
                    const defaultDB = await this._getDefaultDB();
                    let boardIds = await this.getBoardList();
                    // Filter the list to exclude the board we're removing
                    boardIds = boardIds.filter(id => id !== boardIdToRemove);
                    // Save the new, shorter list back to the database
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }
            }


            // ====================================================================
            // SECTION: Database Manager Class
            // ====================================================================

            class SoundboardDB {
                constructor(boardIdOverride = null) {
                    let boardId;
                    // If a boardId is explicitly passed, use it. Otherwise, get it from the URL.
                    if (boardIdOverride) {
                        boardId = boardIdOverride;
                    } else {
                        const urlParams = new URLSearchParams(window.location.search);
                        boardId = urlParams.get('board') || 'default';

                        // We'll move the "guest book" logic to be called after the constructor.
                    }

                    this.DB_NAME = `BugAndMossSoundboardDB_${boardId}`;
                    this.DB_VERSION = 9; // Increment version for this structural change idea
                    this.SOUNDS_STORE = 'sounds';
                    this.CONFIG_STORE = 'config';
                    this.CONFIG_KEY = 'global-config';
                    this.COSMETICS_KEY = 'cosmetics-config';
                    this.db = null;
                }
                async openDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                        request.onupgradeneeded = event => {
                            this.db = event.target.result;
                            if (!this.db.objectStoreNames.contains(this.SOUNDS_STORE)) {
                                this.db.createObjectStore(this.SOUNDS_STORE, {
                                    keyPath: 'id'
                                });
                            }
                            if (!this.db.objectStoreNames.contains(this.CONFIG_STORE)) {
                                this.db.createObjectStore(this.CONFIG_STORE, {
                                    keyPath: 'id'
                                });
                            }
                        };
                        request.onsuccess = event => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };
                        request.onerror = event => reject(event.target.error);
                    });
                }

                _dbRequest(storeName, mode, action, data) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) {
                            reject("Database not initialized.");
                            return;
                        }
                        const transaction = this.db.transaction(storeName, mode);
                        const store = transaction.objectStore(storeName);
                        let request;
                        if (data !== undefined) {
                            request = store[action](data);
                        } else {
                            request = store[action]();
                        }
                        transaction.oncomplete = () => resolve(request.result);
                        transaction.onerror = () => reject(transaction.error);
                    });
                }

                async save(id, data) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    const saveData = { id, ...(data.id !== undefined ? data : { ...data, id }) };
                    return this._dbRequest(storeName, 'readwrite', 'put', saveData);
                }


                async get(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readonly', 'get', id);
                }

                async getAll() {
                    const soundData = await this._dbRequest(this.SOUNDS_STORE, 'readonly', 'getAll');
                    const configData = await this._dbRequest(this.CONFIG_STORE, 'readonly', 'getAll');
                    return [...soundData, ...configData];
                }

                async delete(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readwrite', 'delete', id);
                }

                async clear() {
                    await this._dbRequest(this.SOUNDS_STORE, 'readwrite', 'clear');
                    await this._dbRequest(this.CONFIG_STORE, 'readwrite', 'clear');
                }
            }



            class NotepadCard {
                constructor(element, soundboardManager, dbInstance) {
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.cardId);

                    // DOM Elements
                    this.contentElement = this.cardElement.querySelector('.notepad-content');
                    this.tabsContainer = this.cardElement.querySelector('.notepad-tabs');
                    this.addPageButton = this.cardElement.querySelector('.add-page-btn');

                    // state
                    this.pages = [{ title: 'New Note', content: '' }];
                    this.currentPageIndex = 0;
                    this.height = null;

                    this.attachListeners();
                    this.loadState();
                }

                attachListeners() {
                    this.contentElement.addEventListener('input', () => {
                        this.pages[this.currentPageIndex].content = this.contentElement.value;
                        this.saveState();
                    });

                    this.contentElement.addEventListener('mouseup', () => {
                        // Only save if a height style was actually set by resizing
                        if (this.contentElement.style.height) {
                            this.height = this.contentElement.style.height;
                            this.saveState();
                        }
                    });

                    this.addPageButton.addEventListener('click', () => this.addPage());

                    this.tabsContainer.addEventListener('click', (e) => {
                        // First, handle the delete button action
                        if (e.target.classList.contains('delete-page-btn')) {
                            const tab = e.target.closest('.notepad-tab');
                            if (tab) {
                                this.deletePage(parseInt(tab.dataset.pageIndex));
                            }
                            return; // Stop processing
                        }

                        // Now, handle the page switch action
                        const tabToSwitchTo = e.target.closest('.notepad-tab');
                        if (tabToSwitchTo) {
                            const targetIndex = parseInt(tabToSwitchTo.dataset.pageIndex);

                            // Only switch pages if the clicked tab is not already the active one.
                            if (targetIndex !== this.currentPageIndex) {
                                this.switchPage(targetIndex);
                            }
                            // If it IS the active tab, we do nothing, which lets you click to edit the title.
                        }
                    });

                    this.tabsContainer.addEventListener('input', (e) => {
                        if (e.target.classList.contains('notepad-tab-title')) {
                            const tab = e.target.closest('.notepad-tab');
                            const pageIndex = parseInt(tab.dataset.pageIndex);
                            this.pages[pageIndex].title = e.target.textContent;
                            this.saveState();
                        }
                    });
                }

                async loadState() {
                    const state = await this.db.get(`notepad-${this.id}`);
                    if (state) {
                        this.pages = state.pages.map(p => ({ title: 'Note', content: '', ...p }));
                        this.currentPageIndex = state.currentPageIndex;
                        this.height = state.height || null; // UPDATED: Load the card's height
                    }
                    this.render();
                }

                async saveState() {
                    const state = {
                        pages: this.pages,
                        currentPageIndex: this.currentPageIndex,
                        height: this.height // UPDATED: Save the card's height
                    };
                    await this.db.save(`notepad-${this.id}`, state);
                }

                addPage() {
                    this.pages.push({ title: 'New Note', content: '' });
                    this.currentPageIndex = this.pages.length - 1;
                    this.render();
                    this.saveState();
                }

                deletePage(index) {
                    // If there is more than one page, just delete the page
                    if (this.pages.length > 1) {
                        this.pages.splice(index, 1);
                        if (this.currentPageIndex >= index) {
                            this.currentPageIndex = Math.max(0, this.currentPageIndex - 1);
                        }
                        this.render();
                        this.saveState();
                    } else {
                        // If it's the last page, delete the entire note card
                        this.soundboardManager.removeNotepad(this.id);
                    }
                }

                switchPage(index) {
                    if (index >= 0 && index < this.pages.length) {
                        this.currentPageIndex = index;
                        this.render();
                        this.saveState();
                    }
                }

                render() {
                    const currentPage = this.pages[this.currentPageIndex];
                    this.contentElement.value = currentPage.content;

                    if (this.height) {
                        this.contentElement.style.height = this.height;
                    } else {
                        this.contentElement.style.height = '';
                    }

                    this.tabsContainer.querySelectorAll('.notepad-tab').forEach(tab => tab.remove());

                    this.pages.forEach((page, index) => {
                        const tab = document.createElement('div');
                        tab.className = 'notepad-tab';
                        tab.dataset.pageIndex = index;

                        const tabTitle = document.createElement('span');
                        tabTitle.className = 'notepad-tab-title';
                        tabTitle.textContent = page.title;

                        // UPDATED: Explicitly use strings for contentEditable for better compatibility
                        tabTitle.contentEditable = (index === this.currentPageIndex) ? 'true' : 'false';

                        const deleteBtn = document.createElement('span');
                        deleteBtn.className = 'delete-page-btn';
                        deleteBtn.textContent = 'x';

                        tab.appendChild(tabTitle);
                        tab.appendChild(deleteBtn);

                        if (index === this.currentPageIndex) {
                            tab.classList.add('active');
                        }
                        this.tabsContainer.insertBefore(tab, this.addPageButton);
                    });
                }
            }

            class TimerCard {
                constructor(element, soundboardManager, dbInstance) {
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.timerId);

                    // --- DOM Element References ---
                    this.timerTitle = this.cardElement.querySelector('.timer-title');
                    this.timerDisplay = this.cardElement.querySelector('.timer-display');
                    this.startPauseBtn = this.cardElement.querySelector('.start-pause-timer-btn');
                    this.resetBtn = this.cardElement.querySelector('.reset-timer-btn');
                    this.removeTimerBtn = this.cardElement.querySelector('.remove-timer-btn');
                    this.timerMinutesRange = this.cardElement.querySelector('.timer-minutes-range');
                    this.timerSecondsRange = this.cardElement.querySelector('.timer-seconds-range');
                    this.timerMinutesValue = this.cardElement.querySelector('.timer-minutes-value');
                    this.timerSecondsValue = this.cardElement.querySelector('.timer-seconds-value');
                    this.hideOptionsToggle = this.cardElement.querySelector('.hide-timer-options-toggle');
                    this.optionsContainers = this.cardElement.querySelectorAll('.timer-options-container');
                    this.modeRadios = this.cardElement.querySelectorAll('.timer-mode-radio');
                    this.loopCheckbox = this.cardElement.querySelector('.timer-loop-checkbox');
                    this.startSoundContainer = this.cardElement.querySelector('.start-sound-container');
                    this.startSoundLabel = this.cardElement.querySelector('.start-sound-label');
                    this.endSoundContainer = this.cardElement.querySelector('.end-sound-container');
                    this.timerStartSoundSelect = this.cardElement.querySelector('.timer-start-sound');
                    this.timerEndSoundSelect = this.cardElement.querySelector('.timer-end-sound');

                    // --- State Properties ---
                    this.mode = 'timer';
                    this.isLooping = false;
                    this.isRunning = false;
                    this.totalDurationMs = 0;
                    this.elapsedMs = 0;
                    this.startTime = 0;
                    this.timerInterval = null;
                    this.hasPlayedEndSound = false;
                    this.endSoundData = null;
                    this.highlightColor = this.soundboardManager.cosmeticsData.colors['--highlight-color']

                    this.attachListeners();
                    this.loadTimerState();
                }

                attachListeners() {
                    this.startPauseBtn.addEventListener('click', () => this.handlePlayPause());
                    this.resetBtn.addEventListener('click', () => this.reset());
                    this.removeTimerBtn.addEventListener('click', () => this.soundboardManager.removeTimer(this.id));
                    this.timerMinutesRange.addEventListener('input', () => this.handleSliderChange());
                    this.timerSecondsRange.addEventListener('input', () => this.handleSliderChange());
                    this.hideOptionsToggle.addEventListener('change', () => this.handleOptionsToggle());
                    this.loopCheckbox.addEventListener('change', (e) => this.handleLoopToggle(e.target.checked));
                    this.modeRadios.forEach(radio => radio.addEventListener('change', (e) => this.handleModeChange(e.target.value)));
                    this.cardElement.addEventListener('input', () => this.saveTimerState());
                    this.timerStartSoundSelect.addEventListener('change', () => this.saveTimerState());
                    this.timerEndSoundSelect.addEventListener('change', () => this.saveTimerState());
                }

                async saveTimerState() {
                    const state = {
                        title: this.timerTitle.textContent,
                        minutes: this.timerMinutesRange.value,
                        seconds: this.timerSecondsRange.value,
                        startSound: this.timerStartSoundSelect.value,
                        endSound: this.timerEndSoundSelect.value,
                        optionsHidden: this.hideOptionsToggle.checked,
                        mode: this.mode,
                        isLooping: this.isLooping,
                        isRunning: this.isRunning,
                        startTime: this.startTime,
                        elapsedMs: this.isRunning ? this.elapsedMs + (Date.now() - this.startTime) : this.elapsedMs
                    };
                    this.db.save(`timer-${this.id}`, state);
                }

                async loadTimerState() {
                    const state = await this.db.get(`timer-${this.id}`);
                    if (state) {
                        this.timerTitle.textContent = state.title || 'New Timer';
                        this.timerMinutesRange.value = state.minutes || 0;
                        this.timerSecondsRange.value = state.seconds || 30;
                        this.timerStartSoundSelect.value = state.startSound || '';
                        this.timerEndSoundSelect.value = state.endSound || '';
                        this.hideOptionsToggle.checked = state.optionsHidden || false;
                        this.handleOptionsToggle();
                        this.loopCheckbox.checked = state.isLooping || false;
                        this.mode = state.mode || 'timer';
                        this.cardElement.querySelector(`.timer-mode-radio[value="${this.mode}"]`).checked = true;

                        if (state.isRunning && state.startTime) {
                            this.elapsedMs = state.elapsedMs;
                            this.startTime = Date.now();
                            this.play(true);
                        }
                    }
                    this.handleSliderChange();
                    this.updateUI();
                }

                handleSliderChange() {
                    const minutes = parseInt(this.timerMinutesRange.value, 10);
                    const seconds = parseInt(this.timerSecondsRange.value, 10);
                    this.timerMinutesValue.textContent = minutes;
                    this.timerSecondsValue.textContent = seconds;
                    this.totalDurationMs = (minutes * 60 + seconds) * 1000;

                    if (!this.isRunning) {
                        this.render(this.mode === 'timer' ? this.totalDurationMs : 0);
                    }
                }

                handleOptionsToggle() {
                    const isLocked = this.hideOptionsToggle.checked;
                    
                    this.optionsContainers.forEach((optionsContainer) => {
                        optionsContainer.classList.toggle('hidden-options', isLocked);
                    })
                    this.timerTitle.contentEditable = !isLocked;
                    this.saveTimerState();
                }

                handleLoopToggle(isLooping) {
                    this.isLooping = isLooping;
                    this.updateUI();
                    this.saveTimerState();
                }

                handleModeChange(newMode) {
                    this.mode = newMode;
                    if (!this.isRunning) {
                        this.reset();
                    }
                    this.updateUI();
                    this.saveTimerState();
                }

                
                updateUI() {
                    this.startPauseBtn.textContent = this.isRunning ? 'Pause' : 'Start';
                    this.endSoundContainer.style.display = this.isLooping ? 'none' : '';
                    this.startSoundLabel.textContent = this.isLooping ? 'Play Sound:' : 'Start with:';

                    const currentElapsed = this.elapsedMs + (this.isRunning ? Date.now() - this.startTime : 0);

                    // NEW: Expanded conditions for applying the glow effect
                    const isStopwatchFinished = this.mode === 'stopwatch' && currentElapsed >= this.totalDurationMs && this.totalDurationMs > 0;
                    const isTimerFinished = this.mode === 'timer' && (this.totalDurationMs - currentElapsed) <= 0;

                    if (isStopwatchFinished || (isTimerFinished && !this.isLooping)) {
                        this.timerDisplay.style.color = this.highlightColor;
                        this.cardElement.classList.add('hover-glow');
                    } else {
                        this.timerDisplay.style.color = '';
                        this.cardElement.classList.remove('hover-glow');
                    }
                }

                handlePlayPause() {
                    if (this.isRunning) {
                        this.pause();
                    } else {
                        this.play();
                    }
                }

                play(isResume = false) {
                    if (this.isRunning && !isResume) return;
                    if (this.mode === 'timer' && this.totalDurationMs - this.elapsedMs <= 0 && !this.isLooping) return;

                    this.isRunning = true;
                    this.startTime = Date.now();

                    if (!isResume) {
                        this.playStartSound();
                        this.prepareEndSound();
                    }

                    clearInterval(this.timerInterval);
                    this.timerInterval = setInterval(() => this.tick(), 250);

                    this.timerDisplay.classList.add('running');
                    this.updateUI();
                }

                pause() {
                    if (!this.isRunning) return;
                    this.isRunning = false;
                    this.elapsedMs += Date.now() - this.startTime;

                    clearInterval(this.timerInterval);
                    this.timerDisplay.classList.remove('running');
                    this.updateUI();
                    this.saveTimerState();
                }

                reset() {
                    this.isRunning = false;
                    this.elapsedMs = 0;
                    this.hasPlayedEndSound = false;
                    this.endSoundData = null;

                    clearInterval(this.timerInterval);

                    this.render(this.mode === 'timer' ? this.totalDurationMs : 0);

                    this.timerDisplay.classList.remove('running');
                    this.updateUI(); // This will correctly remove the glow effect
                    this.saveTimerState();
                }

                tick() {
                    const currentElapsed = this.elapsedMs + (Date.now() - this.startTime);

                    if (this.mode === 'timer') {
                        const remainingMs = Math.max(0, this.totalDurationMs - currentElapsed);
                        this.render(remainingMs);
                        this.updateUI();

                        if (this.endSoundData && !this.hasPlayedEndSound && remainingMs <= this.endSoundData.duration * 1000) {
                            this.playEndSound();
                        }

                        if (remainingMs <= 0) {
                            if (this.isLooping) {
                                this.elapsedMs = 0;
                                this.startTime = Date.now();
                                this.playStartSound();
                                this.prepareEndSound();
                            } else {
                                // NEW: Stop the timer at 00:00 instead of resetting
                                if (!this.hasPlayedEndSound) this.playEndSound();
                                this.isRunning = false;
                                this.elapsedMs = this.totalDurationMs; // Lock elapsed time
                                clearInterval(this.timerInterval);
                                this.timerDisplay.classList.remove('running');
                                this.updateUI();
                                this.saveTimerState();
                            }
                        }
                    } else { // Stopwatch mode
                        this.render(currentElapsed);
                        this.updateUI();

                        // NEW: Added the "ends with" timing trick to the stopwatch
                        if (this.endSoundData && this.endSoundData.duration && !this.hasPlayedEndSound && this.totalDurationMs > 0) {
                            const soundTriggerTimeMs = this.totalDurationMs - (this.endSoundData.duration * 1000);
                            if (currentElapsed >= soundTriggerTimeMs) {
                                this.playEndSound();
                            }
                        }
                    }
                }

                render(ms) {
                    const totalSeconds = Math.round(ms / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    this.timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }

                playStartSound() {
                    const startSoundId = parseInt(this.timerStartSoundSelect.value, 10);
                    if (!isNaN(startSoundId)) {
                        this.soundboardManager.togglePlay(startSoundId).catch(error => {
                            console.error('Failed to play start sound:', error);
                        });
                    }
                }

                playEndSound() {
                    if (this.endSoundData) {
                        this.soundboardManager.playFile(this.endSoundData.index, this.endSoundData.fileIndex, this.endSoundData.priority).catch(error => {
                            console.error('Failed to play end sound:', error);
                        });
                        this.hasPlayedEndSound = true;
                    }
                }

                prepareEndSound() {
                    this.hasPlayedEndSound = false;
                    this.endSoundData = null;
                    const endSoundId = parseInt(this.timerEndSoundSelect.value, 10);

                    if (isNaN(endSoundId)) return;

                    const buttonData = this.soundboardManager.buttonsData[endSoundId];
                    if (buttonData && buttonData.files.length > 0) {
                        const player = this.soundboardManager._getAudioPlayer(endSoundId);
                        const fileIndex = buttonData.shuffle ?
                            randomButNot(0, buttonData.files.length, player.playback.currentFileIndex) :
                            player.playback.currentFileIndex;

                        const playbackRate = buttonData.playbackRate || 1.0;

                        this.endSoundData = {
                            index: endSoundId,
                            fileIndex: fileIndex,
                            priority: buttonData.priority,
                            duration: null
                        };

                        this.getAudioDuration(buttonData.files[fileIndex].arrayBuffer)
                            .then(duration => {
                                if (this.endSoundData) {
                                    this.endSoundData.duration = duration / playbackRate;
                                }
                            }).catch(err => console.error("Could not get audio duration:", err));
                    }
                }

                updateTimerSoundSelectors(sounds) {
                    const currentStartVal = this.timerStartSoundSelect.value;
                    const currentEndVal = this.timerEndSoundSelect.value;

                    this.timerStartSoundSelect.innerHTML = '<option value="">None</option>';
                    this.timerEndSoundSelect.innerHTML = '<option value="">None</option>';

                    sounds.forEach((sound, index) => {
                        if (sound.name !== "Default Name") {
                            const optionStart = new Option(sound.name, index);
                            const optionEnd = new Option(sound.name, index);
                            this.timerStartSoundSelect.add(optionStart);
                            this.timerEndSoundSelect.add(optionEnd);
                        }
                    });

                    this.timerStartSoundSelect.value = currentStartVal;
                    this.timerEndSoundSelect.value = currentEndVal;
                }

                getAudioDuration(arrayBuffer) {
                    return new Promise((resolve, reject) => {
                        const blob = new Blob([arrayBuffer]);
                        const audio = new Audio();
                        const objectURL = URL.createObjectURL(blob);
                        audio.addEventListener('loadedmetadata', () => {
                            URL.revokeObjectURL(objectURL);
                            resolve(audio.duration);
                        }, { once: true });
                        audio.addEventListener('error', (e) => {
                            URL.revokeObjectURL(objectURL);
                            reject(new Error('Failed to load audio for duration calculation.'));
                        }, { once: true });
                        audio.src = objectURL;
                    });
                }
            }

            // ====================================================================
            // SECTION: Application Manager Class
            // Manages the state and business logic of the soundboard.
            // UI interactions trigger methods on this manager.
            // ====================================================================

            class SoundboardManager {
                constructor(dbInstance) {
                    this.db = dbInstance;
                    this.soundboardGrid = document.getElementById('soundboard-grid');
                    this.controlCardElement = document.getElementById('control-card');
                    this.buttonsData = [];
                    this.players = new Map();
                    this.timerCards = [];
                    this.notepadCards = [];

                    this.gridLayout = [];
                    this.GRID_LAYOUT_KEY = 'grid-layout';
                    this.activeModalIndex = null;
                    this.isRearranging = false;
                    this.draggedItem = null;
                    this.cosmeticsData = {};

                }

                // ================================================================
                // Core Manager Methods
                // ================================================================

                async _loadBoardData() {
                    await this.loadTitle();
                    await this.loadCosmetics();
                    await this.loadStateFromDB(); // Loads sound buttons
                    await this.loadTimers();
                    await this.loadNotepads();
                    await this.initBugMovement();
                    await this.loadLayout();

                }

                async initialize() {
                    loadGoogleFonts(['Wellfleet']);
                    await this.db.openDB();

                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';
                    await BoardManager.addBoardId(boardId);
                    await this._loadBoardData();
                    this.attachGlobalEventListeners();
                    this.renderGrid();
                }

                async createNewBoard() {
                    const input = document.getElementById('new-board-name-input');
                    const boardName = input.value.trim();

                    if (!boardName) {
                        alert("Please enter a name for the new board.");
                        return;
                    }

                    const boardId = slugify(boardName);
                    if (!boardId) {
                        alert("Please enter a valid name (letters and numbers).");
                        return;
                    }

                    const existingBoardIds = await BoardManager.getBoardList(); // UPDATED
                    if (existingBoardIds.includes(boardId)) {
                        alert(`A board with the ID "${boardId}" already exists.`);
                        return;
                    }

                    window.location.href = `?board=${boardId}`;
                }

                async loadTitle() {
                    const titleData = await this.db.get('soundboard-title');

                    if (titleData && titleData.title) {
                        // If a title is already saved in the database, use it.
                        document.getElementById('soundboard-title').textContent = titleData.title;
                    } else {
                        // NEW: If no title is saved, get the board ID from the URL
                        // and use that as the default title.
                        const urlParams = new URLSearchParams(window.location.search);
                        const boardId = formatIdAsTitle(urlParams.get('board')) || 'The Bug & Moss Simple Soundboard';
                        document.getElementById('soundboard-title').textContent = boardId;
                        document.title = boardId + " | B&M RSS";
                    }
                }

                // REFACTOR: New method to load the grid layout from DB or create a default.
                async loadLayout() {
                    const layoutData = await this.db.get(this.GRID_LAYOUT_KEY);
                    if (layoutData && Array.isArray(layoutData.layout)) {
                        this.gridLayout = layoutData.layout;
                    } else {
                        this._generateDefaultLayout();
                        await this._saveLayout();
                    }
                }

                // REFACTOR: New method to save the current grid layout to DB.
                async _saveLayout() {
                    await this.db.save(this.GRID_LAYOUT_KEY, { id: this.GRID_LAYOUT_KEY, layout: this.gridLayout });
                }

                // REFACTOR: New method to create a default layout if none exists.
                _generateDefaultLayout() {
                    this.gridLayout = [
                        { type: 'sound', id: 0 },
                        { type: 'sound', id: 1 },
                        { type: 'sound', id: 2 },
                        { type: 'sound', id: 3 },
                        { type: 'timer', id: 0 },
                        { type: 'control', id: 'control-card' }
                    ];
                }

                async loadNotepads() {
                    const notepadCountData = await this.db.get('notepadCount');
                    const numNotepads = notepadCountData ? notepadCountData.count : 0;
                    const notepadTemplate = document.getElementById('notepad-card-template');

                    for (let i = 0; i < numNotepads; i++) {
                        // Find the highest existing ID to avoid collisions
                        const existingIds = this.notepadCards.map(n => n.id);
                        const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : i;

                        const newCard = notepadTemplate.content.cloneNode(true).querySelector('.notepad-card');
                        newCard.dataset.cardType = 'notepad';
                        newCard.dataset.cardId = nextId;
                        this.notepadCards.push(new NotepadCard(newCard, this, this.db));
                    }
                }

                // Add this new method to add a notepad
                async addNotepad() {
                    const existingIds = this.notepadCards.map(n => n.id);
                    const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 0;

                    const newCard = document.getElementById('notepad-card-template').content.cloneNode(true).querySelector('.notepad-card');
                    newCard.dataset.cardType = 'notepad';
                    newCard.dataset.cardId = nextId;

                    this.notepadCards.push(new NotepadCard(newCard, this, this.db));

                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    this.gridLayout.splice(controlCardIndex, 0, { type: 'notepad', id: nextId });

                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                // Add this new method to remove a notepad
                async removeNotepad(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this note?');
                    if (!confirmed) return;

                    this.notepadCards = this.notepadCards.filter(n => n.id !== idToRemove);
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'notepad' && item.id === idToRemove));

                    await this.db.delete(`notepad-${idToRemove}`);
                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async loadTimers() {
                    const timerCountData = await this.db.get('timerCount');
                    const numTimers = timerCountData ? timerCountData.count : 0;
                    const timerTemplate = document.getElementById('timer-card-template');

                    for (let i = 0; i < numTimers; i++) {
                        const timerId = i;
                        const newCard = timerTemplate.content.cloneNode(true).querySelector('.timer-card');
                        newCard.dataset.timerId = timerId;
                        // REFACTOR: Add card type and ID for drag-and-drop identification.
                        newCard.dataset.cardType = 'timer';
                        newCard.dataset.cardId = timerId;
                        this.timerCards.push(new TimerCard(newCard, this, this.db));
                    }
                }

                async addTimer() {
                    const nextTimerIndex = this.timerCards.length > 0 ? Math.max(...this.timerCards.map(t => t.id)) + 1 : 0;
                    const newCard = document.getElementById('timer-card-template').content.cloneNode(true).querySelector('.timer-card');
                    newCard.dataset.timerId = nextTimerIndex;
                    newCard.dataset.cardType = 'timer';
                    newCard.dataset.cardId = nextTimerIndex;

                    this.timerCards.push(new TimerCard(newCard, this, this.db));

                    // REFACTOR: Add the new timer to the layout and re-render.
                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    if (controlCardIndex > -1) {
                        this.gridLayout.splice(controlCardIndex, 0, { type: 'timer', id: nextTimerIndex });
                    } else {
                        this.gridLayout.push({ type: 'timer', id: nextTimerIndex });
                    }

                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                // REFACTOR: New unified remove method for timers.
                async removeTimer(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this timer?');
                    if (!confirmed) return;

                    const timerInstance = this.timerCards.find(t => t.id === idToRemove);
                    if (timerInstance) {
                        timerInstance.stopTimer();
                    }

                    // Remove from instance array
                    this.timerCards = this.timerCards.filter(t => t.id !== idToRemove);

                    // Remove from layout
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'timer' && item.id === idToRemove));

                    // Delete DB entries
                    await this.db.delete(`timer-${idToRemove}`);
                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });

                    await this._saveLayout();
                    this.renderGrid();
                }

                async requestPersistentStorage() {
                    if (navigator.storage && navigator.storage.persist) {
                        const isPersisted = await navigator.storage.persisted();
                        if (!isPersisted) {
                            const granted = await navigator.storage.persist();
                            if (granted) {
                                console.log("Persistent storage granted!");
                            } else {
                                console.log("Persistent storage denied.");
                            }
                        } else {
                            console.log("Persistent storage already granted.");
                        }
                    }
                }

                
                async loadStateFromDB() {
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    let configData = await this.db.get(this.db.CONFIG_KEY);
                    if (!configData) {
                        configData = { id: this.db.CONFIG_KEY, numButtons: 4 };
                        await this.db.save(configData.id, configData);

                        // Set the default number of timers to 1
                        await this.db.save('timerCount', { id: 'timerCount', count: 1 });
                    }

                    const numButtons = configData.numButtons;
                    const soundDataMap = new Map(soundData.map(item => [item.id, item]));

                    this.buttonsData = [];
                    for (let i = 0; i < numButtons; i++) {
                        const data = soundDataMap.get(i) || this._getInitialButtonData(i);
                        this.buttonsData.push(data);
                    }
                }

                async addButton() {
                    const nextIndex = this.buttonsData.length;
                    const newButtonData = this._getInitialButtonData(nextIndex);
                    this.buttonsData.push(newButtonData);

                    // REFACTOR: Add the new button to the layout and re-render.
                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    if (controlCardIndex > -1) {
                        this.gridLayout.splice(controlCardIndex, 0, { type: 'sound', id: nextIndex });
                    } else {
                        this.gridLayout.push({ type: 'sound', id: nextIndex });
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async removeLastButton() {
                    if (this.buttonsData.length > 1) {
                        const lastIndex = this.buttonsData.length - 1;
                        this.buttonsData.pop();
                        if (this.players.has(lastIndex)) {
                            this.players.get(lastIndex).cleanup();
                            this.players.delete(lastIndex);
                        }
                        await this.db.delete(lastIndex);
                        await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });

                        // REFACTOR: Remove from layout and re-render.
                        this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === lastIndex));
                        await this._saveLayout();
                        this.renderGrid();
                    }
                }

                async updateButton(index, newData) {
                    this.buttonsData[index] = { ...this.buttonsData[index], ...newData };
                    await this.db.save(index, this.buttonsData[index]);
                    this.renderGrid();
                }

                // ================================================================
                // UI Rendering Methods
                // ================================================================

                // REFACTOR: This is the new primary rendering function.
                renderGrid() {
                    this.soundboardGrid.innerHTML = '';

                    this.gridLayout.forEach(item => {
                        let cardElement = null;
                        if (item.type === 'sound') {
                            const buttonData = this.buttonsData.find(b => b.id === item.id);
                            if (buttonData) {
                                cardElement = this._createSoundCardElement(buttonData, item.id);
                            }
                        } else if (item.type === 'timer') {
                            const timerInstance = this.timerCards.find(t => t.id === item.id);
                            if (timerInstance) {
                                cardElement = timerInstance.cardElement;
                            }
                        } else if (item.type === 'control') {
                            cardElement = this.controlCardElement;
                            cardElement.style.display = 'flex'; // Make it visible
                        } else if (item.type === 'notepad') {
                            const noteInstance = this.notepadCards.find(n => n.id === item.id);
                            if (noteInstance) {
                                cardElement = noteInstance.cardElement;
                            }
                        }

                        if (cardElement) {
                            this.soundboardGrid.appendChild(cardElement);
                        }
                    });

                    this.timerCards.forEach(timer => timer.updateTimerSoundSelectors(this.buttonsData));
                }

                _createSoundCardElement(buttonData, index) {
                    const card = document.createElement('div');
                    const textColor = getContrastColor(buttonData.color);
                    card.className = 'sound-card';
                    // REFACTOR: Use distinct data attributes for type and ID.
                    card.dataset.cardType = 'sound';
                    card.dataset.cardId = index;
                    card.dataset.index = index; // Keep for compatibility
                    card.setAttribute('draggable', this.isRearranging);
                    card.innerHTML = `
<button class="sound-button" data-action="play" style="background-color: ${buttonData.color}; color: ${textColor}">
<div class="progress-overlay" style="width: 0%;"></div>
<span class="button-text">${buttonData.name}</span>
<div class="settings-triangle-btn" data-action="settings">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
<path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
</svg>
</div>
</button>
<div class="sound-controls">
<div class="slider-group">
<label>Volume</label>
<input type="range" min="0" max="1" step="0.01" value="${buttonData.volume}" data-action="volume-change">
</div>
<div class="slider-group">
<label>Speed</label>
<input type="range" min="0.5" max="2" step="0.1" value="${buttonData.playbackRate}" data-action="speed-change" ondblclick="this.value=1.0; this.dispatchEvent(new Event('input'))">
<span class="speed-display">${buttonData.playbackRate.toFixed(1)}x</span>
</div>
</div>
`;
                    return card;
                }

                // ================================================================
                // Event Handling and Playback Logic
                // ================================================================

                attachGlobalEventListeners() {

                    document.getElementById('soundboard-title').addEventListener('blur', (e) => {
                        const newTitle = e.target.textContent.trim();
                        document.title = newTitle + " | B&M RSS";
                        this.db.save('soundboard-title', { id: 'soundboard-title', title: newTitle });
                    });

                    this.soundboardGrid.addEventListener('click', (event) => this.handleGridClick(event));
                    // debounce the slider input to save to DB only after the user stops sliding for 250ms
                    this.soundboardGrid.addEventListener('input', debounce((event) => this.handleSliderChange(event), 250));
                    this.soundboardGrid.addEventListener('dblclick', (event) => this.handleGridDoubleClick(event));

                    this.soundboardGrid.addEventListener('dragstart', (e) => this.handleDragStart(e));
                    this.soundboardGrid.addEventListener('dragover', (e) => this.handleDragOver(e));
                    this.soundboardGrid.addEventListener('dragenter', (e) => this.handleDragEnter(e));
                    this.soundboardGrid.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    this.soundboardGrid.addEventListener('drop', (e) => this.handleDrop(e));
                    this.soundboardGrid.addEventListener('dragend', (e) => this.handleDragEnd(e));

                    document.getElementById('add-notepad-btn').addEventListener('click', () => this.addNotepad());
                    document.getElementById('add-btn-plus').addEventListener('click', () => this.addButton());
                    document.getElementById('remove-button-modal').addEventListener('click', () => this._handleRemoveButton());
                    document.getElementById('add-timer-btn').addEventListener('click', () => this.addTimer());
                    document.getElementById('rearrange-mode-btn').addEventListener('click', () => this.toggleRearrangeMode());
                    document.getElementById('download-config-btn').addEventListener('click', () => this.downloadConfig());
                    document.getElementById('upload-config-btn').addEventListener('click', () => document.getElementById('upload-config-input').click());
                    document.getElementById('upload-config-input').addEventListener('change', (e) => this.uploadConfig(e));
                    document.getElementById('db-manager-btn').addEventListener('click', () => this.showDbManagerModal());

                    document.getElementById('switch-board-btn').addEventListener('click', () => this.openBoardSwitcherModal());
                    document.getElementById('create-new-board-btn').addEventListener('click', () => this.createNewBoard());

                    // ADD a listener to close the new modal when clicking the background
                    document.getElementById('board-switcher-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'board-switcher-modal') {
                            document.getElementById('board-switcher-modal').style.display = 'none';
                        }
                    });


                    document.getElementById('settings-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'settings-modal') this.closeSettingsModal();
                    });
                    document.getElementById('db-manager-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'db-manager-modal') this.closeDbManagerModal();
                    });
                    document.getElementById('persistent-storage-checkbox').addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.requestPersistentStorage();
                        }
                        // Note: Browsers do not currently allow you to programmatically "un-persist" storage.
                        // The user must do this through browser settings.
                    });
                    document.getElementById('clear-database-btn').addEventListener('click', () => this.handleClearDatabase());

                    document.getElementById('button-name-input').addEventListener('input', (e) => this.updateModalButtonData('name', e.target.value));
                    document.getElementById('button-color-picker').addEventListener('input', (e) => this.updateModalButtonData('color', e.target.value));
                    document.getElementById('add-file-input').addEventListener('change', (e) => this.addFilesToModalButton(e));
                    document.getElementById('clear-files-btn').addEventListener('click', () => this.clearModalButtonFiles());
                    document.getElementById('shuffle-checkbox').addEventListener('change', (e) => this.updateModalButtonData('shuffle', e.target.checked));
                    document.getElementById('autoplay-checkbox').addEventListener('change', (e) => this.updateModalButtonData('autoplay', e.target.checked));
                    document.getElementById('priority-checkbox').addEventListener('change', (e) => this.updateModalButtonData('priority', e.target.checked));
                    document.getElementById('loop-checkbox').addEventListener('change', (e) => this.updateModalButtonData('loop', e.target.checked));


                    document.getElementById('cosmetics-btn').addEventListener('click', () => this.openCosmeticsModal());
                    document.getElementById('delete-cosmetics-key-btn').addEventListener('click', () => this.deleteCosmeticsKey());
                    document.getElementById('file-list').addEventListener('click', (e) => {
                        // If the clicked element has the 'remove-file-button' class, then act.
                        if (e.target.classList.contains('remove-file-button')) {
                            this.removeFileFromModalButton(e);
                        }
                    });

                    document.getElementById('cosmetics-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'cosmetics-modal') {
                            document.getElementById('cosmetics-modal').style.display = 'none';
                        }
                    });

                    document.querySelectorAll('#cosmetics-modal input[type="color"]').forEach(input => {
                        input.addEventListener('input', (e) => {
                            const cssVar = e.target.dataset.cssVar;
                            this.cosmeticsData.colors[cssVar] = e.target.value;
                            this.applyCosmetics();
                            this._saveCosmetics();
                        });
                    });

                    document.getElementById('font-input').addEventListener('change', (e) => {
                        const newFont = e.target.value.trim();
                        if (newFont) {
                            this.cosmeticsData.fontFamily = newFont;
                            this.applyCosmetics();
                            this._saveCosmetics();
                        }
                    });

                    // HELPFUL BUG

                    document.getElementById('help-bug-btn').addEventListener('click', () => {
                        document.getElementById('help-modal').style.display = 'flex';
                    });

                    document.getElementById('help-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'help-modal') {
                            document.getElementById('help-modal').style.display = 'none';
                        }
                    });
                    document.querySelector('.help-accordion').addEventListener('click', (e) => {
                        if (e.target.classList.contains('accordion-header')) {
                            const activeHeader = document.querySelector('.accordion-header.active');
                            // Close the already active header if it's not the one that was clicked
                            if (activeHeader && activeHeader !== e.target) {
                                activeHeader.classList.remove('active');
                                activeHeader.nextElementSibling.classList.remove('active');
                            }

                            // Toggle the clicked header and its content
                            e.target.classList.toggle('active');
                            const content = e.target.nextElementSibling;
                            content.classList.toggle('active');
                        }
                    });

                    // SERVICE WORKER
                    // WORKER IN SERVICE
                    // TREAT HIM NICELY
                    if ('serviceWorker' in navigator) {
                        window.addEventListener('load', () => {
                            navigator.serviceWorker.register('./service-worker.js').then(registration => {
                                console.log('ServiceWorker registration successful');
                            }).catch(err => {
                                console.log('ServiceWorker registration failed: ', err);
                            });
                        });
                    }
                }

                handleGridClick(event) {
                    if (this.isRearranging) return;
                    const card = event.target.closest('.sound-card[data-card-type="sound"]');
                    if (!card) return;
                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const actionElement = event.target.closest('[data-action]');
                    if (!actionElement) return;
                    const action = actionElement.dataset.action;

                    switch (action) {
                        case 'play':
                            this.togglePlay(index);
                            break;
                        case 'settings':
                            this.openSettingsModal(index);
                            break;
                    }
                }

                handleGridDoubleClick(event) {
                    const slider = event.target.closest('input[type="range"][data-action="speed-change"]');
                    if (slider) {
                        slider.value = 1.0;
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                handleSliderChange(event) {
                    const card = event.target.closest('.sound-card');
                    if (!card) return;

                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const action = event.target.dataset.action;
                    const value = parseFloat(event.target.value);
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    switch (action) {
                        case 'volume-change':
                            buttonData.volume = value;
                            player.audio.volume = value;
                            break;
                        case 'speed-change':
                            buttonData.playbackRate = value;
                            player.audio.playbackRate = value;
                            const speedDisplay = card.querySelector('.speed-display');
                            if (speedDisplay) {
                                speedDisplay.textContent = `${value.toFixed(1)}x`;
                            }
                            break;
                    }
                    this.db.save(index, buttonData);
                }

                handleDragStart(event) {
                    if (!this.isRearranging) return;
                    this.draggedItem = event.target.closest('.sound-card');
                    if (!this.draggedItem) return;
                    event.dataTransfer.effectAllowed = 'move';
                    // REFACTOR: Use a generic identifier for the drag data.
                    event.dataTransfer.setData('text/plain', this.draggedItem.dataset.cardId);
                    setTimeout(() => {
                        this.draggedItem.classList.add('dragging');
                    }, 0);
                }

                handleDragOver(event) {
                    event.preventDefault();
                }

                handleDragEnter(event) {
                    if (!this.isRearranging) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        targetCard.classList.add('drag-over');
                    }
                }

                handleDragLeave(event) {
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        if (!targetCard.contains(event.relatedTarget)) {
                            targetCard.classList.remove('drag-over');
                        }
                    }
                }

                // REFACTOR: The drop handler now manipulates the gridLayout array.
                async handleDrop(event) {
                    event.preventDefault();
                    if (!this.isRearranging || !this.draggedItem) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        const fromType = this.draggedItem.dataset.cardType;
                        const fromId = fromType === 'control' ? 'control-card' : parseInt(this.draggedItem.dataset.cardId);
                        const toType = targetCard.dataset.cardType;
                        const toId = toType === 'control' ? 'control-card' : parseInt(targetCard.dataset.cardId);

                        const fromIndex = this.gridLayout.findIndex(item => item.type === fromType && item.id === fromId);
                        const toIndex = this.gridLayout.findIndex(item => item.type === toType && item.id === toId);

                        if (fromIndex > -1 && toIndex > -1) {
                            [this.gridLayout[fromIndex], this.gridLayout[toIndex]] = [this.gridLayout[toIndex], this.gridLayout[fromIndex]];
                            await this._saveLayout();
                            this.renderGrid();
                        }
                    }
                }

                handleDragEnd() {
                    if (this.draggedItem) {
                        this.draggedItem.classList.remove('dragging');
                        this.draggedItem = null;
                        this.soundboardGrid.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    }
                }

                // REFACTOR: Toggle rearrange mode for ALL cards.
                toggleRearrangeMode() {
                    this.isRearranging = !this.isRearranging;
                    const btn = document.getElementById('rearrange-mode-btn');
                    const grid = document.getElementById('soundboard-grid');
                    grid.classList.toggle('rearrange-mode', this.isRearranging);
                    btn.textContent = this.isRearranging ? 'Done Rearranging' : 'Rearrange';

                    grid.querySelectorAll('.sound-card').forEach(card => {
                        card.setAttribute('draggable', this.isRearranging);
                    });
                }

                async togglePlay(index) {
                    if (isNaN(index)) {
                        console.error("Invalid index provided:", index);
                        return;
                    }
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    if (buttonData.files.length === 0) return;

                    if (player.playback.currentFileIndex >= buttonData.files.length) {
                        player.playback.currentFileIndex = 0;
                    }

                    if (player.isPlaying) {
                        player.cleanup();
                        this.handlePlaybackCompletion(index);

                    } else {

                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;

                        player.playback.currentFileIndex = fileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    }
                }

                _lerpVolume(audio, slider, from, to, duration) {
                    const start = performance.now();

                    function step(now) {
                        const t = Math.min((now - start) / duration, 1); // 0 â†’ 1
                        audio.volume = Math.max(0, Math.min(1, from + (to - from) * t));
                        slider.value = audio.volume;

                        if (t < 1) {
                            requestAnimationFrame(step);
                        }
                    }

                    requestAnimationFrame(step);
                }

                handlePriorityDucking() {
                    this.players.forEach((player, playerIndex) => {

                        const playerButtonData = this.buttonsData[playerIndex];
                        if (!playerButtonData.priority) {
                            const duckTarget = playerButtonData.volume * player.duckAmount;
                            const slider = this._getVolumeSlider(playerIndex);
                            this._lerpVolume(player.audio, slider, player.audio.volume, duckTarget, player.fadeSpeed);

                        }
                    });
                }

                _getVolumeSlider(index) {
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        return card.querySelector('input[data-action="volume-change"]');
                    }
                    return null;
                }

                _checkForPriorityPlaying() {
                    for (const [playerIndex, player] of this.players.entries()) {
                        // Check if the sound is actually playing AND belongs to a priority button.
                        if (player.isPlaying && this.buttonsData[playerIndex]?.priority) {
                            return true; // Found another priority sound playing, so stop checking.
                        }
                    }
                    return false; // No other priority sounds are playing.
                };


                handlePlaybackCompletion(index) {
                    const buttonData = this.buttonsData[index];
                    const player = this.players.get(index);
                    if (!player) return;

                    // Check if the sound that just ended was a priority sound.
                    if (buttonData.priority) {
                        // Check if any OTHER priority sounds are still playing.
                        let isOtherPriorityPlaying = this._checkForPriorityPlaying();

                        // If no other priority sounds are running, it's safe to un-duck.
                        if (!isOtherPriorityPlaying) {
                            // NEW: This loop now correctly gets the index for each ducked player.
                            this.players.forEach((duckedPlayer, duckedPlayerIndex) => {
                                const duckedPlayerButtonData = this.buttonsData[duckedPlayerIndex];

                                // Only restore volume on sounds that were actually ducked (i.e., non-priority and still playing).
                                if (duckedPlayer.isPlaying && !duckedPlayerButtonData.priority) {
                                    const targetVolume = duckedPlayerButtonData.volume;
                                    const slider = this._getVolumeSlider(duckedPlayerIndex);
                                    this._lerpVolume(duckedPlayer.audio, slider, duckedPlayer.audio.volume, targetVolume, duckedPlayer.fadeSpeed);
                                }
                            });
                        }
                    }


                    // This handles the autoplay/loop logic after the ducking is resolved.
                    if (buttonData.loop) {
                        this.playFile(index, player.playback.currentFileIndex, buttonData.priority);
                    } else if (buttonData.autoplay) {
                        
                        player.playback.currentFileIndex++
                        if (player.playback.currentFileIndex >= buttonData.files.length) {
                            player.playback.currentFileIndex = 0;
                        }
                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    } else {
                        //always advance to the next track by default
                        player.playback.currentFileIndex++
                    }
                }

                async playFile(buttonIndex, fileIndex, isPriority) {
                    const buttonData = this.buttonsData[buttonIndex];
                    const player = this._getAudioPlayer(buttonIndex);
                    const fileData = buttonData.files[fileIndex];
                    if (!fileData) {
                        console.error("No file found at index:", fileIndex);
                        return;
                    }
                    player.cleanup();
                    const blob = new Blob([fileData.arrayBuffer], { type: fileData.mimeType });
                    player.audio.src = URL.createObjectURL(blob);
                    player.audio.volume = buttonData.volume;
                    player.audio.playbackRate = buttonData.playbackRate;

                    player.audio.play().catch(e => console.error("Playback error:", e));
                    if (isPriority) {
                        this.handlePriorityDucking();
                    }
                }

                _getAudioPlayer(index) {
                    let player = this.players.get(index);
                    if (!player) {
                        const audio = new Audio();
                        player = new AudioPlayer(audio);
                        this.players.set(index, player);

                        audio.onended = () => {
                            this.handlePlaybackCompletion(index);
                        };
                    }
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        player.progressOverlay = card.querySelector('.progress-overlay');
                        player.card = card;
                    }
                    return player;
                }

                _getInitialButtonData(index) {
                    return {
                        id: index,
                        name: `Button ${index + 1}`,
                        color: "var(--accent-color)",
                        volume: 1.0,
                        playbackRate: 1.0,
                        shuffle: false,
                        loop: false,
                        priority: false,
                        files: []
                    };
                }

                _shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                }

                // ================================================================
                // COSMETICS MODAL METHODS
                // ================================================================

                async loadCosmetics() {
                    let cosmeticsData = await this.db.get(this.db.COSMETICS_KEY);
                    if (!cosmeticsData) {
                        // Default values if no settings are saved
                        cosmeticsData = {
                            id: this.db.COSMETICS_KEY,
                            fontFamily: 'Wellfleet',
                            colors: {
                                // SET COLOR THEME HERE - COLOR THEME CONFIG - COLOR VARIABLES
                                '--background-color': '#f7fafc',
                                '--panel-color': '#e3f0ff',
                                '--accent-color': '#33a367',
                                '--highlight-color': '#ff914d',
                                '--primary-color': '#234e70', // Dark Text
                                '--secondary-color': '#e7e7e7ff', // Light Text
                            }
                        };
                        await this.db.save(cosmeticsData.id, cosmeticsData);
                    }
                    this.cosmeticsData = cosmeticsData;
                    this.applyCosmetics();
                }

                applyCosmetics() {
                    const root = document.documentElement;
                    const colors = this.cosmeticsData.colors;

                    // Set the base colors first
                    for (const [key, value] of Object.entries(colors)) {
                        root.style.setProperty(key, value);
                    }

                    // NEW: Dynamically set contrasting text colors
                    const darkText = colors['--primary-color'];
                    const lightText = colors['--secondary-color'];

                    // Helper function to avoid repetition
                    const setContrast = (bgVar, textVar) => {
                        const bgColor = colors[bgVar];
                        const luminance = (0.299 * parseInt(bgColor.substr(1, 2), 16) + 0.587 * parseInt(bgColor.substr(3, 2), 16) + 0.114 * parseInt(bgColor.substr(5, 2), 16)) / 255;
                        root.style.setProperty(textVar, luminance > 0.5 ? darkText : lightText);
                    };

                    setContrast('--panel-color', '--panel-color-text');
                    setContrast('--accent-color', '--accent-color-text');
                    setContrast('--highlight-color', '--highlight-color-text');
                    setContrast('--primary-color', '--primary-color-text');
                    setContrast('--background-color', '--background-color-text');
                    
                    // Apply font
                    loadGoogleFonts([this.cosmeticsData.fontFamily]);
                    root.style.setProperty('--font-family-primary', `'${this.cosmeticsData.fontFamily}', sans-serif`);
                    
                    // Update color pickers in the modal
                    document.querySelectorAll('#cosmetics-modal input[type="color"]').forEach(input => {
                        const cssVar = input.dataset.cssVar;
                        if (colors[cssVar]) {
                            input.value = colors[cssVar];
                        }
                    });
                    document.getElementById('font-input').value = this.cosmeticsData.fontFamily;
                }

                async deleteCosmeticsKey() {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete all cosmetic settings? This cannot be undone.');
                    if (confirmed) {
                        await this.db.delete(this.db.COSMETICS_KEY);
                        // Reload the page to reset to default settings
                        window.location.reload();
                    }
                }

                async _saveCosmetics() {
                    await this.db.save(this.cosmeticsData.id, this.cosmeticsData);
                }

                

                openCosmeticsModal() {
                    this.applyCosmetics();
                    document.getElementById('cosmetics-modal').style.display = 'flex';
                }

                // ================================================================
                // Settings Modal Methods
                // ================================================================

                openSettingsModal(index) {
                    this.activeModalIndex = index;
                    const buttonData = this.buttonsData[index];
                    const modal = document.getElementById('settings-modal');

                    // Set the initial value of the color picker
                    document.getElementById('button-color-picker').value = this.buttonsData[index].color;

                    document.getElementById('button-name-input').value = buttonData.name;
                    document.getElementById('shuffle-checkbox').checked = buttonData.shuffle;
                    document.getElementById('autoplay-checkbox').checked = buttonData.autoplay;
                    document.getElementById('priority-checkbox').checked = buttonData.priority;
                    document.getElementById('loop-checkbox').checked = buttonData.loop;
                    this._renderFileList(buttonData.files);

                    modal.style.display = 'flex';
                }

                closeSettingsModal() {
                    const modal = document.getElementById('settings-modal');
                    modal.style.display = 'none';
                    this.activeModalIndex = null;
                    this.renderGrid();
                }

                updateModalButtonData(key, value) {
                    if (this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        buttonData[key] = value;
                        this.updateButton(this.activeModalIndex, buttonData);
                    }
                }

                _renderFileList(files) {
                    const fileListElement = document.getElementById('file-list');
                    fileListElement.innerHTML = ''; // Clear the list first

                    if (files.length === 0) {
                        const emptyItem = document.createElement('li');
                        emptyItem.innerHTML = '<small>No files added yet.</small>';
                        fileListElement.appendChild(emptyItem);
                        return;
                    }

                    files.forEach((file, index) => {
                        const listItem = document.createElement('li');
                        // The button is now just part of the HTML string. The single,
                        // delegated listener on the parent list will handle its click.
                        listItem.innerHTML = `
            <span>${file.fileName}</span>
            <button data-file-index="${index}" class="remove-file-button">Remove</button>
        `;
                        fileListElement.appendChild(listItem);
                    });
                }

                async addFilesToModalButton(event) {
                    if (this.activeModalIndex === null) return;
                    const files = event.target.files;
                    if (files.length === 0) return;
                    const buttonData = this.buttonsData[this.activeModalIndex];
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const arrayBuffer = await file.arrayBuffer();
                        const fileData = { fileName: file.name, mimeType: file.type, arrayBuffer: arrayBuffer };
                        buttonData.files.push(fileData);
                    }
                    await this.updateButton(this.activeModalIndex, buttonData);
                    this._renderFileList(buttonData.files);
                }

                async clearModalButtonFiles() {
                    const confirmed = await this.showConfirmModal("Are you sure you want to clear all audio files for this button?");
                    if (confirmed && this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        player.cleanup();
                        buttonData.files = [];
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                async removeFileFromModalButton(event) {
                    const fileIndex = parseInt(event.target.dataset.fileIndex);
                    if (!isNaN(fileIndex)) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        if (!buttonData || !buttonData.files) return;
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        if (player) { player.cleanup(); }
                        buttonData.files.splice(fileIndex, 1);
                        if (buttonData.files.length > 0) { player.playback.currentFileIndex = 0; }
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                // ================================================================
                // Global Functionality Methods
                // ================================================================

                async openBoardSwitcherModal() {
                    const boardIds = await BoardManager.getBoardList(); // UPDATED
                    const boardListElement = document.getElementById('board-list');
                    const modal = document.getElementById('board-switcher-modal');

                    boardListElement.innerHTML = ''; // Clear previous list

                    if (boardIds.length === 0) {
                        boardListElement.innerHTML = '<li><small>No other boards found. Create one by adding "?board=board-name" to the URL.</small></li>';
                    } else {
                        boardIds.forEach(id => {
                            const listItem = document.createElement('li');
                            const link = document.createElement('a');
                            link.textContent = id;
                            // The 'default' board links to the base URL
                            link.href = (id === 'default') ? window.location.pathname : `?board=${id}`;
                            listItem.appendChild(link);
                            boardListElement.appendChild(listItem);
                        });
                    }

                    modal.style.display = 'flex';
                }

                async _handleRemoveButton() {
                    if (this.activeModalIndex === null) return;
                    const confirmed = await this.showConfirmModal("Are you sure you want to permanently remove this button?");
                    if (confirmed) {
                        await this.removeButton(this.activeModalIndex);
                    }
                }

                // REFACTOR: This method now updates the gridLayout as well.
                async removeButton(indexToRemove) {
                    if (this.buttonsData.length <= 1) {
                        return;
                    }

                    this.buttonsData.splice(indexToRemove, 1);
                    if (this.players.has(indexToRemove)) {
                        this.players.get(indexToRemove).cleanup();
                        this.players.delete(indexToRemove);
                    }

                    // Remove from layout
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === indexToRemove));

                    // Re-index subsequent button IDs in both data and layout
                    this.buttonsData.forEach((button, i) => {
                        if (i >= indexToRemove) button.id = i;
                    });
                    this.gridLayout.forEach(item => {
                        if (item.type === 'sound' && item.id > indexToRemove) {
                            item.id--;
                        }
                    });

                    // Clear and re-write the database to maintain consistency
                    await this.db._dbRequest(this.db.SOUNDS_STORE, 'readwrite', 'clear');
                    for (const button of this.buttonsData) {
                        await this.db.save(button.id, button);
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();

                    this.closeSettingsModal();
                    this.renderGrid();
                }

                async downloadConfig() {
                    const allData = await this.db.getAll();
                    const soundboardTitle = document.getElementById('soundboard-title').textContent.trim();
                    const serializableData = allData.map(item => {
                        if (item.files && item.files.length > 0) {
                            const serializableFiles = item.files.map(file => ({ ...file, arrayBuffer: this._arrayBufferToBase64(file.arrayBuffer) }));
                            return { ...item, files: serializableFiles };
                        }
                        return item;
                    });
                    const json = JSON.stringify(serializableData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${Date.now()}_${soundboardTitle}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                async uploadConfig(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            const confirmed = await this.showConfirmModal("This will overwrite your current soundboard configuration. Are you sure?");
                            if (confirmed) {
                                const deserializedData = data.map(item => {
                                    if (item.files && item.files.length > 0) {
                                        const deserializedFiles = item.files.map(file => ({ ...file, arrayBuffer: this._base64ToArrayBuffer(file.arrayBuffer) }));
                                        return { ...item, files: deserializedFiles };
                                    }
                                    return item;
                                });

                                await this.db.clear();
                                for (const item of deserializedData) {
                                    await this.db.save(item.id, item);
                                }

                                await this._loadBoardData();
                                alert("Configuration uploaded successfully!");
                                window.location.reload();
                            }
                        } catch (e) {
                            alert("Failed to read file. Please ensure it is a valid JSON configuration file.");
                            console.error("Upload error:", e);
                        }
                    };
                    reader.readAsText(file);
                }

                _arrayBufferToBase64(buffer) {
                    let binary = '';
                    const bytes = new Uint8Array(buffer);
                    const len = bytes.byteLength;
                    for (let i = 0; i < len; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return btoa(binary);
                }

                _base64ToArrayBuffer(base64) {
                    const binary_string = atob(base64);
                    const len = binary_string.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binary_string.charCodeAt(i);
                    }
                    return bytes.buffer;
                }

                // ================================================================
                // Modal Manager Methods
                // ================================================================

                async showDbManagerModal() {
                    this.updateDbStats();
                    this.updateDbFileList();

                    const checkbox = document.getElementById('persistent-storage-checkbox');
                    if (navigator.storage && navigator.storage.persisted) {
                        checkbox.parentElement.style.display = ''; // Ensure it's visible
                        const isPersisted = await navigator.storage.persisted();
                        checkbox.checked = isPersisted;
                        checkbox.disabled = isPersisted; // ADD THIS LINE to lock the checkbox
                    } else {
                        // If the API isn't supported, hide the option entirely.
                        checkbox.parentElement.style.display = 'none';
                    }


                    document.getElementById('db-manager-modal').style.display = 'flex';
                }

                closeDbManagerModal() {
                    document.getElementById('db-manager-modal').style.display = 'none';
                }

                async updateDbStats() {
                    const dbSizeEl = document.getElementById('db-usage');
                    const dbQuotaEl = document.getElementById('db-quota');
                    const dbButtonCountEl = document.getElementById('db-button-count');

                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    dbButtonCountEl.textContent = soundData.length;

                    if (navigator.storage && navigator.storage.estimate) {
                        const { quota, usage } = await navigator.storage.estimate();
                        dbSizeEl.textContent = this._formatBytes(usage);
                        dbQuotaEl.textContent = this._formatBytes(quota);
                    } else {
                        dbSizeEl.textContent = 'N/A';
                        dbQuotaEl.textContent = 'N/A';
                    }
                }

                async updateDbFileList() {
                    const fileListEl = document.getElementById('db-file-list');
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    fileListEl.innerHTML = '';
                    if (soundData.length === 0) {
                        fileListEl.innerHTML = '<li><small>No sounds found.</small></li>';
                        return;
                    }

                    soundData.forEach(item => {
                        const li = document.createElement('li');
                        li.textContent = `Button ${item.id + 1}: ${item.files.length} file(s)`;
                        fileListEl.appendChild(li);
                    });
                }

                async handleClearDatabase() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';

                    if (boardId === 'default') {
                        // --- NEW LOGIC FOR WIPING THE DEFAULT BOARD ---
                        const confirmed = await this.showConfirmModal("This will wipe all cards and settings from the default board but will PRESERVE your list of other boards. Are you sure?");
                        if (confirmed) {
                            try {
                                // 1. Read the board list and keep it in memory.
                                const boardList = await BoardManager.getBoardList();

                                // 2. Clear both object stores completely.
                                await this.db.clear();

                                // 3. Write the board list back to the now-empty database.
                                await BoardManager.saveBoardList(boardList);

                                // 4. Reload the page to show the fresh default board.
                                window.location.reload();

                            } catch (e) {
                                console.error("Failed to wipe default board:", e);
                            }
                        }
                    } else {
                        // --- EXISTING LOGIC FOR DELETING OTHER BOARDS ---
                        const confirmed = await this.showConfirmModal(`This will permanently delete the entire "${boardId}" board. Are you sure?`);
                        if (confirmed) {
                            try {
                                await this.db.clear();
                                await BoardManager.removeBoardId(boardId);
                                window.location.href = window.location.pathname;
                            } catch (e) {
                                console.error("Failed to clear database:", e);
                            }
                        }
                    }
                }

                showConfirmModal(message) {
                    return new Promise(resolve => {
                        const modal = document.getElementById('confirm-modal');
                        const messageEl = document.getElementById('confirm-modal-message');
                        const yesBtn = document.getElementById('confirm-yes-btn');
                        const noBtn = document.getElementById('confirm-no-btn');
                        messageEl.textContent = message;
                        const handler = (e) => {
                            if (e.target === yesBtn) resolve(true);
                            else if (e.target === noBtn) resolve(false);
                            yesBtn.removeEventListener('click', handler);
                            noBtn.removeEventListener('click', handler);
                            modal.style.display = 'none';
                        };
                        yesBtn.addEventListener('click', handler);
                        noBtn.addEventListener('click', handler);
                        modal.style.display = 'flex';
                        modal.style.zIndex = 1001;
                    });
                }

                _formatBytes(bytes, decimals = 2) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const dm = decimals < 0 ? 0 : decimals;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
                }

                // helper bug more stuff

                async initBugMovement() {
                    const checkbox = document.getElementById('toggle-bug-movement-checkbox');
                    const bug = document.getElementById('help-bug-btn');

                    // Load the state and set the initial UI
                    const state = await this.db.get("bug-movement");
                    const isStill = state ? state.state : false; // Default to false (bug is moving)
                    checkbox.checked = isStill;

                    // Invert the logic: if the bug is 'still', remove the 'bug-moving' class
                    bug.classList.toggle('bug-moving', !isStill);

                    // Attach the single listener for all future changes
                    checkbox.addEventListener('change', async () => {
                        const isNowStill = checkbox.checked;
                        await this.db.save("bug-movement", { id: "bug-movement", state: isNowStill });
                        bug.classList.toggle('bug-moving', !isNowStill);
                    });
                }

            }





            const app = new SoundboardManager(new SoundboardDB());
            app.initialize();
        });
    </script>


    <!-- THE HELPFUL BUG -->
    <button id="help-bug-btn" title="Help">
        <svg width="100%" height="100%" viewBox="0 0 224 240" version="1.1" xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/"
            style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;">
            <g id="Layer3"></g>
            <rect id="Artboard1" x="0" y="0" width="224" height="240" style="fill:none;" />
            <clipPath id="_clip1">
                <rect x="0" y="0" width="224" height="240" />
            </clipPath>
            <g clip-path="url(#_clip1)">
                <g id="Layer4">
                    <path
                        d="M60.644,104.58c-11.256,-5.528 -12.727,-5.926 -26.493,-14.801c-13.766,-8.874 -18.652,-15.658 -20.973,-18.747"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M95.436,55.756c-13.129,-12.407 2.698,-28.163 -0.73,-38.025c-5.141,-14.784 -20.837,-13.943 -29.852,-4.11c-5.483,5.98 -8.152,13.151 -7.828,22.714"
                        style="fill:none;stroke:#00a200;stroke-width:6.64px;" />
                    <path
                        d="M127.345,55.361c13.72,-11.75 -1.318,-28.262 2.589,-37.944c5.858,-14.515 21.493,-12.908 30.017,-2.645c5.184,6.241 7.499,13.533 6.708,23.07"
                        style="fill:none;stroke:#00a200;stroke-width:6.64px;" />
                    <path d="M57.333,140.553c-25.39,8.88 -28.701,38.481 -44.155,44.402"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M76.551,178.048c-12.254,11.196 -24.092,15.043 -26.945,27.627c-2.853,12.585 -12.143,20.721 -22.078,31.575"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M163.356,104.58c11.256,-5.528 12.727,-5.926 26.493,-14.801c13.766,-8.874 18.652,-15.658 20.973,-18.747"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path d="M166.667,140.553c25.39,8.88 28.701,38.481 44.155,44.402"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M147.449,178.048c12.254,11.196 24.092,15.043 26.945,27.627c2.853,12.585 12.143,20.721 22.078,31.575"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M111.527,48.602c19.855,0 35.975,1.319 35.975,15.263c-0,13.945 -16.12,43.015 -35.975,43.015c-19.856,0 -35.521,-29.07 -35.521,-43.015c-0,-13.944 15.665,-15.263 35.521,-15.263Z"
                        style="fill:#00a200;" />
                    <path
                        d="M110.517,76.417c33.618,-0 60.195,16.364 60.195,55.302c0,38.937 -26.577,85.797 -60.195,85.797c-33.618,-0 -61.263,-46.86 -61.263,-85.797c0,-38.938 27.645,-55.302 61.263,-55.302Z"
                        style="fill:#00a200;" />
                    <path
                        d="M110.517,115.143l-36.286,83.255c-0,-0 13.666,19.426 37.464,19.118c21.992,-0.285 36.807,-21.893 36.807,-21.893l-37.985,-80.48Z"
                        style="fill:#a7b700;" />
                    <circle cx="108.983" cy="193.638" r="14.362" style="fill:#e2ff00;" />
                    <path
                        d="M89.067,113.981c2.248,-8.99 10.114,-17.981 22.21,-17.981c10.381,-0 20.733,6.575 21.619,19.105c0.887,12.53 -14.482,22.051 -20.679,23.6c-4.495,1.124 -4.045,11.614 -4.045,22.852"
                        style="fill:none;stroke:#e2ff00;stroke-width:25.54px;" />
                </g>
            </g>
        </svg>
    </button>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Soundboard Help & Info</h3>
            </div>

            <div class="help-accordion">

                <div class="accordion-item">
                    <button class="accordion-header active">Really Simple Overview</button>
                    <div class="accordion-content active"><p>Welcome to the Really Simple Soundboard!

                            I made this for the daily "morning radio" style <a href="https://bugandmoss.com/" target="_blank" rel="noopener noreferrer">podcast</a> that my wife Bug and I make, but then I got carried away...

                            I think this thing is SUPER useful! Not only for podcasting, but for loads of stuff (like my friend Ty who uses it for D&D).

                            The driving principle behind this project was to create a dashboard that is designed to be used WHILE recording.

                            It's a simple, customizable soundboard that works in your browser and can be installed as a Progressive Web App (PWA) to use offline. (There's an install button in the section about this!)

                            It's also all packed into ONE big HTML file (which I know is bad practice lol) so if you want to copy this whole thing over to your site, all you have to do is save this page.

                            All of your files stay on your device - nothing is uploaded anywhere except your local browser storage!

                            Initially, it was just a customizable local soundboard, but it has since grown to have different kinds of cards with various features that you can explore in the list below!

                            <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html"
                                target="_blank" rel="noopener noreferrer">Steal this, change it, use it however you'd like!</a> I don't care what you do with it, except for ONE rule: you cannot monetize it.

                            (Tip: click the title at the top to change it to whatever you want!)

                            Created with love by Mason Amadeus for Bug JennettðŸ’– (and you)

                            <a href="https://bugandmoss.com/" target="_blank" rel="noopener noreferrer"><i>Listen to "Bug & Moss" every weekday morning!</i></a>
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">The Control Card</button>
                    <div class="accordion-content"><p>This is the card with a bunch of buttons. It's the main hub for managing your soundboard.</p>
                        <ul><li><b>Add Sound/Timer/Note:</b> Creates a new card of that type!
                                
                                They'll spawn immediately to the LEFT of the control card.

                                (More details about each type can be found in their own dropdowns.)
                            </li>
                            
                            <li><b>Rearrange:</b> Toggles rearrange mode. Click and drag cards to SWAP their positions.

                                I know this is a bit of a PITA. Someday I hope to make it so you can drop cards in-between, and they'll scoot over instead of swapping. If you wanna help, this thing is <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html" target="_blank">on github</a>.
                            </li>

                            <li><b>Upload/Download:</b> Save or load your entire board configuration, INCLUDING THE SOUNDS, to a JSON file!

                                It'll pop into your downloads without a popup (probably), and the title will be whatever your board title is.

                                (Nerds: the files are stored as an array buffer in IndexedDB, and converted to base64 when they go into the json)
                            </li>

                            <li><b>Storage:</b> An overview of how much of your browser storage is being used, as well as a setting to toggle "storage durability" which should provide a little extra protection against accidental data loss!

                                This is also where you go to delete your entire board, if you want to do that! It also deletes the associated sound files.
                            </li>

                            <li><b>Cosmetics:</b> Change the colors and font of your soundboard.

                                This is probably the jankiest cosmetic menu on earth, and I'm particularly proud of the font selector lmao.
                            </li>

                            <li><b>Switch Board:</b> Switch between different soundboards, or create new ones!

                                Make as many boards as you want! Just beware that I haven't tested any of this with an extreme amount of buttons/boards/data, so I have no idea what happens if it gets too big.</li>
                                (Nerds: This works by changing the url to have a parameter named after the board name you choose, which causes a new IndexedDB database to be created. I dunno what happens if you make two boards with the same name, but it probably breaks.)
                        </ul>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Sound Buttons</button>
                    <div class="accordion-content"><p>
                            <b>Play a sound</b> by clicking the big button.

                            <b>Stop a sound</b> by clicking the button while a sound is playing. If there are multiple files in the button, this will skip to the next file (depending on the other options explained below).

                            <b>Volume</b> affects how loud the sound plays.

                            <b>Speed</b> affects the playback speed of the sound. It's a bit jank, but it's pretty fun.

                            <b>Edit the button</b> by clicking the colorful triangle corner in the bottom right of the button.

                            Inside the settings menu you can:

                            <b>Change the button color</b> using the little colored square to the left of the button title field.

                            <b>Change the button name</b> by clicking on the title field and typing a new name.

                            <b>Multiple sounds</b> can be added to a button. There is no limit! You can remove individual files from the list, or clear them all using labeled buttons.

                            <b>Random</b> will randomly select a file from that button each time it is clicked to play.

                            <b>Autoplay</b> will automatically play the next sound when the currently playing sound ends.

                            <b>Priority</b> is useful for situations like playing a bumper over music. Any buttons with "Priority" will temporarly turn down any non-priority buttons until the priority sound finishes. It's auto-ducking, basically!

                            <b>Loop</b> will loop whatever sound is playing, restarting it when it ends.
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Timers</button>
                    <div class="accordion-content"><p>Timers run a countdown, and can also trigger buttons at the start and end!

                            <b>Start</b> will start the timer.

                            <b>Reset</b> will stop and reset the timer to its initial time, but WILL NOT reset any other settings (like Starts & Ends With cues).

                            Uncheck "Lock Timer Settings" to edit the following timer properties:

                            <b>"Starts With"</b> lets you select a button to play when the timer starts.

                            <b>"Ends With"</b> lets you select a button to play at the end of the timer -- with a catch!

                            When you have selected an "Ends With" sound, <b><i>the timer will hit 0:00 exactly as the "Ends With" sound FINISHES playing!</b></i>

                            This makes it a powerful tool for timed segments, as you can input the desired segment length and your outro cue will 'play you out' automagically!

                            Sometimes this function fails to calculate the length of the end cue (I've only had it fail on mobile), and as a fallback - it will play when the timer ends. But 99% of the time, the Timer Card should end WITH the sound.
                            
                            The timer is pretty darn accurate, and stays running even if the tab is in the background or the page is refreshed!
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Notepads</button>
                    <div class="accordion-content"><p>A simple place to keep notes!

                            I like to use it to copy/paste URLs for articles or stuff we talk about on the show. Or to jot down stuff to talk about on future shows.

                            You can even store multiple notes in a single card. Click the little "+" button to add a new tab inside the note card.

                            You can edit the title of a note by clicking the text "New Note" and changing it to whatever you want.

                            Other than that it's just a text box. Go crazy!
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Offline Use (PWA)</button>
                    <div class="accordion-content"><p>This soundboard is an installable Progressive Web App (PWA).

                            <b>IMPORTANT:</b> When you install this as an app, your boards will NOT transfer over automatically. You will not lose any data, but any boards you have already created will need to be downloaded from the website and then uploaded to the app.

            <button id="install-pwa-btn" class="install-button-modal" disabled>Install App for Offline Use</button>
                            <b>If the install button is greyed-out or disabled,</b> it means your browser isn't ready. Sometimes this takes a second. Try waiting a minute and reloading the page.

                            If you're on mobile, you might have to go to "Share Page" and then "Add to Home Screen" (or something like that).
                            
                            As always, ALL of your data is stored ONLY on your device. Even if you use the website version. I don't want to pay for a server lmao.

                            Your data is stored locally and can be double-protected from automatic cleanup by enabling "Storage Durability" in the Storage menu. Mobile doesn't seem to like that.

                            IndexedDB is pretty robust, and doesn't tend to clear out unless you're REALLY low on space - so you probably don't even need to worry about it.

                            (Tip: if you REALLY want to use this soundboard on mobile, create the boards on a computer first, download your config, email it to yourself, download it from the email on your phone, and upload the config to the mobile site/app. Badaboom, it works.)

                        </p>
                    </div>
                </div>

                <div class="modal-checkbox-group" style="margin-top: 1rem">
                    <label>
                        <input type="checkbox" id="toggle-bug-movement-checkbox">
                        Hold still, Bug!
                    </label>
                </div>

            </div>
        </div>
</body>

</html>
