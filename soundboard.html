<!DOCTYPE html>
<html lang="en">
    <!-- TO DO :
     
        - OBS INTEGRATIONS
        - CACHE GOOGLE FONTS
        - SELF-PACKING SERVICE WORKER PWA SELF-CONTAINED
        - LET TIMERS TRIGGER TIMERS
    

    -->

<head>

    <meta property="og:title" content="Bug & Moss Really Simple Soundboard">
    <meta property="og:description"
        content="A simple, feature-rich, fully-local, offline-capable infinite soundboard app for broad (and pod) casting.">
    <meta property="og:image" content="https://bugandmoss.com/images/soundboardscreenshot.jpg">
    <meta property="og:url" content="https://bugandmoss.com/soundboard.html">
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Soundboard | B&M Really Simple Soundboard</title>
    <style>
        /* =================================================================== */
        /* CORE LAYOUT & THEMING
/* =================================================================== */
        :root {
            /* Base Color Palette */
            --background-color: #f7fafc;
            --panel-color: #95c7ff;
            --accent-color: #3bb273;
            --highlight-color: #ff914d;

            /* Text Colors (Static) */
            --primary-color: #234e70;
            /* Dark Text */
            --secondary-color: #cce0ec;
            /* Light Text */

            /* Dynamic Text Colors (Set by JS) */
            --panel-color-text: #234e70;
            --accent-color-text: #234e70;
            --highlight-color-text: #234e70;
            --primary-color-text: #cce0ec;
            --background-color-text: #234e70;

            /* Typography */
            --font-family-primary: 'Wellfleet', sans-serif;
        }

        .accent-color {
            background-color: var(--accent-color) !important;
            color: var(--accent-color-text) !important;
        }

        .primary-color {
            background-color: var(--primary-color) !important;
            color: var(--primary-color-text) !important;
        }

        .panel-color {
            background-color: var(--panel-color) !important;
            color: var(--panel-color-text) !important;
        }

        .secondary-color {
            background-color: var(--secondary-color) !important;
            color: var(--secondary-color-text) !important;
        }

        .highlight-color {
            background-color: var(--highlight-color) !important;
            color: var(--highlight-color-text) !important;
        }

        .background-color {
            background-color: var(--background-color) !important;
            color: var(--background-color-text) !important;
        }

        /* =================================================================== */
        /* SCROLLBAR STYLING
/* =================================================================== */

        /* --- Standard Firefox Styling --- */
        * {
            scrollbar-width: thin;
            /* "auto" or "thin" */
            scrollbar-color: var(--accent-color) var(--secondary-color);
            /* thumb and track */
        }

        /* --- WebKit (Chrome, Safari, Edge) Styling --- */
        ::-webkit-scrollbar {
            width: 10px;
            /* Width of the entire scrollbar */
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary-color);
            /* The track (the part the thumb slides along) */
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--accent-color);
            /* The draggable scrolling handle */
            border-radius: 6px;
            /* Rounded corners on the thumb */
            border: 2px solid var(--secondary-color);
            /* Creates padding around the thumb */
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--highlight-color);
            /* Color of the thumb on hover */
        }

        body {
            font-family: var(--font-family-primary);
            background-color: var(--background-color);
            color: var(--background-color-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #soundboard-title {
            text-align: center;
            cursor: text;
            padding: 1rem;
            transition: background-color 0.3s ease;
        }

        #soundboard-title:hover,
        #soundboard-title:focus {
            background-color: var(--panel-color);
            outline: none;
        }

        /* =================================================================== */
        /* BUTTONS & GENERAL CONTROLS
/* =================================================================== */
        button {
            font-family: var(--font-family-primary);
            border: none;
            cursor: pointer;
            transition: filter 0.3s ease;
            background-color: var(--accent-color);
            color: var(--accent-color-text);
            padding: 1rem;
        }

        #button-color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            padding: 0;
            border: 2px solid var(--primary-color);
            background-color: transparent;
            cursor: pointer;
        }


        .title-and-color {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .title-and-color input[type="text"] {
            flex-grow: 1;
            /* Allows the text input to fill available space */
        }

        button:hover {
            filter: brightness(90%);
        }

        .danger {
            background-color: #d9534f !important;
            /* A consistent red for danger actions */
            color: white !important;
            padding: 1rem;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .slider-group label {
            width: 60px;
            font-size: 0.875rem;
            color: var(--panel-color-text);
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: var(--secondary-color);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        /* =================================================================== */
        /* GRIDS & CARDS
/* =================================================================== */
        .soundboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .sound-card {
            background-color: var(--panel-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            align-self: start;
            align-items: center;
            margin: auto;
            width: 100%;
            box-sizing: border-box;
        }

        .hover-glow {
            box-shadow: 0px 0px 8px var(--highlight-color) !important;
        }

        /* --- Drag & Drop Styles --- */
        .soundboard-grid.rearrange-mode {
            cursor: grab;
        }

        .soundboard-grid.rearrange-mode .sound-card {
            transform: rotate(1deg);
            border: 2px solid var(--highlight-color);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .soundboard-grid.rearrange-mode .sound-card:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        .sound-card.dragging {
            opacity: 0.5;
        }

        .soundboard-grid.rearrange-mode .sound-card.drag-over {
            border: 2px dashed var(--highlight-color);
            transform: scale(1.05);
        }

        /* =================================================================== */
        /* SOUND BUTTON CARDS
/* =================================================================== */
        .sound-button {
            position: relative;
            width: 100%;
            height: 100px;
            background-color: var(--accent-color);
            color: var(--accent-color-text);
            font-size: 1.25rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            transition: width 0.1s linear;
        }

        .button-text {
            position: relative;
            z-index: 1;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .settings-triangle-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 0;
            height: 0;
            border-bottom: 40px solid var(--highlight-color);
            border-left: 40px solid transparent;
            z-index: 2;
        }

        .settings-triangle-btn svg {
            position: absolute;
            top: -30px;
            left: 10px;
            z-index: 3;
            width: 20px;
            height: 20px;
            color: var(--highlight-color-text);
        }

        .sound-controls {
            width: 100%;
        }

        .sound-controls .speed-display {
            color: var(--panel-color-text);
        }

        /* =================================================================== */
        /* CONTROL CARD
/* =================================================================== */
        #control-card-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .span-two-columns {
            grid-column: span 2;
        }

        .span-three-columns {
            grid-column: span 3;
        }

        /* General button style within the control card */
        #control-card-actions button {
            padding: 0.75rem;
            font-size: 1.2rem;
            font-weight: 500;
            text-align: center;
            background-color: var(--accent-color);
            color: var(--accent-color-text);
        }

        /* Specific overrides for uniquely colored buttons */
        #rearrange-mode-btn {
            background-color: var(--highlight-color) !important;
            color: var(--highlight-color-text) !important;
        }

        #switch-board-btn {
            background-color: var(--primary-color) !important;
            color: var(--primary-color-text) !important;
        }

        /* =================================================================== */
        /* TIMER CARDS
/* =================================================================== */


        .timer-title {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            color: var(--panel-color-text);
            border: 2px solid transparent;
            width: 90%;
            padding: 0.5rem;
            transition: border-color 0.2s ease;
        }

        .timer-title[contenteditable="true"] {
            background-color: var(--background-color);
            color: var(--background-color-text);
            border-color: var(--highlight-color);
            outline: none;
            cursor: text;
        }

        .timer-display {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            position: relative;
            padding: 0.5rem;
            background-color: var(--panel-color);
            color: var(--panel-color-text);
            border: 2px solid var(--secondary-color);
            /* Creates a darkening overlay on top of the panel color */
            background-image: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2));
            width: 90%;
        }

        timer-display span {
            position: relative;
            z-index: 1;
        }

        .timer-progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
        }

        .timer-display.running {
            color: var(--accent-color);
        }

        .timer-display.finished {
            color: var(--highlight-color);
        }

        .timer-seconds-value,
        .timer-minutes-value {
            width: 2rem;
            /* Set a fixed width */
            text-align: center;
            border: 0px;
            background-color: var(--panel-color);
            color: var(--panel-color-text);
            font-family: var(--font-family-primary);
            font-size: 1rem;
            margin: 0;
            -moz-appearance: textfield;
            /* Hide the Firefox spin buttons */
        }

        /* Hide spin buttons for WebKit browsers (Chrome, Safari) */
        .timer-seconds-value::-webkit-inner-spin-button,
        .timer-seconds-value::-webkit-outer-spin-button,
        .timer-minutes-value::-webkit-inner-spin-button,
        .timer-minutes-value::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .timer-options-toggle label,
        .timer-mode-selector label,
        .timer-sound-select label {
            color: var(--panel-color-text);
            user-select: none;
        }

        .timer-mode-selector {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 0.75rem;
        }

        .timer-options-toggle {
            margin-bottom: 1rem;
        }

        .timer-sound-select {
            margin-bottom: 1rem;
            display: flex;
            width: 100%;
        }

        .timer-end-sound,
        .timer-start-sound {
            font-size: 1rem;
            width: 60%;
            margin-left: auto;
            border: 0px;
            font-family: var(--font-family-primary);
            color: var(--secondary-color-text);
            background-color: var(--secondary-color);
        }

        .timer-controls {
            width: 100%;
        }

        .timer-controls .slider-group span {
            min-width: 25px;
            text-align: center;
            color: var(--panel-color-text);
        }

        .timer-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .timer-buttons button {
            flex-grow: 1;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            background-color: var(--accent-color);
            color: var(--accent-color-text);
        }

        .timer-buttons .reset-timer-btn {
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
        }

        .remove-timer-btn {
            width: 100%;
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
        }

        .timer-options-container.hidden-options {
            display: none;
        }

        /* =================================================================== */
        /* NOTEPAD CARDS
/* =================================================================== */
        .notepad-card {
            align-self: stretch;
            /* Allows notepad to fill vertical space, overriding .sound-card */
        }

        .notepad-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            width: 100%;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--secondary-color);
        }

        .notepad-tab,
        .add-page-btn {
            border: 1px solid var(--secondary-color);
            background-color: var(--background-color);
            padding: 0.4rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .add-page-btn {
            margin-left: auto;
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
            font: var(--font-family-primary);
            font-weight: 800;
        }

        .notepad-tab-title {
            cursor: pointer;
            outline: none;
            font-size: 1rem;
            white-space: nowrap;
            user-select: none;
            padding-right: 0.5rem;
        }

        .notepad-tab.active {
            background-color: var(--accent-color);
            color: var(--accent-color-text);
            font-weight: bold;
            border-color: var(--accent-color);
        }

        .notepad-tab.active .notepad-tab-title {
            cursor: text;
        }

        .delete-page-btn {
            color: darkred;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem;
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        .delete-page-btn:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .notepad-content {
            flex-grow: 1;
            width: 100%;
            border: none;
            background-color: var(--secondary-color);
            padding: 0.5rem;
            font-family: sans-serif;
            font-size: 1rem;
            color: var(--secondary-color-text);
            resize: vertical;
            box-sizing: border-box;
            min-height: 150px;
            font: var(--font-family-primary);
        }

        .notepad-content:focus {
            outline: 1px solid var(--highlight-color);
        }

        /* =================================================================== */
        /* MODALS
        /* =================================================================== */
        .modal,
        .confirm-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            align-items: center;
            justify-content: center;
        }

        .modal-content,
        .confirm-modal-content {
            background-color: var(--panel-color);
            color: var(--panel-color-text);
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-section {
            margin-bottom: 1.5rem;
        }

        .modal-section h3,
        .modal-section h4 {
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.25rem;
        }

        .modal-section label {
            display: block;
            margin-bottom: 0.5rem;
        }

        .modal-section input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 1.25rem;
            background-color: var(--background-color);
            border: 1px solid var(--primary-color);
            color: var(--background-color-text);
        }

        .modal-actions-row {
            display: flex;
            justify-content: space-between;
        }

        /* --- Specific Modal Buttons --- */
        .file-input-container label,
        .modal-actions-row button,
        #create-new-board-btn {
            background-color: var(--accent-color);
            color: var(--accent-color-text);
            padding: 0.75rem 1.5rem;
            text-align: center;
        }

        #clear-files-btn {
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
        }

        /* --- File List --- */
        .file-list {
            list-style: none;
            padding: 0;
        }

        .file-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--background-color);
            color: var(--background-color-text);
            font-size: 1rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid var(--panel-color);
        }

        .file-list li a {
            color: var(--background-color-text);
        }

        .file-list button {
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }

        /* --- Checkboxes --- */
        .modal-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .modal-checkbox-group input[type="checkbox"] {
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid var(--primary-color);
            cursor: pointer;
            position: relative;
            display: flex;

        }


        .modal-actions-row {
            display: flex;
            justify-content: space-between;

        }

        .modal-checkbox-group {
            display: flex;
            gap: 1.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .modal-checkbox-group input[type="checkbox"]:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .modal-checkbox-group input[type="checkbox"]:checked::after {
            content: 'âœ”';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent-color-text);
            font-size: 1rem;
        }

        /* --- Color Pickers --- */
        .color-palette-grid {
            display: grid;
            /* Use 'repeat' with 'auto-fill' to create a flexible grid */
            grid-template-columns: repeat(auto-fill,  1fr);
            gap: 1rem;
        }

        .color-palette-buttons {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5%;
        }

        .color-box {
            position: relative;
            /* This padding technique creates a square box that scales */
            padding-top: 50%;
            /* Let the grid control the width */
            width: 100%;
            height: 0;
            border: 0px solid var(--primary-color);
            overflow: hidden;
        }

        /* Style the color input to fill the entire box */
        .color-box input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 0;
            border: 0;
            cursor: pointer;
            border-radius: 0;
            z-index: 1;
            /* Ensure the input is above the background color */
        }

        /* Style the label as an overlay */
        .color-box label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            /* Make the label sit on top of the color input */
            font-size: 100%;
            text-align: center;
            white-space: nowrap;
            pointer-events: none;
        }

        /* --- Confirmation Modal --- */
        .confirm-modal-content {
            text-align: center;
            max-width: 400px;
        }

        .confirm-modal-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .confirm-modal-actions button {
            padding: 0.75rem 1.5rem;
            font-weight: bold;
        }

        .confirm-yes-btn {
            background-color: var(--accent-color);
            color: var(--accent-color-text);
        }

        .confirm-no-btn {
            background-color: var(--highlight-color);
            color: var(--highlight-color-text);
        }

        /* =================================================================== */
        /* HELPER BUG & ACCORDION
/* =================================================================== */
        #help-bug-btn {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 50;
            min-width: 30px;
            min-height: 30px;
            max-width: 80px;
            max-height: 80px;
            background: transparent;
        }

        .bug-moving {
            animation: skitter 8s ease-in-out infinite;
        }

        .accordion-header {
            width: 100%;
            background-color: transparent;
            text-align: left;
            padding: 1rem;
            font-size: 1.1rem;
            font-weight: bold;
            position: relative;
            color: var(--panel-color-text);
        }

        .accordion-header::after {
            content: '+';
            position: absolute;
            right: 1rem;
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        .accordion-header.active::after {
            transform: rotate(45deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            background-color: var(--background-color);
            color: var(--background-color-text);
            padding: 0 1rem;
            white-space: pre-line;
        }

        .accordion-content.active {
            max-height: 200px;
            /* Adjust as needed */
            overflow-y: auto;
            padding: 1rem;
        }

        @keyframes skitter {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            4% {
                transform: translate(15px, 5px) rotate(25deg);
            }

            8% {
                transform: translate(15px, 5px) rotate(25deg);
            }

            15% {
                transform: translate(-10px, -10px) rotate(-15deg);
            }

            18% {
                transform: translate(-8px, -12px) rotate(-20deg);
            }

            20% {
                transform: translate(-10px, -10px) rotate(-15deg);
            }

            28% {
                transform: translate(20px, -5px) rotate(40deg);
            }

            35% {
                transform: translate(20px, -5px) rotate(40deg);
            }

            50% {
                transform: translate(-15px, 20px) rotate(-30deg);
            }

            60% {
                transform: translate(-15px, 20px) rotate(-30deg);
            }

            63% {
                transform: translate(-12px, 22px) rotate(-35deg);
            }

            65% {
                transform: translate(-15px, 20px) rotate(-30deg);
            }

            75% {
                transform: translate(10px, 10px) rotate(15deg);
            }

            85% {
                transform: translate(10px, 10px) rotate(15deg);
            }

            95% {
                transform: translate(2px, 2px) rotate(5deg);
            }
        }
    </style>
    <style name="ThemeManager">
        #theme-library-list {
            max-height: 200px;
            /* Adjust this value as needed */
            overflow-y: auto;
            border: 1px solid var(--secondary-color);
            padding: 0.5rem;
        }

        .theme-list-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            padding: 0.25rem;
            font-size: 0.75rem;
        }

        .theme-list-buttons button {
            margin: 0.1rem;
        }

        .theme-list-item-template span {
            font-size: 2rem;
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 id="soundboard-title" contenteditable="true">Bug & Moss Really Simple Soundboard</h1>

        <div id="soundboard-grid" class="soundboard-grid">
        </div>

    </div>

    <template id="notepad-card-template">
        <div class="sound-card special-function-card notepad-card">
            <div class="notepad-tabs">
                <button class="add-page-btn">+</button>
            </div>
            <textarea class="notepad-content" placeholder="Type your notes here..."></textarea>
        </div>
    </template>

    <template id="timer-card-template">
        <div class="sound-card special-function-card timer-card">
            <div class="timer-title" contenteditable="false">New Timer</div>
            <div class="timer-display">
                <span>00:00</span>
                <div class="timer-progress-overlay"></div>
            </div>
            <div class="timer-controls">
                <div class="timer-options-toggle">
                    <label>
                        <input type="checkbox" class="hide-timer-options-toggle" value="false">
                        Lock Timer Settings
                    </label>
                </div>
                <div class="timer-options-container">


                    <div class="slider-group">
                        <label>Minutes:</label>
                        <input type="range" class="timer-minutes-range" min="0" max="90" value="0">
                        <input type="number" class="timer-minutes-value" data-type="minutes" min="0" max="90" value="0">
                    </div>
                    <div class="slider-group">
                        <label>Seconds:</label>
                        <input type="range" class="timer-seconds-range" min="0" max="59" value="30">
                        <input type="number" class="timer-seconds-value" data-type="seconds" min="0" max="59"
                            value="30">
                    </div>

                    <div class="timer-mode-selector">
                        <label>
                            <input type="radio" name="timer-mode" class="timer-mode-radio" value="timer" checked> Timer
                        </label>
                        <label>
                            <input type="radio" name="timer-mode" class="timer-mode-radio" value="stopwatch"> Stopwatch
                        </label>
                    </div>

                    <div class="timer-sound-select start-sound-container">
                        <label class="start-sound-label">Start with:</label>
                        <select class="timer-start-sound"></select>
                    </div>
                    <div class="timer-sound-select end-sound-container">
                        <label>End with:</label>
                        <select class="timer-end-sound"></select>
                    </div>
                    <div class="timer-sound-select">
                        <label>
                            <input type="checkbox" class="timer-loop-checkbox" style="margin-right: 0.5rem;">Auto
                            Restart
                        </label>
                    </div>
                </div>
                <div class="timer-buttons">
                    <button class="start-pause-timer-btn">Start</button>
                    <button class="reset-timer-btn">Reset</button>
                </div>

                <div class="timer-options-container">

                    <button class="remove-timer-btn danger">Remove Timer</button>
                </div>
            </div>
        </div>
    </template>

    <div id="control-card" class="sound-card special-function-card" data-card-type="control" data-card-id="control-card"
        style="display: none;">
        <div id="control-card-actions">
            <button id="add-btn-plus" title="Add a new button" class="span-two-columns">Add Sound</button>
            <button id="add-timer-btn">Add Timer</button>
            <button id="add-notepad-btn">Add Note</button>
            <button id="rearrange-mode-btn" class="span-two-columns">Rearrange</button>
            <button id="upload-config-btn">Upload</button>
            <button id="download-config-btn">Download</button>
            <button id="switch-board-btn" class="span-two-columns">Switch
                Board</button>
            <button id="cosmetics-btn">Cosmetics</button>
            <button id="db-manager-btn">Storage</button>


        </div>
    </div>


    <input type="file" id="upload-config-input" accept="application/json" style="display: none;">

    <div id="confirm-modal" class="confirm-modal">
        <div class="confirm-modal-content">
            <p id="confirm-modal-message"></p>
            <div class="confirm-modal-actions">
                <button id="confirm-yes-btn" class="confirm-yes-btn">Yes</button>
                <button id="confirm-no-btn" class="confirm-no-btn">No</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div id="modal-content" class="modal-content">


            <div class="modal-section">
                <h3>Button Settings</h3>
                <div class="title-and-color">
                    <input type="color" id="button-color-picker">
                    <input type="text" style="font-size: 1rem;" id="button-name-input">
                </div>
            </div>


            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <label>
                        <input type="checkbox" id="shuffle-checkbox">
                        Random
                    </label>
                    <label>
                        <input type="checkbox" id="autoplay-checkbox">
                        Autoplay
                    </label>
                    <label>
                        <input type="checkbox" id="priority-checkbox">
                        Priority
                    </label>
                    <label>
                        <input type="checkbox" id="loop-checkbox">
                        Loop
                    </label>

                </div>
            </div>

            <div class="modal-section">
                <h3>Audio Files</h3>
                <div class="file-input-container">
                    <label for="add-file-input" class="file-input-label">Add Audio File</label>
                    <input type="file" id="add-file-input" accept="audio/*" multiple style="display: none;">
                </div>
                <ul id="file-list" class="file-list"></ul>
                <div class="modal-actions-row">
                    <button id="remove-button-modal" class="danger">Delete Button</button>
                    <button id="clear-files-btn" class="highlight-color">Clear
                        All</button>
                </div>
            </div>

        </div>
    </div>

    <div id="db-manager-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Local Database Manager</h3>
            </div>
            <div class="modal-section">
                <div id="db-stats-container">
                    <div class="stat-line">
                        <span>Total Buttons:</span> <span id="db-button-count">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>IndexedDB Usage:</span> <span id="db-usage">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>Available Quota:</span> <span id="db-quota">Calculating...</span>
                    </div>
                </div>
            </div>
            <div class="modal-section">
                <h3>Stored Sounds</h3>
                <ul id="db-file-list">
                    <li><small>No sounds found.</small></li>
                </ul>
            </div>
            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <input type="checkbox" id="persistent-storage-checkbox">
                    <h4>Storage Durability</h4>
                </div>
                <small>Recommended for offline use. Your browser may ask for permission.</small>
            </div>

            <div class="modal-section">
            </div>

            <div class="modal-section">
                <button id="clear-database-btn" class="danger">Delete Everything & Try Again</button>
            </div>
        </div>
    </div>

    <div id="cosmetics-modal" class="modal">
        <div class="modal-content">
            <div class="modal-section">
                <h4>Font Selection</h4>
                <label for="font-input">Enter a font name:</label>
                <input type="text" id="font-input" placeholder="Wellfleet">
                <small>You can use any font from <a href="https://fonts.google.com/" target="_blank"
                        rel="noopener noreferrer">Google
                        Fonts</a>.</small>
            </div>
            <div class="modal-section">
                <h4>Color Palette</h4>
                <div class="color-palette-grid">

                    <div class="color-box">
                        <input type="color" id="primary-color-picker" data-css-var="--primary-color">
                        <label for="primary-color-picker" style="color:var(--primary-color-text)">Dark Text</label>
                    </div>
                    <div class="color-box">
                        <input type="color" id="secondary-color-picker" data-css-var="--secondary-color">
                        <label for="secondary-color-picker" style="color:var(--secondary-color-text)">Light Text</label>
                    </div>
                    <div class="color-box">
                        <input type="color" id="panel-color-picker" data-css-var="--panel-color">
                        <label for="panel-color-picker" style="color:var(--panel-color-text)">Panel</label>
                    </div>
                    <div class="color-box">
                        <input type="color" id="background-color-picker" data-css-var="--background-color">
                        <label for="background-color-picker"
                            style="color:var(--background-color-text)">Background</label>
                    </div>
                    <div class="color-box">
                        <input type="color" id="accent-color-picker" data-css-var="--accent-color">
                        <label for="accent-color-picker" style="color:var(--accent-color-text)">Accent</label>
                    </div>
                    <div class="color-box">
                        <input type="color" id="highlight-color-picker" data-css-var="--highlight-color">
                        <label for="highlight-color-picker" style="color:var(--highlight-color-text)">Highlight</label>
                    </div>

                    <button id="delete-cosmetics-key-btn" class="danger span-three-columns">Reset Current
                        Appearance</button>
                </div>

            </div>

            <div class="modal-section">
                <h4>Save Current Theme</h4>
                <div class="title-and-color">
                    <input type="text" id="save-theme-name-input" placeholder="Enter theme name...">
                    <button id="save-theme-btn" class="accent-color" style="padding: 0.5rem 1rem;">Save</button>
                </div>
            </div>

            <div class="modal-section">
                <h4>My Themes</h4>
                <ul id="theme-library-list" class="file-list">
                    <li><small>No saved themes yet.</small></li>
                </ul>
            </div>

            <div class="modal-section">
                <h4>Manage Themes</h4>
                <div class="color-palette-buttons">
                    <button id="download-theme-btn" class="accent-color">Download Current</button>
                    <button id="upload-theme-btn" class="highlight-color">Upload Single</button>
                    <div>
                        <h4>|</h4>
                    </div>
                    <button id="download-library-btn" class="accent-color">Download Library</button>
                    <button id="upload-library-btn" class="highlight-color">Upload Library</button>

                </div>
                <input type="file" id="upload-theme-input" accept="application/json" style="display: none;">
                <input type="file" id="upload-themelibrary-input" accept="application/json" style="display: none;">
            </div>

        </div>
    </div>

    <template id="theme-list-item-template">
        <li>
            <span class="theme-name"></span>
            <div class="theme-list-buttons">
                <button class="apply-theme-btn primary-color"><span>Apply</span></button>
                <button class="download-theme-btn accent-color"><span>Download</span></button>
                <button class="rename-theme-btn highlight-color"><span>Rename</span></button>
                <button class="delete-theme-btn danger"><span>Delete</span></button>
            </div>
        </li>
    </template>

    <div id="board-switcher-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Switch Soundboard</h3>
            </div>
            <div class="modal-section">
                <ul id="board-list" class="file-list">
                </ul>
            </div>

            <div class="modal-section" style="border-top: 1px solid var(--secondary-color); padding-top: 1.5rem;">
                <h4>Create New Board</h4>
                <div class="title-and-color">
                    <input type="text" id="new-board-name-input" placeholder="New board name...">
                    <button id="create-new-board-btn">Create</button>
                </div>
            </div>

        </div>
    </div>
    <script name="Class-ThemeManager">
        /**
         * Manages all aspects of the soundboard's appearance, including the current
         * board's theme and the global library of saved themes.
         */
        /**
         * Manages all aspects of the cosmetics modal, including its UI,
         * event listeners, and all data interactions for themes.
         */
        class ThemeManager {
            // Constants for database keys
            static COSMETICS_KEY = 'cosmetics-config';
            static THEME_LIBRARY_KEY = 'theme-library';

            constructor(db, defaultDb, soundboardManager) {
                // Core dependencies
                this.db = db;
                this.defaultDb = defaultDb;
                this.soundboardManager = soundboardManager; // For confirm modals

                // Data state
                this.cosmeticsData = null;
                this.debouncedSave = debounce(() => this.saveCurrentCosmetics(), 300);

                // UI Element References
                this.modal = document.getElementById('cosmetics-modal');
                this.fontInput = document.getElementById('font-input');
                this.colorPickers = this.modal.querySelectorAll('input[type="color"]');
                this.saveThemeNameInput = document.getElementById('save-theme-name-input');
                this.themeList = document.getElementById('theme-library-list');
                this.uploadThemeInput = document.getElementById('upload-theme-input');
                this.uploadThemeLibraryInput = document.getElementById('upload-themelibrary-input');

                // This single call sets up all modal interactivity.
                this._attachListeners();
            }

            /**
             * Initializes the manager by loading the current board's cosmetics.
             */
            async init() {
                await Promise.all([
                    this.db.openDB(),
                    this.defaultDb.openDB()
                ]);
                await this.loadCurrentCosmetics();
            }

            /**
             * Attaches all necessary event listeners for the cosmetics modal.
             * This keeps the setup logic contained within the class.
             */
            _attachListeners() {
                this.modal.addEventListener('click', (e) => {
                    if (e.target.id === 'cosmetics-modal') this.close();
                });

                this.colorPickers.forEach(input => {
                    input.addEventListener('input', (e) => this.updateColor(e.target.dataset.cssVar, e.target.value));
                });
                this.fontInput.addEventListener('change', (e) => this.updateFont(e.target.value));

                // THEME MANAGEMENT
                document.getElementById('download-theme-btn').addEventListener('click', () => this.downloadCurrentTheme());
                document.getElementById('upload-theme-btn').addEventListener('click', () => this.uploadThemeInput.click());
                this.uploadThemeInput.addEventListener('change', (e) => this._handleThemeUpload(e));

                document.getElementById('download-library-btn').addEventListener('click', () => this.downloadThemeLibrary());
                document.getElementById('upload-library-btn').addEventListener('click', () => this.uploadThemeLibraryInput.click());
                this.uploadThemeLibraryInput.addEventListener('change', (e) => this._handleLibraryUpload(e));

                document.getElementById('delete-cosmetics-key-btn').addEventListener('click', () => this._handleResetCosmetics());

                document.getElementById('save-theme-btn').addEventListener('click', () => this._handleSaveTheme());
                this.themeList.addEventListener('click', (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;
                    
                    const themeId = button.dataset.themeId;
                    if (!themeId) return;
                    if (button.classList.contains('apply-theme-btn')) this._handleApplyTheme(themeId);
                    if (button.classList.contains('rename-theme-btn')) this._handleRenameTheme(themeId)
                    if (button.classList.contains('download-theme-btn')) this.downloadSpecificTheme(themeId);
                    if (button.classList.contains('delete-theme-btn')) this._handleDeleteTheme(themeId);
                });
            }

            // ================================================================
            // PUBLIC UI Methods (Called from SoundboardManager)
            // ================================================================

            open() {
                this._updateModalInputs();
                this._renderThemeList();
                this.modal.style.display = 'flex';
            }

            close() {
                this.modal.style.display = 'none';
            }

            // ================================================================
            // INTERNAL UI Handlers and Renderers
            // ================================================================

            _updateModalInputs() {
                const { colors, fontFamily } = this.cosmeticsData;
                this.colorPickers.forEach(input => {
                    const cssVar = input.dataset.cssVar;
                    if (colors[cssVar]) input.value = colors[cssVar];
                });
                this.fontInput.value = fontFamily;
            }

            async _renderThemeList() {
                const template = document.getElementById('theme-list-item-template');
                const themes = await this.getThemeLibrary();

                this.themeList.innerHTML = ''; // Clear the list first
                const themeIds = Object.keys(themes);

                if (themeIds.length === 0) {
                    this.themeList.innerHTML = '<li><small>No saved themes yet.</small></li>';
                    return;
                }

                themeIds.forEach(themeId => {
                    const theme = themes[themeId];
                    // Create a new copy of the template for each theme
                    const clone = template.content.cloneNode(true);

                    // Find the elements inside the cloned template
                    const nameSpan = clone.querySelector('.theme-name');
                    const applyBtn = clone.querySelector('.apply-theme-btn');
                    const renameBtn = clone.querySelector('.rename-theme-btn');
                    const downloadBtn = clone.querySelector('.download-theme-btn');
                    const deleteBtn = clone.querySelector('.delete-theme-btn');

                    // Populate the elements with the correct data
                    nameSpan.textContent = theme.name;
                    applyBtn.dataset.themeId = themeId;
                    renameBtn.dataset.themeId = themeId;
                    downloadBtn.dataset.themeId = themeId;
                    deleteBtn.dataset.themeId = themeId;

                    // Add the finished item to the list
                    this.themeList.appendChild(clone);
                });
            }

            async _handleResetCosmetics() {
                const confirmed = await this.soundboardManager.showConfirmModal('Are you sure you want to reset appearance settings? This cannot be undone.');
                if (confirmed) this.resetCurrentCosmetics();
            }

            async _handleLibraryUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                // The confirmation message is now much clearer
                const confirmed = await this.soundboardManager.showConfirmModal("This will overwrite your entire theme library with the contents of this file. Are you sure?");

                if (confirmed) {
                    const success = await this.uploadThemeLibrary(file);
                    if (success) {
                        // Refresh the list to show the newly uploaded themes
                        await this._renderThemeList();
                    } else {
                        alert("Failed to read file. Please ensure it is a valid theme library JSON file.");
                    }
                }
                event.target.value = ''; // Reset file input
            }

            async _handleThemeUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                // The confirmation message is now much clearer
                const applyNow = await this.soundboardManager.showConfirmModal(`Uploaded Theme: ${file.name}. Apply Now?`);
                const success = await this.uploadTheme(file, applyNow);
                if (success) {
                    // Refresh the list to show the newly uploaded themes
                    await this._renderThemeList();
                } else {
                    alert("Failed to read file. Please ensure it is a valid theme library JSON file.");
                }


            }

            async _handleSaveTheme() {
                const themeName = this.saveThemeNameInput.value.trim();
                if (!themeName) {
                    alert('Please enter a name for your theme.');
                    return;
                }
                await this.saveThemeToLibrary(themeName);
                this.saveThemeNameInput.value = '';
                this._renderThemeList();
            }

            async _handleApplyTheme(themeId) {
                const appliedThemeName = await this.applyThemeFromLibrary(themeId);
                if (appliedThemeName) {
                    this._updateModalInputs();
                }
            }

            async _handleDeleteTheme(themeId) {
                const themes = await this.getThemeLibrary();
                const themeName = themes[themeId]?.name || 'this theme';
                const confirmed = await this.soundboardManager.showConfirmModal(`Delete "${themeName}" from your library?`);
                if (confirmed) {
                    await this.deleteThemeFromLibrary(themeId);
                    this._renderThemeList();
                }
            }

            async _handleRenameTheme(themeId) {
                const themes = await this.getThemeLibrary();
                const currentName = themes[themeId]?.name;
                if (!currentName) return;

                const newName = prompt("Enter a new name for the theme:", currentName);

                if (newName && newName.trim() !== currentName) {
                    const success = await this.renameTheme(themeId, newName.trim());
                    if (success) {
                        // If the rename was successful, re-render the list to show the change
                        await this._renderThemeList();
                    }
                }
            }


            // ================================================================
            // DATA MANAGEMENT Methods (The "Model" part of the class)
            // ================================================================


            /**
             * Loads the cosmetic configuration from the current board's database.
             * If none exists, it creates and saves a default configuration.
             */
            async loadCurrentCosmetics() {
                let data = await this.db.get(ThemeManager.COSMETICS_KEY);
                if (!data) {
                    data = {
                        id: ThemeManager.COSMETICS_KEY,
                        fontFamily: 'Wellfleet',
                        colors: {
                            '--background-color': '#f7fafc',
                            '--panel-color': '#e3f0ff',
                            '--accent-color': '#33a367',
                            '--highlight-color': '#ff914d',
                            '--primary-color': '#234e70',
                            '--secondary-color': '#e7e7e7',
                        },
                        themeName: null
                    };
                    await this.db.save(data.id, data);
                }
                this.cosmeticsData = data;
                this.applyCosmetics();

            }

            /**
             * Applies the current in-memory cosmeticsData to the document's styles.
             */
            applyCosmetics() {
                if (!this.cosmeticsData) return;

                const root = document.documentElement;
                const { colors, fontFamily } = this.cosmeticsData;

                // Apply base colors
                for (const [key, value] of Object.entries(colors)) {
                    root.style.setProperty(key, value);
                }

                // Dynamically set contrasting text colors
                const darkText = colors['--primary-color'];
                const lightText = colors['--secondary-color'];
                const setContrast = (bgVar, textVar) => {
                    const bgColor = colors[bgVar];
                    const luminance = (0.299 * parseInt(bgColor.substr(1, 2), 16) + 0.587 * parseInt(bgColor.substr(3, 2), 16) + 0.114 * parseInt(bgColor.substr(5, 2), 16)) / 255;
                    root.style.setProperty(textVar, luminance > 0.5 ? darkText : lightText);
                };

                setContrast('--panel-color', '--panel-color-text');
                setContrast('--accent-color', '--accent-color-text');
                setContrast('--highlight-color', '--highlight-color-text');
                setContrast('--primary-color', '--primary-color-text');
                setContrast('--background-color', '--background-color-text');
                setContrast('--secondary-color', '--secondary-color-text');

                // Apply font
                loadGoogleFonts([fontFamily]);
                root.style.setProperty('--font-family-primary', `'${fontFamily}', sans-serif`);
            }

            /**
             * Saves the current cosmeticsData to the current board's database.
             */
            async saveCurrentCosmetics() {
                await this.db.save(this.cosmeticsData.id, this.cosmeticsData);
            }

            /**
             * Updates a specific color value, applies it, and saves.
             * @param {string} cssVar - The CSS variable for the color (e.g., '--panel-color').
             * @param {string} value - The new hex color value.
             */
            updateColor(cssVar, value) {
                this.cosmeticsData.colors[cssVar] = value;
                this.cosmeticsData.themeName = null;
                this.applyCosmetics();
                this.debouncedSave();
            }

            /**
             * Updates the font family, applies it, and saves.
             * @param {string} fontFamily - The name of the new font.
             */
            updateFont(fontFamily) {
                this.cosmeticsData.fontFamily = fontFamily.trim();
                this.cosmeticsData.themeName = null;
                this.applyCosmetics();

                this.saveCurrentCosmetics(); // Save immediately for fonts
            }

            /**
             * Resets the current board's appearance to default by deleting its config.
             */
            async resetCurrentCosmetics() {
                await this.db.delete(ThemeManager.COSMETICS_KEY);
                // Reload the page to apply the default settings cleanly.
                window.location.reload();
            }


            // ================================================================
            // Methods for the GLOBAL Theme Library
            // ================================================================

            /*
            * Retrieves the theme library. If no library exists, it creates
            * and saves a default library for the user.
            * @returns {Promise<object>} An object containing all saved themes.
            */
            async getThemeLibrary() {
                let libraryData = await this.defaultDb.get(ThemeManager.THEME_LIBRARY_KEY);

                // If no library exists in the database...
                if (!libraryData) {
                    console.log("No theme library found. Creating default library.");
                    // This is the default theme object you provided.
                    const defaultLibrary = {
                        id: "theme-library",
                        themes: {
                            "default-moss": {
                                name: "Default Moss",
                                fontFamily: "Wellfleet",
                                colors: {
                                    "--background-color": "#f7fafc",
                                    "--panel-color": "#e3f0ff",
                                    "--accent-color": "#33a367",
                                    "--highlight-color": "#ff914d",
                                    "--primary-color": "#234e70",
                                    "--secondary-color": "#e7e7e7"
                                }
                            },
                            "solarized-bug": {
                                name: "Solarized Bug",
                                fontFamily: "Wellfleet",
                                colors: {
                                    "--background-color": "#385b71",
                                    "--panel-color": "#9fc6c6",
                                    "--accent-color": "#4a8c6a",
                                    "--highlight-color": "#ff914d",
                                    "--primary-color": "#1f2e42",
                                    "--secondary-color": "#d0d0a9"
                                }
                            }
                        }
                    };

                    // Save the new default library to the database.
                    await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, defaultLibrary);

                    // Set libraryData to our new default so the rest of the app can use it immediately.
                    libraryData = defaultLibrary;
                }

                return libraryData.themes;
            }

            /**
             * Saves the current board's theme to the global library.
             * @param {string} themeName - The user-provided name for the theme.
             */
            async saveThemeToLibrary(themeName) {
                const themeId = slugify(themeName);
                const allThemes = await this.getThemeLibrary();

                allThemes[themeId] = {
                    name: themeName,
                    fontFamily: this.cosmeticsData.fontFamily,
                    colors: this.cosmeticsData.colors
                };

                await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, {
                    id: ThemeManager.THEME_LIBRARY_KEY,
                    themes: allThemes
                });
            }

            /**
             * Deletes a theme from the global library.
             * @param {string} themeId - The slugified ID of the theme to delete.
             */
            async deleteThemeFromLibrary(themeId) {
                const allThemes = await this.getThemeLibrary();
                if (allThemes[themeId]) {
                    delete allThemes[themeId];
                    await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, {
                        id: ThemeManager.THEME_LIBRARY_KEY,
                        themes: allThemes
                    });
                }
            }

            /**
             * Applies a theme from the library to the current board.
             * @param {string} themeId - The slugified ID of the theme to apply.
             */
            async applyThemeFromLibrary(themeId) {
                const themes = await this.getThemeLibrary();
                const themeToApply = themes[themeId];

                if (!themeToApply) {
                    console.error("Theme not found:", themeId);
                    return;
                }

                // Overwrite the current in-memory theme
                this.cosmeticsData.colors = themeToApply.colors;
                this.cosmeticsData.fontFamily = themeToApply.fontFamily;

                this.applyCosmetics();
                await this.saveCurrentCosmetics(); // Save the newly applied theme to this board

                this.cosmeticsData.themeName = themeToApply.name;
                return themeToApply.name;
            }

            /**
            * Downloads the entire theme library as a single JSON file.
            */
            async downloadThemeLibrary() {
                const themes = await this.getThemeLibrary();
                if (Object.keys(themes).length === 0) {
                    alert("There are no saved themes in your library to download.");
                    return;
                }

                // The data we want to save is the entire 'themes' object.
                const dataToSave = {
                    id: ThemeManager.THEME_LIBRARY_KEY, // Keep the key for validation
                    themes: themes
                };

                const json = JSON.stringify(dataToSave, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ReallySimpleSoundboard Theme Library_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert("Theme library downloaded successfully.");

            }

            /**
             * Reads a JSON file and overwrites the entire theme library with its content.
             * @param {File} file - The file object from the input element.
             * @returns {Promise<boolean>} True if the upload was successful, false otherwise.
             */
            uploadThemeLibrary(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const uploadedData = JSON.parse(e.target.result);

                            // Perform validation to ensure it's a valid library file.
                            if (!uploadedData.id || uploadedData.id !== ThemeManager.THEME_LIBRARY_KEY || typeof uploadedData.themes !== 'object') {
                                throw new Error("Invalid or corrupted theme library file.");
                            }

                            // Overwrite the existing library with the uploaded data.
                            await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, uploadedData);

                            resolve(true); // Indicate success
                        } catch (err) {
                            console.error("Theme library upload error:", err);
                            resolve(false); // Indicate failure
                        }
                    };
                    reader.onerror = () => resolve(false);
                    reader.readAsText(file);
                });
            }

            async downloadCurrentTheme() {
                let themeName = this.cosmeticsData.themeName;

                // If the theme is "dirty" (unnamed), we need to prompt the user.
                if (!themeName) {
                    const timestamp = new Date().toISOString().slice(0, 10); // e.g., "2025-08-23"
                    const suggestedName = `${this.soundboardManager.boardName}_Theme ${timestamp}`;

                    // Use the browser's built-in prompt to ask the user for a name.
                    themeName = prompt("This is an unsaved theme. Please provide a name to save and download it.", suggestedName);

                    // If the user clicks "Cancel" in the prompt, stop the entire process.
                    if (!themeName) {
                        return;
                    }

                    // Since we have a new name, save this theme to the library.
                    await this.saveThemeToLibrary(themeName);

                    // Update our state to remember the name of this newly saved theme.
                    this.cosmeticsData.themeName = themeName;

                    // Refresh the list in the UI so the user can see their new theme.
                    await this._renderThemeList();
                }

                // Now, proceed with the download using the determined theme name.
                const json = JSON.stringify(this.cosmeticsData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Use the "slugify" helper for a clean, web-safe filename.
                a.download = `RSS_Theme_${slugify(themeName)}.json`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // In ThemeManager, DELETE downloadCurrentTheme and ADD this method:
            /**
             * Downloads a specific theme from the library as a JSON file.
             * @param {string} themeId - The slugified ID of the theme to download.
             */
            async downloadSpecificTheme(themeId) {
                const allThemes = await this.getThemeLibrary();
                const themeToDownload = allThemes[themeId];

                if (!themeToDownload) {
                    alert("Could not find the selected theme to download.");
                    return;
                }

                // Create a data structure similar to a standard cosmetics object for consistency
                const dataToSave = {
                    id: ThemeManager.COSMETICS_KEY,
                    fontFamily: themeToDownload.fontFamily,
                    colors: themeToDownload.colors,
                    themeName: themeToDownload.name // Include the name
                };

                const json = JSON.stringify(dataToSave, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `RSS_Theme_${slugify(themeToDownload.name)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            uploadTheme(file, applyNow = true) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const uploadedData = JSON.parse(e.target.result);
                            if (!uploadedData.id || !uploadedData.colors || !uploadedData.fontFamily) {
                                throw new Error("Invalid theme file structure.");
                            }

                            const themeName = uploadedData.themeName || `Imported Theme - ${file.name}`;
                            const themeId = slugify(themeName);
                            const allThemes = await this.getThemeLibrary();

                            
                            // Check if a theme with this ID already exists.
                            if (allThemes[themeId]) {
                                const confirmed = await this.soundboardManager.showConfirmModal(`A theme named "${themeName}" already exists. Do you want to overwrite it?`);
                                if (!confirmed) {
                                    resolve(false); // User canceled, resolve as failure.
                                    return;
                                }
                            }

                            const themeToSave = {
                                name: themeName,
                                fontFamily: uploadedData.fontFamily,
                                colors: uploadedData.colors
                            };

                            // Save the theme to the library.
                            allThemes[themeId] = themeToSave;
                            await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, {
                                id: ThemeManager.THEME_LIBRARY_KEY,
                                themes: allThemes
                            });

                            // Apply if requested.
                            if (applyNow) {
                                this.cosmeticsData = uploadedData;
                                this.cosmeticsData.themeName = themeName;
                                this.applyCosmetics();
                                await this.saveCurrentCosmetics();
                            }

                            resolve(true); // Success
                        } catch (err) {
                            console.error("Theme upload error:", err);
                            resolve(false); // Failure
                        }
                    };
                    reader.onerror = () => resolve(false);
                    reader.readAsText(file);
                });
            }

            /**
             * Renames a theme in the global library.
             * @param {string} oldThemeId - The original, slugified ID of the theme.
             * @param {string} newThemeName - The new, user-provided name for the theme.
             * @returns {Promise<boolean>} True if rename was successful, false otherwise.
             */
            async renameTheme(oldThemeId, newThemeName) {
                const newThemeId = slugify(newThemeName);
                if (!newThemeName || oldThemeId === newThemeId) {
                    return false; // Do nothing if the name is empty or unchanged
                }

                const allThemes = await this.getThemeLibrary();
                if (allThemes[newThemeId]) {
                    alert(`A theme with the name "${newThemeName}" already exists.`);
                    return false;
                }

                if (allThemes[oldThemeId]) {
                    // Copy the data to a new key and then delete the old one
                    allThemes[newThemeId] = { ...allThemes[oldThemeId], name: newThemeName };
                    delete allThemes[oldThemeId];

                    await this.defaultDb.save(ThemeManager.THEME_LIBRARY_KEY, {
                        id: ThemeManager.THEME_LIBRARY_KEY,
                        themes: allThemes
                    });
                    return true;
                }
                return false;
            }
        }
    </script>
    <script name="Class-AudioPlayer">
        // ====================================================================
            // SECTION: Audio Player Class
            // I'm so fucking tired ddude
            // ====================================================================

            class AudioPlayer {
                constructor(audioElement) {
                    this.audio = audioElement || new Audio();
                    this.isPlaying = false;
                    this.duckAmount = 0.4;
                    this.fadeSpeed = 200;
                    this.playback = {
                        currentFileIndex: 0,
                    };
                    this.progressOverlay = null; // A reference to the progress bar element
                    this.card = null; // a reference to the card itself
                    this.setupListeners();
                }

                setupListeners() {
                    this.audio.onplaying = () => {
                        this.isPlaying = true;
                        if (this.card) {
                            this.card.classList.add('hover-glow');
                        }
                    };
                    this.audio.onpause = () => {
                        this.isPlaying = false;
                        this.resetProgress();
                    };
                    this.audio.onended = () => {
                        // This is for local cleanup ONLY
                        this.isPlaying = false;
                        this.resetProgress();
                        this.audio.currentTime = 0; // Rewind the audio element
                    };
                    this.audio.ontimeupdate = () => this.updateProgress();
                }

                updateProgress() {
                    if (this.progressOverlay && this.audio.duration > 0) {
                        const progress = (this.audio.currentTime / this.audio.duration) * 100;
                        this.progressOverlay.style.width = `${progress}%`;
                    }
                }

                resetProgress() {
                    if (this.progressOverlay) {
                        this.progressOverlay.style.width = '0%';
                    }
                    if (this.card) {
                        this.card.classList.remove('hover-glow');
                    }
                }

                // A method to properly clean up the audio object and its URL
                cleanup() {
                    this.audio.pause();
                    if (this.audio.src) {
                        URL.revokeObjectURL(this.audio.src);
                        this.audio.src = '';
                        this.audio.load();
                    }
                    this.isPlaying = false;
                    this.resetProgress();
                }
            }

    </script>
    <script name="Class-BoardManager">
        class BoardManager {
                // A helper to temporarily open a connection to the default DB
                static _getDefaultDB() {
                    const db = new SoundboardDB('default');
                    return db.openDB().then(() => db);
                }

                // Gets the list of board IDs from the default DB
                static async getBoardList() {
                    const defaultDB = await this._getDefaultDB();
                    const listData = await defaultDB.get('board-list');
                    return listData ? listData.ids : [];
                }

                // Adds a new board ID to the list in the default DB
                static async addBoardId(boardId) {
                    const defaultDB = await this._getDefaultDB();
                    const boardIds = await this.getBoardList();
                    if (!boardIds.includes(boardId)) {
                        boardIds.push(boardId);
                        await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                    }
                }

                static async saveBoardList(boardIds) {
                    const defaultDB = await this._getDefaultDB();
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }

                static async removeBoardId(boardIdToRemove) {
                    const defaultDB = await this._getDefaultDB();
                    let boardIds = await this.getBoardList();
                    // Filter the list to exclude the board we're removing
                    boardIds = boardIds.filter(id => id !== boardIdToRemove);
                    // Save the new, shorter list back to the database
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }
            }

    </script>
    <script name="Class-SoundboardDB">
            // ====================================================================
            // Soundboard Database Manager Class
            // ====================================================================

            class SoundboardDB {
                constructor(boardIdOverride = null) {
                    let boardId;
                    // If a boardId is explicitly passed, use it. Otherwise, get it from the URL.
                    if (boardIdOverride) {
                        boardId = boardIdOverride;
                    } else {
                        const urlParams = new URLSearchParams(window.location.search);
                        boardId = urlParams.get('board') || 'default';

                        // We'll move the "guest book" logic to be called after the constructor.
                    }

                    this.DB_NAME = `BugAndMossSoundboardDB_${boardId}`;
                    this.DB_VERSION = 9; // Increment version for this structural change idea
                    this.SOUNDS_STORE = 'sounds';
                    this.CONFIG_STORE = 'config';
                    this.CONFIG_KEY = 'global-config';
                    this.COSMETICS_KEY = 'cosmetics-config';
                    this.db = null;
                }
                async openDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                        request.onupgradeneeded = event => {
                            this.db = event.target.result;
                            if (!this.db.objectStoreNames.contains(this.SOUNDS_STORE)) {
                                this.db.createObjectStore(this.SOUNDS_STORE, {
                                    keyPath: 'id'
                                });
                            }
                            if (!this.db.objectStoreNames.contains(this.CONFIG_STORE)) {
                                this.db.createObjectStore(this.CONFIG_STORE, {
                                    keyPath: 'id'
                                });
                            }
                        };
                        request.onsuccess = event => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };
                        request.onerror = event => reject(event.target.error);
                    });
                }

                _dbRequest(storeName, mode, action, data) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) {
                            reject("Database not initialized.");
                            return;
                        }
                        const transaction = this.db.transaction(storeName, mode);
                        const store = transaction.objectStore(storeName);
                        let request;
                        if (data !== undefined) {
                            request = store[action](data);
                        } else {
                            request = store[action]();
                        }
                        transaction.oncomplete = () => resolve(request.result);
                        transaction.onerror = () => reject(transaction.error);
                    });
                }

                async save(id, data) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    const saveData = { id, ...(data.id !== undefined ? data : { ...data, id }) };
                    return this._dbRequest(storeName, 'readwrite', 'put', saveData);
                }


                async get(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readonly', 'get', id);
                }

                async getAll() {
                    const soundData = await this._dbRequest(this.SOUNDS_STORE, 'readonly', 'getAll');
                    const configData = await this._dbRequest(this.CONFIG_STORE, 'readonly', 'getAll');
                    return [...soundData, ...configData];
                }

                async delete(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readwrite', 'delete', id);
                }

                async clear() {
                    await this._dbRequest(this.SOUNDS_STORE, 'readwrite', 'clear');
                    await this._dbRequest(this.CONFIG_STORE, 'readwrite', 'clear');
                }
            }
    </script>
    <script name="Class-NotepadCard">
        class NotepadCard {
                constructor(element, soundboardManager, dbInstance) {
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.cardId);

                    // DOM Elements
                    this.contentElement = this.cardElement.querySelector('.notepad-content');
                    this.tabsContainer = this.cardElement.querySelector('.notepad-tabs');
                    this.addPageButton = this.cardElement.querySelector('.add-page-btn');

                    // state
                    this.pages = [{ title: 'New Note', content: '' }];
                    this.currentPageIndex = 0;
                    this.height = null;

                    this.attachListeners();
                    this.loadState();
                }

                attachListeners() {
                    this.contentElement.addEventListener('input', () => {
                        this.pages[this.currentPageIndex].content = this.contentElement.value;
                        this.saveState();
                    });

                    this.contentElement.addEventListener('mouseup', () => {
                        // Only save if a height style was actually set by resizing
                        if (this.contentElement.style.height) {
                            this.height = this.contentElement.style.height;
                            this.saveState();
                        }
                    });

                    this.addPageButton.addEventListener('click', () => this.addPage());



                    this.tabsContainer.addEventListener('click', (e) => {
                        // First, handle the delete button action
                        if (e.target.classList.contains('delete-page-btn')) {
                            const tab = e.target.closest('.notepad-tab');
                            if (tab) {
                                this.deletePage(parseInt(tab.dataset.pageIndex));
                            }
                            return; // Stop processing
                        }

                        // Now, handle the page switch action
                        const tabToSwitchTo = e.target.closest('.notepad-tab');
                        if (tabToSwitchTo) {
                            const targetIndex = parseInt(tabToSwitchTo.dataset.pageIndex);

                            // Only switch pages if the clicked tab is not already the active one.
                            if (targetIndex !== this.currentPageIndex) {
                                this.switchPage(targetIndex);
                            }
                            // If it IS the active tab, we do nothing, which lets you click to edit the title.
                        }
                    });

                    this.tabsContainer.addEventListener('input', (e) => {
                        if (e.target.classList.contains('notepad-tab-title')) {
                            const tab = e.target.closest('.notepad-tab');
                            const pageIndex = parseInt(tab.dataset.pageIndex);
                            this.pages[pageIndex].title = e.target.textContent;
                            this.saveState();
                        }
                    });
                }

                async loadState() {
                    const state = await this.db.get(`notepad-${this.id}`);
                    if (state) {
                        this.pages = state.pages.map(p => ({ title: 'Note', content: '', ...p }));
                        this.currentPageIndex = state.currentPageIndex;
                        this.height = state.height || null; // UPDATED: Load the card's height
                    }
                    this.render();
                }

                async saveState() {
                    const state = {
                        pages: this.pages,
                        currentPageIndex: this.currentPageIndex,
                        height: this.height // UPDATED: Save the card's height
                    };
                    await this.db.save(`notepad-${this.id}`, state);
                }

                addPage() {
                    this.pages.push({ title: 'New Note', content: '' });
                    this.currentPageIndex = this.pages.length - 1;
                    this.render();
                    this.saveState();
                }



                async deletePage(index) {
                    // If there is more than one page, just delete the page
                    if (this.pages.length > 1) {
                        const confirm = await this.soundboardManager.showConfirmModal('Are you sure you want to delete this page?');
                        if (!confirm) return;

                        this.pages.splice(index, 1);
                        if (this.currentPageIndex >= index) {
                            this.currentPageIndex = Math.max(0, this.currentPageIndex - 1);
                        }
                        this.render();
                        this.saveState();
                    } else {
                        // If it's the last page, delete the entire note card
                        this.soundboardManager.removeNotepad(this.id);
                    }
                }

                switchPage(index) {
                    if (index >= 0 && index < this.pages.length) {
                        this.currentPageIndex = index;
                        this.render();
                        this.saveState();
                    }
                }

                render() {
                    const currentPage = this.pages[this.currentPageIndex];
                    this.contentElement.value = currentPage.content;

                    if (this.height) {
                        this.contentElement.style.height = this.height;
                    } else {
                        this.contentElement.style.height = '';
                    }

                    this.tabsContainer.querySelectorAll('.notepad-tab').forEach(tab => tab.remove());

                    this.pages.forEach((page, index) => {
                        const tab = document.createElement('div');
                        tab.className = 'notepad-tab';
                        tab.dataset.pageIndex = index;

                        const tabTitle = document.createElement('span');
                        tabTitle.className = 'notepad-tab-title';
                        tabTitle.textContent = page.title;

                        // UPDATED: Explicitly use strings for contentEditable for better compatibility
                        tabTitle.contentEditable = (index === this.currentPageIndex) ? 'true' : 'false';

                        const deleteBtn = document.createElement('span');
                        deleteBtn.className = 'delete-page-btn';
                        deleteBtn.textContent = 'X';


                        tab.appendChild(deleteBtn);
                        tab.appendChild(tabTitle);

                        if (index === this.currentPageIndex) {
                            tab.classList.add('active');
                        }
                        this.tabsContainer.insertBefore(tab, this.addPageButton);
                    });
                }
            }

    </script>
    <script name="Class-TimerCard">
         class TimerCard {
                constructor(element, soundboardManager, dbInstance) {
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.cardId);

                    // --- DOM Element References ---
                    // TITLE AND DISPLAY
                    this.timerTitle = this.cardElement.querySelector('.timer-title');
                    this.timerDisplayContainer = this.cardElement.querySelector('.timer-display');
                    this.timerDisplay = this.timerDisplayContainer.querySelector('span');
                    this.timerProgressOverlay = this.cardElement.querySelector('.timer-progress-overlay');

                    // BUTTONS
                    this.startPauseBtn = this.cardElement.querySelector('.start-pause-timer-btn');
                    this.resetBtn = this.cardElement.querySelector('.reset-timer-btn');

                    // SLIDERS & THEIR LABELS
                    this.timerMinutesRange = this.cardElement.querySelector('.timer-minutes-range');
                    this.timerMinutesValue = this.cardElement.querySelector('.timer-minutes-value');
                    this.timerSecondsRange = this.cardElement.querySelector('.timer-seconds-range');
                    this.timerSecondsValue = this.cardElement.querySelector('.timer-seconds-value');

                    // TIMER OPTIONS SECTION
                    this.hideOptionsToggle = this.cardElement.querySelector('.hide-timer-options-toggle');
                    this.optionsContainers = this.cardElement.querySelectorAll('.timer-options-container');

                    this.modeRadios = this.cardElement.querySelectorAll('.timer-mode-radio');
                    this.modeRadios.forEach(radio => {
                        radio.name = `timer-mode-${this.id}`;
                    });
                    this.loopCheckbox = this.cardElement.querySelector('.timer-loop-checkbox');
                    this.startSoundLabel = this.cardElement.querySelector('.start-sound-label');
                    this.timerStartSoundSelect = this.cardElement.querySelector('.timer-start-sound');
                    this.endSoundContainer = this.cardElement.querySelector('.end-sound-container');
                    this.timerEndSoundSelect = this.cardElement.querySelector('.timer-end-sound');

                    this.removeTimerBtn = this.cardElement.querySelector('.remove-timer-btn');

                    // --- State Properties ---
                    this.state = {
                        title: 'New Timer',
                        mode: 'timer', // 'timer' or 'stopwatch'
                        isLooping: false,
                        isRunning: false,
                        optionsHidden: false,
                        targetDurationMs: 30000, // Default to 30s
                        startTime: null, // Timestamp when the timer was started/resumed
                        pauseTime: null, // Timestamp when the timer was paused
                        elapsedMs: 0,    // Total elapsed time when paused
                        startSoundId: '',
                        endSoundId: '',
                        endSoundDuration: 0,
                        endSoundFileIndex: null, // <-- ADD THIS LINE
                        hasPlayedEndSound: false,
                    };
                    this.animationFrameId = null;
                    this.debouncedSave = debounce(() => this.saveState(), 300);
                }

                async init() {
                    await this.loadState();
                    this.attachListeners();
                    this.updateUI();
                    this.renderDisplay();
                }

                attachListeners() {
                    this.startPauseBtn.addEventListener('click', () => this.handlePlayPause());
                    this.resetBtn.addEventListener('click', () => this.reset());
                    this.removeTimerBtn.addEventListener('click', () => this.soundboardManager.removeTimer(this.id));

                    // Listeners that change state and require a save
                    const controlsToListen = [
                        this.timerMinutesRange, this.timerSecondsRange, this.hideOptionsToggle,
                        this.loopCheckbox, this.timerStartSoundSelect, this.timerEndSoundSelect
                    ];
                    controlsToListen.forEach(el => el.addEventListener('input', () => this.handleControlChange()));
                    controlsToListen.forEach(el => el.addEventListener('change', () => this.handleControlChange()));
                    this.modeRadios.forEach(radio => radio.addEventListener('change', () => this.handleControlChange()));
                    // Handle the title separately to keep the saving from being every keystroke
                    this.timerTitle.addEventListener('blur', () => {
                        this.state.title = this.timerTitle.textContent;
                        this.saveState();
                    });

                    // text editable minutes/seconds
                    this.timerMinutesValue.addEventListener('blur', (e) => this.handleManualTimeInput(e));
                    this.timerSecondsValue.addEventListener('blur', (e) => this.handleManualTimeInput(e));




                }



                destroy() {
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                    }
                }

                // ================================================================
                // State Management
                // ================================================================

                async saveState() {
                    // If running, calculate current elapsed time before saving
                    if (this.state.isRunning) {
                        this.state.elapsedMs += Date.now() - this.state.startTime;
                        this.state.startTime = Date.now();
                    }
                    await this.db.save(`timer-${this.id}`, this.state);
                }

                async loadState() {
                    const savedState = await this.db.get(`timer-${this.id}`);
                    if (savedState) {
                        // Merge saved state with defaults
                        this.state = { ...this.state, ...savedState };

                        // If the timer was running when the page was closed, calculate the time that has passed since.
                        if (this.state.isRunning && this.state.startTime) {
                            const timePassedSinceSave = Date.now() - this.state.startTime;
                            this.state.elapsedMs += timePassedSinceSave;
                            this.startTimer();
                        } else {
                            this.state.isRunning = false; // Ensure it's not running if it wasn't saved as such
                        }
                    }
                    // Ensure dropdowns have a valid value, defaulting to "" (None)
                    this.state.startSoundId = this.state.startSoundId || "";
                    this.state.endSoundId = this.state.endSoundId || "";
                }

                // ================================================================
                // Event Handlers
                // ================================================================

                startTimer() {
                    if (!this.state.isLooping) {
                        this.prepareEndSound();
                    }
                    this.state.startTime = Date.now();
                    if (this.state.elapsedMs === 0) { // ONLY play sound on fresh start not every click.
                        this.playStartSound();
                    }
                    this.tick();
                }

                handlePlayPause() {

                    const isFinished = this.state.mode === 'timer' && this.state.elapsedMs >= this.state.targetDurationMs;

                    if (!this.state.isRunning && isFinished) {
                        this.reset();
                    }

                    this.state.isRunning = !this.state.isRunning; // TOGGLE THE RUNNING STATE

                    if (this.state.isRunning) { // REMEMBER WE JUST TOGGLED THE RUNNING STATE
                        this.startTimer();
                    } else {
                        // --- PAUSING ---
                        this.state.elapsedMs += Date.now() - this.state.startTime;
                        cancelAnimationFrame(this.animationFrameId);
                    }
                    this.updateUI();
                    this.saveState();
                }

                reset() {
                    this.state.isRunning = false;
                    this.state.elapsedMs = 0;
                    this.state.hasPlayedEndSound = false;
                    this.state.endSoundDuration = 0;

                    this.updateUI();
                    this.renderDisplay();
                    this.saveState();
                }

                handleControlChange() {
                    // Sync state object with UI controls
                    this.state.title = this.timerTitle.textContent;
                    this.state.targetDurationMs = (parseInt(this.timerMinutesRange.value, 10) * 60 + parseInt(this.timerSecondsRange.value, 10)) * 1000;
                    this.state.optionsHidden = this.hideOptionsToggle.checked;
                    this.state.isLooping = this.loopCheckbox.checked;
                    this.state.mode = this.cardElement.querySelector('.timer-mode-radio:checked').value;
                    this.state.startSoundId = this.timerStartSoundSelect.value;
                    this.state.endSoundId = this.timerEndSoundSelect.value;

                    // Check if the timer is not running before resetting it
                    if (!this.state.isRunning) {
                        this.reset();
                    }

                    this.updateUI();

                    // Only prepare the end sound if the timer is not running or in loop mode
                    if (!this.state.isRunning && !this.state.isLooping) {
                        this.prepareEndSound();
                    }

                    this.debouncedSave();
                }

                handleManualTimeInput(e) {
                    const value = parseInt(e.target.value, 10);
                    const type = e.target.dataset.type;

                    if (type === 'minutes') {
                        // Validate minutes to be within a reasonable range (e.g., 0-90)
                        let validatedValue = isNaN(value) ? 0 : Math.max(0, Math.min(value, 90));
                        this.timerMinutesRange.value = validatedValue;
                        this.state.targetDurationMs = (validatedValue * 60 + parseInt(this.timerSecondsRange.value, 10)) * 1000;
                    } else if (type === 'seconds') {
                        // Validate seconds to be between 0-59
                        let validatedValue = isNaN(value) ? 0 : Math.max(0, Math.min(value, 59));
                        this.timerSecondsRange.value = validatedValue;
                        this.state.targetDurationMs = (parseInt(this.timerMinutesRange.value, 10) * 60 + validatedValue) * 1000;
                    }

                    this.updateUI();
                    // Re-render the display to show the formatted value (e.g., single digit to double)
                    this.renderDisplay();

                    // Call the debounced save to persist the change
                    this.debouncedSave();
                }

                handleButtonDeletion(deletedIndex) {
                    let stateChanged = false;
                    const startId = parseInt(this.state.startSoundId, 10);
                    const endId = parseInt(this.state.endSoundId, 10);

                    // Handle Start Sound ID
                    if (!isNaN(startId)) {
                        if (startId === deletedIndex) {
                            this.state.startSoundId = ""; // The selected button was deleted, reset to "None"
                            stateChanged = true;
                        } else if (startId > deletedIndex) {
                            this.state.startSoundId = (startId - 1).toString(); // A button before it was deleted, so shift the index down
                            stateChanged = true;
                        }
                    }

                    // Handle End Sound ID
                    if (!isNaN(endId)) {
                        if (endId === deletedIndex) {
                            this.state.endSoundId = ""; // The selected button was deleted, reset to "None"
                            stateChanged = true;
                        } else if (endId > deletedIndex) {
                            this.state.endSoundId = (endId - 1).toString(); // A button before it was deleted, so shift the index down
                            stateChanged = true;
                        }
                    }

                    if (stateChanged) {
                        this.saveState();
                    }
                }

                // ================================================================
                // Core Timer Logic & Rendering
                // ================================================================

                tick() {
                    if (!this.state.isRunning) return;

                    const currentElapsed = this.state.elapsedMs + (Date.now() - this.state.startTime);

                    if (this.state.mode === 'timer') {
                        const remainingMs = this.state.targetDurationMs - currentElapsed;

                        // Check for end sound trigger
                        if (!this.state.isLooping && this.state.endSoundId && !this.state.hasPlayedEndSound && remainingMs <= this.state.endSoundDuration) {
                            this.playEndSound();
                        }

                        // Check for timer completion
                        if (remainingMs <= 0) {
                            if (this.state.isLooping) {
                                this.state.elapsedMs = 0;
                                this.state.startTime = Date.now()
                                this.playStartSound();
                                // There is no "end sound" when looping and we just use the start sound like it's the only sound
                            } else {
                                this.state.isRunning = false;
                                this.state.elapsedMs = this.state.targetDurationMs; // Clamp to the end
                                this.updateUI();
                                this.renderDisplay();
                                this.saveState();
                                return; // Stop the loop
                            }
                        }
                    } else { // Stopwatch mode
                        // Check for end sound trigger
                        if (!this.state.isLooping && this.state.endSoundId && !this.state.hasPlayedEndSound && this.state.targetDurationMs > 0) {
                            const triggerTime = this.state.targetDurationMs - this.state.endSoundDuration;
                            if (currentElapsed >= triggerTime) {
                                this.playEndSound();
                            }
                        }
                    }

                    this.renderDisplay(currentElapsed);
                    this.animationFrameId = requestAnimationFrame(() => this.tick());
                }

                updateUI() {
                    // Sync UI controls with the state object
                    this.timerTitle.textContent = this.state.title;
                    this.timerMinutesRange.value = Math.floor(this.state.targetDurationMs / 60000);
                    this.timerSecondsRange.value = Math.floor((this.state.targetDurationMs % 60000) / 1000);

                    this.timerMinutesValue.value = this.timerMinutesRange.value;

                    this.timerSecondsValue.value = this.timerSecondsRange.value;

                    this.hideOptionsToggle.checked = this.state.optionsHidden;
                    this.loopCheckbox.checked = this.state.isLooping;
                    this.cardElement.querySelector(`.timer-mode-radio[value="${this.state.mode}"]`).checked = true;
                    this.timerStartSoundSelect.value = this.state.startSoundId;
                    this.timerEndSoundSelect.value = this.state.endSoundId;

                    // Update dynamic UI elements
                    this.startPauseBtn.textContent = this.state.isRunning ? 'Pause' : 'Start';
                    this.startPauseBtn.style.backgroundColor = this.state.isRunning ? 'var(--primary-color)' : 'var(--accent-color)'
                    this.startPauseBtn.style.color = this.state.isRunning ? 'var(--primary-color-text)' : 'var(--accent-color-text)'
                    this.optionsContainers.forEach(c => c.classList.toggle('hidden-options', this.state.optionsHidden));
                    this.timerTitle.contentEditable = !this.state.optionsHidden;
                    this.endSoundContainer.style.display = this.state.isLooping ? 'none' : '';
                    this.startSoundLabel.textContent = this.state.isLooping ? 'Play Sound:' : 'Start with:';


                }

                renderDisplay(currentElapsed = this.state.elapsedMs) {
                    let msToDisplay;
                    if (this.state.mode === 'timer') {
                        msToDisplay = Math.max(0, this.state.targetDurationMs - currentElapsed);
                    } else { // stopwatch
                        msToDisplay = currentElapsed;
                    }

                    // Round UP seconds because this is a soundboard for live broadcast, so it's important to USE the entire last second - displaying 1 rather than 0 helps with that.
                    const totalSeconds = Math.ceil(msToDisplay / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    this.timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                    if (this.state.mode === 'timer' && msToDisplay > 0 && msToDisplay < 3000) {
                        const progress = 100 - (msToDisplay / 3000) * 100;
                        this.timerProgressOverlay.style.width = `${progress}%`;
                    } else {
                        this.timerProgressOverlay.style.width = '0%';
                    }

                    // Apply glow effect for finished states
                    const isStopwatchFinished = this.state.mode === 'stopwatch' && currentElapsed >= this.state.targetDurationMs && this.state.targetDurationMs > 0;
                    const isTimerFinished = this.state.mode === 'timer' && (this.state.targetDurationMs - currentElapsed) <= 0;
                    const shouldGlow = isStopwatchFinished || (isTimerFinished && !this.state.isLooping);

                    this.cardElement.classList.toggle('hover-glow', shouldGlow);
                    this.timerDisplay.classList.toggle('finished', shouldGlow);


                }

                updateTimerSoundSelectors(sounds) {
                    // Clear the existing options
                    this.timerStartSoundSelect.innerHTML = '<option value="">None</option>';
                    this.timerEndSoundSelect.innerHTML = '<option value="">None</option>';

                    if (!sounds) return;

                    // Populate the dropdowns with all available sounds
                    sounds.forEach((sound) => {
                        // We'll use the button's unique ID for the value
                        if (sound.name !== "Default Name") {
                            const optionStart = new Option(sound.name, sound.id);
                            const optionEnd = new Option(sound.name, sound.id);
                            this.timerStartSoundSelect.add(optionStart);
                            this.timerEndSoundSelect.add(optionEnd);
                        }
                    });

                    // **THE FIX**: After populating, set the select element's value
                    // directly from our loaded state. this.state is the source of truth.
                    this.timerStartSoundSelect.value = this.state.startSoundId;
                    this.timerEndSoundSelect.value = this.state.endSoundId;
                }

                validateSoundSelections(existingSoundIds) {
                    let stateChanged = false;
                    const startId = parseInt(this.state.startSoundId, 10);
                    const endId = parseInt(this.state.endSoundId, 10);

                    // Check if the selected start sound ID is still valid
                    if (this.state.startSoundId && !existingSoundIds.includes(startId)) {
                        this.state.startSoundId = ""; // Reset to "None"
                        stateChanged = true;
                    }

                    // Check if the selected end sound ID is still valid
                    if (this.state.endSoundId && !existingSoundIds.includes(endId)) {
                        this.state.endSoundId = ""; // Reset to "None"
                        stateChanged = true;
                    }

                    // If we made a change, save the state. The next render will pick this up.
                    if (stateChanged) {
                        this.saveState();
                    }
                }

                // ================================================================
                // Sound Logic
                // ================================================================

                playStartSound() {
                    if (this.state.startSoundId !== "") {
                        this.soundboardManager.togglePlay(parseInt(this.state.startSoundId, 10));
                    }
                }

                playEndSound() {
                    if (this.state.endSoundId !== "" && this.state.endSoundFileIndex !== null && !this.state.hasPlayedEndSound) {
                        const buttonId = parseInt(this.state.endSoundId, 10);
                        const buttonData = this.soundboardManager.buttonsData.find(b => b.id === buttonId);

                        // Directly play the pre-selected file, bypassing togglePlay's own shuffle logic
                        this.soundboardManager.playFile(buttonId, this.state.endSoundFileIndex, buttonData.priority);

                        this.state.hasPlayedEndSound = true; // Prevent re-triggering
                    }
                }
                async prepareEndSound() {
                    this.state.hasPlayedEndSound = false;
                    this.state.endSoundFileIndex = null; // Reset the chosen file index

                    if (this.state.endSoundId === "") {
                        this.state.endSoundDuration = 0;
                        return;
                    }

                    const buttonId = parseInt(this.state.endSoundId, 10);
                    const buttonData = this.soundboardManager.buttonsData.find(b => b.id === buttonId);

                    if (buttonData && buttonData.files.length > 0) {
                        let fileIndexToPlay;
                        const player = this.soundboardManager._getAudioPlayer(buttonId);

                        if (buttonData.shuffle) {
                            // Pre-determine the random file to play
                            fileIndexToPlay = randomButNot(0, buttonData.files.length, player.playback.currentFileIndex);
                        } else {
                            // Use the next file in sequence
                            fileIndexToPlay = player.playback.currentFileIndex >= buttonData.files.length ? 0 : player.playback.currentFileIndex;
                        }

                        this.state.endSoundFileIndex = fileIndexToPlay; // Store our choice
                        const file = buttonData.files[fileIndexToPlay];
                        const playbackRate = buttonData.playbackRate || 1.0;

                        try {
                            const duration = await this.getAudioDuration(file.arrayBuffer);
                            this.state.endSoundDuration = (duration / playbackRate) * 1000; // Convert to ms
                        } catch (err) {
                            console.error("Could not get audio duration for timer:", err);
                            this.state.endSoundDuration = 0;
                        }
                    }
                }

                getAudioDuration(arrayBuffer) {
                    return new Promise((resolve, reject) => {
                        const blob = new Blob([arrayBuffer]);
                        const audio = new Audio();
                        const objectURL = URL.createObjectURL(blob);
                        audio.addEventListener('loadedmetadata', () => {
                            URL.revokeObjectURL(objectURL);
                            resolve(audio.duration);
                        }, { once: true });
                        audio.addEventListener('error', () => {
                            URL.revokeObjectURL(objectURL);
                            reject(new Error('Failed to load audio for duration calculation.'));
                        }, { once: true });
                        audio.src = objectURL;
                    });
                }
            }

    </script>
    <script name="helper-functions">

        function formatIdAsTitle(id) {
            if (!id) return '';
            return id
                .replace(/-/g, ' ') // my-gaming-sounds -> my gaming sounds
                .split(' ')          // -> ['my', 'gaming', 'sounds']
                .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // -> ['My', 'Gaming', 'Sounds']
                .join(' ');          // -> "My Gaming Sounds"
        }

        function debounce(func, delay) {
            let timeoutId;
            return function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        function slugify(text) {
            return text.toString().toLowerCase().trim()
                .replace(/\s+/g, '-')           // Replace spaces with -
                .replace(/[^\w\-]+/g, '')       // Remove all non-word chars except -
                .replace(/\-\-+/g, '-');          // Replace multiple - with single -
        }

        function loadGoogleFonts(fontNames) {
            if (!fontNames || fontNames.length === 0) {
                console.warn("No font names provided to loadGoogleFonts.");
                return;
            }

            const FONT_STYLESHEET_ID = 'google-fonts-stylesheet';

            // Check for and remove the old font link, if it exists
            const oldLink = document.getElementById(FONT_STYLESHEET_ID);
            if (oldLink) {
                oldLink.remove();
            }

            // Create and add the new font link
            const formattedNames = fontNames.map(name => name.replace(/\s+/g, '+'));
            const fontUrl = `https://fonts.googleapis.com/css?family=${formattedNames.join('|')}&display=swap`;
            const link = document.createElement('link');
            link.id = FONT_STYLESHEET_ID; // Give the new link a consistent ID
            link.href = fontUrl;
            link.rel = 'stylesheet';
            document.head.appendChild(link);
        };


        function getAdvancedContrastColor(bgHex) {
            // Helper function to convert Hex to RGB
            const hexToRgb = (hex) => {
                let r = 0, g = 0, b = 0;
                // 3 digits
                if (hex.length == 4) {
                    r = "0x" + hex[1] + hex[1];
                    g = "0x" + hex[2] + hex[2];
                    b = "0x" + hex[3] + hex[3];
                    // 6 digits
                } else if (hex.length == 7) {
                    r = "0x" + hex[1] + hex[2];
                    g = "0x" + hex[3] + hex[4];
                    b = "0x" + hex[5] + hex[6];
                }
                return [parseInt(r), parseInt(g), parseInt(b)];
            };

            // Helper function to convert RGB to HSL
            const rgbToHsl = (r, g, b) => {
                r /= 255; g /= 255; b /= 255;
                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max == min) {
                    h = s = 0; // achromatic
                } else {
                    let d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            };

            // Helper function to convert HSL to RGB
            const hslToRgb = (h, s, l) => {
                let r, g, b;
                if (s == 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    let p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            };

            // Helper function to convert an RGB component to a 2-digit hex string
            const componentToHex = (c) => {
                const hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            };

            // 1. Get RGB values from the hex color
            const [r, g, b] = hexToRgb(bgHex);

            // 2. Calculate luminance to determine if the color is light or dark
            // This is the same reliable formula from your original function.
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // 3. Convert the background color to HSL for easier manipulation
            let [h, s, l] = rgbToHsl(r, g, b);

            // 4. The "Magic": Adjust the color
            if (luminance > 0.5) { // If the background is light...
                // ...we want a dark text color.
                l = Math.max(0, l - 0.4); // Drastically reduce lightness
                s = Math.max(0, s - 0.5); // Desaturate to avoid weird dark colors
            } else { // If the background is dark...
                // ...we want a light text color.
                l = Math.min(1, l + 0.6); // Drastically increase lightness
                s = Math.max(0, s - 0.4); // Desaturate slightly to avoid overly vibrant light text
            }

            // 5. Convert the new HSL color back to RGB
            const [finalR, finalG, finalB] = hslToRgb(h, s, l);

            // 6. Convert the final RGB back to a hex string and return it
            return `#${componentToHex(finalR)}${componentToHex(finalG)}${componentToHex(finalB)}`;
        }

        function getContrastColor(hexColor) {
            // 1. Remove '#' and convert hex to R, G, B numbers
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            // 2. Calculate the luminance using the standard formula
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // 3. Return dark or light color based on a threshold
            return luminance > 0.45 ? 'var(--primary-color)' : 'var(--secondary-color)'; // Returns dark for light backgrounds, and vice-versa
        }

        function getRandom(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            let value = Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
            return value // The maximum is exclusive and the minimum is inclusive
        }

        function randomButNot(min, max, notThis) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);

            // If the range of possible numbers is 1 or less,
            // we might get an infinite loop.
            if (maxFloored - minCeiled <= 1) {
                // If the only possible value is the one we're trying to avoid,
                // we have no choice but to return it (or a default).
                if (minCeiled === notThis) {
                    // This scenario should be handled based on desired behavior.
                    // Returning `notThis` is one option, returning null is another.
                    return notThis;
                }
                return minCeiled;
            }

            let value;
            do {
                value = getRandom(min, max);
            } while (value === notThis);
            return value;
        }

    </script>
    <script name="Class-SoundboardManager">
        // ====================================================================
        // SECTION: Application Manager Class
        // Manages the state and business logic of the soundboard.
        // UI interactions trigger methods on this manager.
        // ====================================================================
        class SoundboardManager {
                constructor(dbInstance) {
                    this.db = dbInstance;
                    this.soundboardGrid = document.getElementById('soundboard-grid');
                    this.controlCardElement = document.getElementById('control-card');
                    this.buttonsData = [];
                    this.players = new Map();
                    this.timerCards = [];
                    this.notepadCards = [];

                    this.gridLayout = [];
                    this.GRID_LAYOUT_KEY = 'grid-layout';
                    this.activeModalIndex = null;
                    this.isRearranging = false;
                    this.draggedItem = null;

                    this.themeManager = new ThemeManager(this.db, new SoundboardDB('default'), this);

                }

                // ================================================================
                // Core Manager Methods
                // ================================================================

                async _loadBoardData() {
                    await this.loadTitle();
                    await this.themeManager.init();
                    await this.loadStateFromDB(); // Loads sound buttons
                    await this.loadTimers();
                    await this.loadNotepads();
                    await this.initBugMovement();
                    await this.loadLayout();

                }

                async initialize() {
                    loadGoogleFonts(['Wellfleet']);
                    await this.db.openDB();

                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';
                    await BoardManager.addBoardId(boardId);

                    await this._loadBoardData();
                    this.attachGlobalEventListeners();
                    this.renderGrid();
                }

                async createNewBoard() {
                    const input = document.getElementById('new-board-name-input');
                    const boardName = input.value.trim();

                    if (!boardName) {
                        alert("Please enter a name for the new board.");
                        return;
                    }

                    const boardId = slugify(boardName);
                    if (!boardId) {
                        alert("Please enter a valid name (letters and numbers).");
                        return;
                    }

                    const existingBoardIds = await BoardManager.getBoardList(); // UPDATED
                    if (existingBoardIds.includes(boardId)) {
                        alert(`A board with the ID "${boardId}" already exists.`);
                        return;
                    }

                    window.location.href = `?board=${boardId}`;
                }

                async loadTitle() {
                    const titleData = await this.db.get('soundboard-title');

                    if (titleData && titleData.title) {
                        // If a title is already saved in the database, use it.
                        document.getElementById('soundboard-title').textContent = titleData.title;
                    } else {
                        // NEW: If no title is saved, get the board ID from the URL
                        // and use that as the default title.
                        const urlParams = new URLSearchParams(window.location.search);
                        const boardId = formatIdAsTitle(urlParams.get('board')) || 'The Bug & Moss "Really Simple" Soundboard';
                        document.getElementById('soundboard-title').textContent = boardId;
                        document.title = boardId + " | B&M RSS";
                    }
                }

                // REFACTOR: New method to load the grid layout from DB or create a default.
                async loadLayout() {
                    const layoutData = await this.db.get(this.GRID_LAYOUT_KEY);
                    if (layoutData && Array.isArray(layoutData.layout)) {
                        this.gridLayout = layoutData.layout;
                    } else {
                        this._generateDefaultLayout();
                        await this._saveLayout();
                    }
                }

                // REFACTOR: New method to save the current grid layout to DB.
                async _saveLayout() {
                    await this.db.save(this.GRID_LAYOUT_KEY, { id: this.GRID_LAYOUT_KEY, layout: this.gridLayout });
                }

                // REFACTOR: New method to create a default layout if none exists.
                _generateDefaultLayout() {
                    this.gridLayout = [
                        { type: 'sound', id: 0 },
                        { type: 'sound', id: 1 },
                        { type: 'sound', id: 2 },
                        { type: 'sound', id: 3 },
                        { type: 'timer', id: 0 },
                        { type: 'control', id: 'control-card' }
                    ];
                }

                async loadNotepads() {
                    const notepadCountData = await this.db.get('notepadCount');
                    const numNotepads = notepadCountData ? notepadCountData.count : 0;
                    const notepadTemplate = document.getElementById('notepad-card-template');

                    for (let i = 0; i < numNotepads; i++) {
                        // Find the highest existing ID to avoid collisions
                        const existingIds = this.notepadCards.map(n => n.id);
                        const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : i;

                        const newCard = notepadTemplate.content.cloneNode(true).querySelector('.notepad-card');
                        newCard.dataset.cardType = 'notepad';
                        newCard.dataset.cardId = nextId;
                        this.notepadCards.push(new NotepadCard(newCard, this, this.db));
                    }
                }

                // Add this new method to add a notepad
                async addNotepad() {
                    const existingIds = this.notepadCards.map(n => n.id);
                    const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 0;

                    const newCard = document.getElementById('notepad-card-template').content.cloneNode(true).querySelector('.notepad-card');
                    newCard.dataset.cardType = 'notepad';
                    newCard.dataset.cardId = nextId;

                    this.notepadCards.push(new NotepadCard(newCard, this, this.db));

                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    this.gridLayout.splice(controlCardIndex, 0, { type: 'notepad', id: nextId });

                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                // Add this new method to remove a notepad
                async removeNotepad(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this note?');
                    if (!confirmed) return;

                    this.notepadCards = this.notepadCards.filter(n => n.id !== idToRemove);
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'notepad' && item.id === idToRemove));

                    await this.db.delete(`notepad-${idToRemove}`);
                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async loadTimers() {
                    const timerCountData = await this.db.get('timerCount');
                    const numTimers = timerCountData ? timerCountData.count : 0;
                    const timerTemplate = document.getElementById('timer-card-template');

                    // Use Promise.all to initialize all timers in parallel for speed
                    const timerPromises = [];
                    for (let i = 0; i < numTimers; i++) {
                        const timerId = i; // This might need to be more robust if IDs aren't sequential
                        const newCard = timerTemplate.content.cloneNode(true).querySelector('.timer-card');
                        newCard.dataset.cardType = 'timer';
                        newCard.dataset.cardId = timerId;

                        const timerInstance = new TimerCard(newCard, this, this.db);
                        this.timerCards.push(timerInstance);
                        timerPromises.push(timerInstance.init()); // Add the init promise to the array
                    }
                    await Promise.all(timerPromises); // Wait for all timers to be initialized
                }

                async addTimer() {
                    const nextTimerIndex = this.timerCards.length > 0 ? Math.max(...this.timerCards.map(t => t.id)) + 1 : 0;
                    const newCard = document.getElementById('timer-card-template').content.cloneNode(true).querySelector('.timer-card');
                    newCard.dataset.cardType = 'timer';
                    newCard.dataset.cardId = nextTimerIndex;

                    const newTimer = new TimerCard(newCard, this, this.db);
                    this.timerCards.push(newTimer);
                    await newTimer.init(); // Await initialization before proceeding

                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    this.gridLayout.splice(controlCardIndex, 0, { type: 'timer', id: nextTimerIndex });

                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async removeTimer(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this timer?');
                    if (!confirmed) return;

                    const timerInstance = this.timerCards.find(t => t.id === idToRemove);
                    if (timerInstance) {
                        timerInstance.destroy(); // Clean up the animation frame loop
                    }

                    this.timerCards = this.timerCards.filter(t => t.id !== idToRemove);
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'timer' && item.id === idToRemove));

                    await this.db.delete(`timer-${idToRemove}`);
                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async requestPersistentStorage() {
                    if (navigator.storage && navigator.storage.persist) {
                        const isPersisted = await navigator.storage.persisted();
                        if (!isPersisted) {
                            const granted = await navigator.storage.persist();
                            if (granted) {
                                console.log("Persistent storage granted!");
                            } else {
                                console.log("Persistent storage denied.");
                            }
                        } else {
                            console.log("Persistent storage already granted.");
                        }
                    }
                }


                async loadStateFromDB() {
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    let configData = await this.db.get(this.db.CONFIG_KEY);
                    if (!configData) {
                        configData = { id: this.db.CONFIG_KEY, numButtons: 4 };
                        await this.db.save(configData.id, configData);

                        // Set the default number of timers to 1
                        await this.db.save('timerCount', { id: 'timerCount', count: 1 });
                    }

                    const numButtons = configData.numButtons;
                    const soundDataMap = new Map(soundData.map(item => [item.id, item]));

                    this.buttonsData = [];
                    for (let i = 0; i < numButtons; i++) {
                        const data = soundDataMap.get(i) || this._getInitialButtonData(i);
                        this.buttonsData.push(data);
                    }
                }

                async addButton() {
                    const nextIndex = this.buttonsData.length;
                    const newButtonData = this._getInitialButtonData(nextIndex);
                    this.buttonsData.push(newButtonData);

                    // REFACTOR: Add the new button to the layout and re-render.
                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    if (controlCardIndex > -1) {
                        this.gridLayout.splice(controlCardIndex, 0, { type: 'sound', id: nextIndex });
                    } else {
                        this.gridLayout.push({ type: 'sound', id: nextIndex });
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async removeLastButton() {
                    if (this.buttonsData.length > 1) {
                        const lastIndex = this.buttonsData.length - 1;
                        this.buttonsData.pop();
                        if (this.players.has(lastIndex)) {
                            this.players.get(lastIndex).cleanup();
                            this.players.delete(lastIndex);
                        }
                        await this.db.delete(lastIndex);
                        await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });

                        // REFACTOR: Remove from layout and re-render.
                        this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === lastIndex));
                        await this._saveLayout();
                        this.renderGrid();
                    }
                }

                async updateButton(index, newData) {
                    this.buttonsData[index] = { ...this.buttonsData[index], ...newData };
                    await this.db.save(index, this.buttonsData[index]);
                    this.renderGrid();
                }

                // ================================================================
                // UI Rendering Methods
                // ================================================================

                // REFACTOR: This is the new primary rendering function.
                renderGrid() {
                    this.soundboardGrid.innerHTML = '';

                    this.gridLayout.forEach(item => {
                        let cardElement = null;
                        if (item.type === 'sound') {
                            const buttonData = this.buttonsData.find(b => b.id === item.id);
                            if (buttonData) {
                                cardElement = this._createSoundCardElement(buttonData, item.id);
                            }
                        } else if (item.type === 'timer') {
                            const timerInstance = this.timerCards.find(t => t.id === item.id);
                            if (timerInstance) {
                                cardElement = timerInstance.cardElement;
                            }
                        } else if (item.type === 'control') {
                            cardElement = this.controlCardElement;
                            cardElement.style.display = 'flex'; // Make it visible
                        } else if (item.type === 'notepad') {
                            const noteInstance = this.notepadCards.find(n => n.id === item.id);
                            if (noteInstance) {
                                cardElement = noteInstance.cardElement;
                            }
                        }

                        if (cardElement) {
                            this.soundboardGrid.appendChild(cardElement);
                        }
                    });

                    this.timerCards.forEach(timer => timer.updateTimerSoundSelectors(this.buttonsData));
                }

                _createSoundCardElement(buttonData, index) {
                    const card = document.createElement('div');
                    const textColor = getContrastColor(buttonData.color);
                    card.className = 'sound-card';
                    // REFACTOR: Use distinct data attributes for type and ID.
                    card.dataset.cardType = 'sound';
                    card.dataset.cardId = index;
                    card.dataset.index = index; // Keep for compatibility
                    card.setAttribute('draggable', this.isRearranging);
                    card.innerHTML = `
<button class="sound-button" data-action="play" style="background-color: ${buttonData.color}; color: ${textColor}">
<div class="progress-overlay" style="width: 0%;"></div>
<span class="button-text">${buttonData.name}</span>
<div class="settings-triangle-btn" data-action="settings">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
<path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
</svg>
</div>
</button>
<div class="sound-controls">
<div class="slider-group">
<label>Volume</label>
<input type="range" min="0" max="1" step="0.01" value="${buttonData.volume}" data-action="volume-change">
</div>
<div class="slider-group">
<label>Speed</label>
<input type="range" min="0.5" max="2" step="0.1" value="${buttonData.playbackRate}" data-action="speed-change" ondblclick="this.value=1.0; this.dispatchEvent(new Event('input'))">
<span class="speed-display">${buttonData.playbackRate.toFixed(1)}x</span>
</div>
</div>
`;
                    return card;
                }

                // ================================================================
                // Event Handling and Playback Logic
                // ================================================================

                attachGlobalEventListeners() {

                    document.getElementById('soundboard-title').addEventListener('blur', (e) => {
                        const newTitle = e.target.textContent.trim();
                        document.title = newTitle + " | B&M RSS";
                        this.db.save('soundboard-title', { id: 'soundboard-title', title: newTitle });
                    });

                    this.soundboardGrid.addEventListener('click', (event) => this.handleGridClick(event));
                    // debounce the slider input to save to DB only after the user stops sliding for 250ms
                    this.soundboardGrid.addEventListener('input', debounce((event) => this.handleSliderChange(event), 250));
                    this.soundboardGrid.addEventListener('dblclick', (event) => this.handleGridDoubleClick(event));

                    this.soundboardGrid.addEventListener('dragstart', (e) => this.handleDragStart(e));
                    this.soundboardGrid.addEventListener('dragover', (e) => this.handleDragOver(e));
                    this.soundboardGrid.addEventListener('dragenter', (e) => this.handleDragEnter(e));
                    this.soundboardGrid.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    this.soundboardGrid.addEventListener('drop', (e) => this.handleDrop(e));
                    this.soundboardGrid.addEventListener('dragend', (e) => this.handleDragEnd(e));

                    document.getElementById('add-notepad-btn').addEventListener('click', () => this.addNotepad());
                    document.getElementById('add-btn-plus').addEventListener('click', () => this.addButton());
                    document.getElementById('remove-button-modal').addEventListener('click', () => this._handleRemoveButton());
                    document.getElementById('add-timer-btn').addEventListener('click', () => this.addTimer());
                    document.getElementById('rearrange-mode-btn').addEventListener('click', () => this.toggleRearrangeMode());
                    document.getElementById('download-config-btn').addEventListener('click', () => this.downloadConfig());
                    document.getElementById('upload-config-btn').addEventListener('click', () => document.getElementById('upload-config-input').click());
                    document.getElementById('upload-config-input').addEventListener('change', (e) => this.uploadConfig(e));
                    document.getElementById('db-manager-btn').addEventListener('click', () => this.showDbManagerModal());

                    document.getElementById('switch-board-btn').addEventListener('click', () => this.openBoardSwitcherModal());
                    document.getElementById('create-new-board-btn').addEventListener('click', () => this.createNewBoard());

                    // ADD a listener to close the new modal when clicking the background
                    document.getElementById('board-switcher-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'board-switcher-modal') {
                            document.getElementById('board-switcher-modal').style.display = 'none';
                        }
                    });


                    document.getElementById('settings-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'settings-modal') this.closeSettingsModal();
                    });

                    document.getElementById('file-list').addEventListener('click', (event) => {
                        // Check if the clicked element is a "remove file" button
                        if (event.target.classList.contains('remove-file-button')) {
                            // If so, call the handler method to remove the file
                            this.removeFileFromModalButton(event);
                        }
                    });
                    

                    document.getElementById('db-manager-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'db-manager-modal') this.closeDbManagerModal();
                    });
                    document.getElementById('persistent-storage-checkbox').addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.requestPersistentStorage();
                        }
                        // Note: Browsers do not currently allow you to programmatically "un-persist" storage.
                        // The user must do this through browser settings.
                    });
                    document.getElementById('clear-database-btn').addEventListener('click', () => this.handleClearDatabase());

                    document.getElementById('button-name-input').addEventListener('input', (e) => this.updateModalButtonData('name', e.target.value));
                    document.getElementById('button-color-picker').addEventListener('input', (e) => this.updateModalButtonData('color', e.target.value));
                    document.getElementById('add-file-input').addEventListener('change', (e) => this.addFilesToModalButton(e));
                    document.getElementById('clear-files-btn').addEventListener('click', () => this.clearModalButtonFiles());
                    document.getElementById('shuffle-checkbox').addEventListener('change', (e) => this.updateModalButtonData('shuffle', e.target.checked));
                    document.getElementById('autoplay-checkbox').addEventListener('change', (e) => this.updateModalButtonData('autoplay', e.target.checked));
                    document.getElementById('priority-checkbox').addEventListener('change', (e) => this.updateModalButtonData('priority', e.target.checked));
                    document.getElementById('loop-checkbox').addEventListener('change', (e) => this.updateModalButtonData('loop', e.target.checked));


                    // COSMETICS MODAL LISTENERS
                    document.getElementById('cosmetics-btn').addEventListener('click', () => this.themeManager.open());

                    // HELPFUL BUG

                    document.getElementById('help-bug-btn').addEventListener('click', () => {
                        document.getElementById('help-modal').style.display = 'flex';
                    });

                    document.getElementById('help-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'help-modal') {
                            document.getElementById('help-modal').style.display = 'none';
                        }
                    });
                    document.querySelector('.help-accordion').addEventListener('click', (e) => {
                        if (e.target.classList.contains('accordion-header')) {
                            const activeHeader = document.querySelector('.accordion-header.active');
                            // Close the already active header if it's not the one that was clicked
                            if (activeHeader && activeHeader !== e.target) {
                                activeHeader.classList.remove('active');
                                activeHeader.nextElementSibling.classList.remove('active');
                            }

                            // Toggle the clicked header and its content
                            e.target.classList.toggle('active');
                            const content = e.target.nextElementSibling;
                            content.classList.toggle('active');
                        }
                    });

                    // SERVICE WORKER
                    // WORKER IN SERVICE
                    // TREAT HIM NICELY
                    if ('serviceWorker' in navigator) {
                        window.addEventListener('load', () => {
                            navigator.serviceWorker.register('./service-worker.js').then(registration => {
                                console.log('ServiceWorker registration successful');
                            }).catch(err => {
                                console.log('ServiceWorker registration failed: ', err);
                            });
                        });
                    }
                }

                handleGridClick(event) {
                    if (this.isRearranging) return;
                    const card = event.target.closest('.sound-card[data-card-type="sound"]');
                    if (!card) return;
                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const actionElement = event.target.closest('[data-action]');
                    if (!actionElement) return;
                    const action = actionElement.dataset.action;

                    switch (action) {
                        case 'play':
                            this.togglePlay(index);
                            break;
                        case 'settings':
                            this.openSettingsModal(index);
                            break;
                    }
                }

                handleGridDoubleClick(event) {
                    const slider = event.target.closest('input[type="range"][data-action="speed-change"]');
                    if (slider) {
                        slider.value = 1.0;
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                handleSliderChange(event) {
                    const card = event.target.closest('.sound-card');
                    if (!card) return;

                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const action = event.target.dataset.action;
                    const value = parseFloat(event.target.value);
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    switch (action) {
                        case 'volume-change':
                            buttonData.volume = value;
                            player.audio.volume = value;
                            break;
                        case 'speed-change':
                            buttonData.playbackRate = value;
                            player.audio.playbackRate = value;
                            const speedDisplay = card.querySelector('.speed-display');
                            if (speedDisplay) {
                                speedDisplay.textContent = `${value.toFixed(1)}x`;
                            }
                            break;
                    }
                    this.db.save(index, buttonData);
                }

                handleDragStart(event) {
                    if (!this.isRearranging) return;
                    this.draggedItem = event.target.closest('.sound-card');
                    if (!this.draggedItem) return;
                    event.dataTransfer.effectAllowed = 'move';
                    // REFACTOR: Use a generic identifier for the drag data.
                    event.dataTransfer.setData('text/plain', this.draggedItem.dataset.cardId);
                    setTimeout(() => {
                        this.draggedItem.classList.add('dragging');
                    }, 0);
                }

                handleDragOver(event) {
                    event.preventDefault();
                }

                handleDragEnter(event) {
                    if (!this.isRearranging) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        targetCard.classList.add('drag-over');
                    }
                }

                handleDragLeave(event) {
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        if (!targetCard.contains(event.relatedTarget)) {
                            targetCard.classList.remove('drag-over');
                        }
                    }
                }

                async handleDrop(event) {
                    event.preventDefault();
                    if (!this.isRearranging || !this.draggedItem) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        const fromType = this.draggedItem.dataset.cardType;
                        const fromId = fromType === 'control' ? 'control-card' : parseInt(this.draggedItem.dataset.cardId);
                        const toType = targetCard.dataset.cardType;
                        const toId = toType === 'control' ? 'control-card' : parseInt(targetCard.dataset.cardId);

                        const fromIndex = this.gridLayout.findIndex(item => item.type === fromType && item.id === fromId);
                        const toIndex = this.gridLayout.findIndex(item => item.type === toType && item.id === toId);

                        if (fromIndex > -1 && toIndex > -1) {
                            [this.gridLayout[fromIndex], this.gridLayout[toIndex]] = [this.gridLayout[toIndex], this.gridLayout[fromIndex]];
                            await this._saveLayout();
                            this.renderGrid();
                        }
                    }
                }

                handleDragEnd() {
                    if (this.draggedItem) {
                        this.draggedItem.classList.remove('dragging');
                        this.draggedItem = null;
                        this.soundboardGrid.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    }
                }

                toggleRearrangeMode() {
                    this.isRearranging = !this.isRearranging;
                    const btn = document.getElementById('rearrange-mode-btn');
                    const grid = document.getElementById('soundboard-grid');
                    grid.classList.toggle('rearrange-mode', this.isRearranging);
                    btn.textContent = this.isRearranging ? 'Done Rearranging' : 'Rearrange';

                    grid.querySelectorAll('.sound-card').forEach(card => {
                        card.setAttribute('draggable', this.isRearranging);
                    });
                }

                async togglePlay(index) {
                    if (isNaN(index)) {
                        console.error("Invalid index provided:", index);
                        return;
                    }
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    if (buttonData.files.length === 0) return;

                    if (player.playback.currentFileIndex >= buttonData.files.length) {
                        player.playback.currentFileIndex = 0;
                    }

                    if (player.isPlaying) {
                        player.cleanup();
                        this.handlePlaybackCompletion(index);

                    } else {

                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;

                        player.playback.currentFileIndex = fileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    }
                }

                _lerpVolume(audio, slider, from, to, duration) {
                    const start = performance.now();

                    function step(now) {
                        const t = Math.min((now - start) / duration, 1); // 0 â†’ 1
                        audio.volume = Math.max(0, Math.min(1, from + (to - from) * t));
                        slider.value = audio.volume;

                        if (t < 1) {
                            requestAnimationFrame(step);
                        }
                    }

                    requestAnimationFrame(step);
                }

                handlePriorityDucking() {
                    this.players.forEach((player, playerIndex) => {

                        const playerButtonData = this.buttonsData[playerIndex];
                        if (!playerButtonData.priority) {
                            const duckTarget = playerButtonData.volume * player.duckAmount;
                            const slider = this._getVolumeSlider(playerIndex);
                            this._lerpVolume(player.audio, slider, player.audio.volume, duckTarget, player.fadeSpeed);

                        }
                    });
                }

                _getVolumeSlider(index) {
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        return card.querySelector('input[data-action="volume-change"]');
                    }
                    return null;
                }

                _checkForPriorityPlaying() {
                    for (const [playerIndex, player] of this.players.entries()) {
                        // Check if the sound is actually playing AND belongs to a priority button.
                        if (player.isPlaying && this.buttonsData[playerIndex]?.priority) {
                            return true; // Found another priority sound playing, so stop checking.
                        }
                    }
                    return false; // No other priority sounds are playing.
                };


                handlePlaybackCompletion(index) {
                    const buttonData = this.buttonsData[index];
                    const player = this.players.get(index);
                    if (!player) return;

                    // Check if the sound that just ended was a priority sound.
                    if (buttonData.priority) {
                        // Check if any OTHER priority sounds are still playing.
                        let isOtherPriorityPlaying = this._checkForPriorityPlaying();

                        // If no other priority sounds are running, it's safe to un-duck.
                        if (!isOtherPriorityPlaying) {
                            
                            this.players.forEach((duckedPlayer, duckedPlayerIndex) => {
                                const duckedPlayerButtonData = this.buttonsData[duckedPlayerIndex];

                                // Only restore volume on sounds that were actually ducked (i.e., non-priority and still playing).
                                if (!duckedPlayerButtonData.priority) {
                                    const targetVolume = duckedPlayerButtonData.volume;
                                    const slider = this._getVolumeSlider(duckedPlayerIndex);
                                    this._lerpVolume(duckedPlayer.audio, slider, duckedPlayer.audio.volume, targetVolume, duckedPlayer.fadeSpeed);
                                }
                            });
                        }
                    }


                    // This handles the autoplay/loop logic after the ducking is resolved.
                    if (buttonData.loop) {
                        this.playFile(index, player.playback.currentFileIndex, buttonData.priority);
                    } else if (buttonData.autoplay) {

                        player.playback.currentFileIndex++
                        if (player.playback.currentFileIndex >= buttonData.files.length) {
                            player.playback.currentFileIndex = 0;
                        }
                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    } else {
                        // Always advance to the next track by default.
                        player.playback.currentFileIndex++
                    }
                }

                async playFile(buttonIndex, fileIndex, isPriority) {
                    const buttonData = this.buttonsData[buttonIndex];
                    const player = this._getAudioPlayer(buttonIndex);
                    const fileData = buttonData.files[fileIndex];
                    if (!fileData) {
                        console.error("No file found at index:", fileIndex);
                        return;
                    }
                    player.cleanup();
                    const blob = new Blob([fileData.arrayBuffer], { type: fileData.mimeType });
                    player.audio.src = URL.createObjectURL(blob);
                    player.audio.volume = buttonData.volume;
                    player.audio.playbackRate = buttonData.playbackRate;

                    player.audio.play().catch(e => console.error("Playback error:", e));
                    if (isPriority) {
                        this.handlePriorityDucking();
                    }
                }

                _getAudioPlayer(index) {
                    let player = this.players.get(index);
                    if (!player) {
                        const audio = new Audio();
                        player = new AudioPlayer(audio);
                        this.players.set(index, player);

                        audio.onended = () => {
                            this.handlePlaybackCompletion(index);
                        };
                    }
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        player.progressOverlay = card.querySelector('.progress-overlay');
                        player.card = card;
                    }
                    return player;
                }

                _getInitialButtonData(index) {
                    return {
                        id: index,
                        name: `Button ${index + 1}`,
                        color: "var(--accent-color)",
                        volume: 1.0,
                        playbackRate: 1.0,
                        shuffle: false,
                        loop: false,
                        priority: false,
                        files: []
                    };
                }

                _shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                }


                // ================================================================
                // Settings Modal Methods
                // ================================================================

                openSettingsModal(index) {
                    this.activeModalIndex = index;
                    const buttonData = this.buttonsData[index];
                    const modal = document.getElementById('settings-modal');

                    const colorPicker = document.getElementById('button-color-picker');
                    let colorValue = this.buttonsData[index].color;

                    // Check if the stored color is a CSS variable
                    if (colorValue.startsWith('var(')) {
                        // Extract the variable name (e.g., '--accent-color') from the string.
                        const cssVarName = colorValue.match(/--[\w-]+/)[0];

                        // Get the computed style from the root element and retrieve the variable's value.
                        colorValue = getComputedStyle(document.documentElement).getPropertyValue(cssVarName).trim();
                    }

                    // 3. Set the color picker's value to the resolved hex code.
                    colorPicker.value = colorValue;

                    document.getElementById('button-name-input').value = buttonData.name;
                    document.getElementById('shuffle-checkbox').checked = buttonData.shuffle;
                    document.getElementById('autoplay-checkbox').checked = buttonData.autoplay;
                    document.getElementById('priority-checkbox').checked = buttonData.priority;
                    document.getElementById('loop-checkbox').checked = buttonData.loop;
                    this._renderFileList(buttonData.files);

                    modal.style.display = 'flex';
                }

                closeSettingsModal() {
                    const modal = document.getElementById('settings-modal');
                    modal.style.display = 'none';
                    this.activeModalIndex = null;
                    this.renderGrid();
                }

                updateModalButtonData(key, value) {
                    if (this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        buttonData[key] = value;
                        this.updateButton(this.activeModalIndex, buttonData);
                    }
                }

                _renderFileList(files) {
                    const fileListElement = document.getElementById('file-list');
                    fileListElement.innerHTML = ''; // Clear the list first

                    if (files.length === 0) {
                        const emptyItem = document.createElement('li');
                        emptyItem.innerHTML = '<small>No files added yet.</small>';
                        fileListElement.appendChild(emptyItem);
                        return;
                    }

                    files.forEach((file, index) => {
                        const listItem = document.createElement('li');
                        // The button is now just part of the HTML string. The single,
                        // delegated listener on the parent list will handle its click.
                        listItem.innerHTML = `
            <span>${file.fileName}</span>
            <button data-file-index="${index}" class="remove-file-button">Remove</button>
        `;
                        fileListElement.appendChild(listItem);
                    });
                }

                async addFilesToModalButton(event) {
                    if (this.activeModalIndex === null) return;
                    const files = event.target.files;
                    if (files.length === 0) return;
                    const buttonData = this.buttonsData[this.activeModalIndex];
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const arrayBuffer = await file.arrayBuffer();
                        const fileData = { fileName: file.name, mimeType: file.type, arrayBuffer: arrayBuffer };
                        buttonData.files.push(fileData);
                    }
                    await this.updateButton(this.activeModalIndex, buttonData);
                    this._renderFileList(buttonData.files);
                }

                async clearModalButtonFiles() {
                    const confirmed = await this.showConfirmModal("Are you sure you want to clear all audio files for this button?");
                    if (confirmed && this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        player.cleanup();
                        buttonData.files = [];
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                async removeFileFromModalButton(event) {
                    const fileIndex = parseInt(event.target.dataset.fileIndex);
                    if (!isNaN(fileIndex)) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        if (!buttonData || !buttonData.files) return;
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        if (player) { player.cleanup(); }
                        buttonData.files.splice(fileIndex, 1);
                        if (buttonData.files.length > 0) { player.playback.currentFileIndex = 0; }
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                // ================================================================
                // Global Functionality Methods
                // ================================================================

                async openBoardSwitcherModal() {
                    const boardIds = await BoardManager.getBoardList(); // UPDATED
                    const boardListElement = document.getElementById('board-list');
                    const modal = document.getElementById('board-switcher-modal');

                    boardListElement.innerHTML = ''; // Clear previous list

                    if (boardIds.length === 0) {
                        boardListElement.innerHTML = '<li><small>No other boards found. Create one by adding "?board=board-name" to the URL.</small></li>';
                    } else {
                        boardIds.forEach(id => {
                            const listItem = document.createElement('li');
                            const link = document.createElement('a');
                            link.textContent = id;
                            // The 'default' board links to the base URL
                            link.href = (id === 'default') ? window.location.pathname : `?board=${id}`;
                            listItem.appendChild(link);
                            boardListElement.appendChild(listItem);
                        });
                    }

                    modal.style.display = 'flex';
                }

                async _handleRemoveButton() {
                    if (this.activeModalIndex === null) return;
                    const confirmed = await this.showConfirmModal("Are you sure you want to permanently remove this button?");
                    if (confirmed) {
                        await this.removeButton(this.activeModalIndex);
                    }
                }

                // REFACTOR: This method now updates the gridLayout as well.
                async removeButton(indexToRemove) {
                    if (this.buttonsData.length <= 1) {
                        return;
                    }

                    this.timerCards.forEach(timer => timer.handleButtonDeletion(indexToRemove)); // notify timer cards of the change to prevent start/end cues shifting

                    this.buttonsData.splice(indexToRemove, 1);
                    if (this.players.has(indexToRemove)) {
                        this.players.get(indexToRemove).cleanup();
                        this.players.delete(indexToRemove);
                    }

                    // Remove from layout
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === indexToRemove));

                    // Re-index subsequent button IDs in both data and layout
                    this.buttonsData.forEach((button, i) => {
                        if (i >= indexToRemove) button.id = i;
                    });
                    this.gridLayout.forEach(item => {
                        if (item.type === 'sound' && item.id > indexToRemove) {
                            item.id--;
                        }
                    });

                    // Clear and re-write the database to maintain consistency
                    await this.db._dbRequest(this.db.SOUNDS_STORE, 'readwrite', 'clear');
                    for (const button of this.buttonsData) {
                        await this.db.save(button.id, button);
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();

                    this.closeSettingsModal();
                    this.renderGrid();
                }

                async downloadConfig() {
                    const allData = await this.db.getAll();
                    const soundboardTitle = document.getElementById('soundboard-title').textContent.trim();
                    const serializableData = allData.map(item => {
                        if (item.files && item.files.length > 0) {
                            const serializableFiles = item.files.map(file => ({ ...file, arrayBuffer: this._arrayBufferToBase64(file.arrayBuffer) }));
                            return { ...item, files: serializableFiles };
                        }
                        return item;
                    });
                    const json = JSON.stringify(serializableData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${Date.now()}_${soundboardTitle}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                async uploadConfig(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            const confirmed = await this.showConfirmModal("This will overwrite your current soundboard configuration. Are you sure?");
                            if (confirmed) {
                                const deserializedData = data.map(item => {
                                    if (item.files && item.files.length > 0) {
                                        const deserializedFiles = item.files.map(file => ({ ...file, arrayBuffer: this._base64ToArrayBuffer(file.arrayBuffer) }));
                                        return { ...item, files: deserializedFiles };
                                    }
                                    return item;
                                });

                                await this.db.clear();
                                for (const item of deserializedData) {
                                    await this.db.save(item.id, item);
                                }

                                await this._loadBoardData();
                                alert("Configuration uploaded successfully!");
                                window.location.reload();
                            }
                        } catch (e) {
                            alert("Failed to read file. Please ensure it is a valid JSON configuration file.");
                            console.error("Upload error:", e);
                        }
                    };
                    reader.readAsText(file);
                }

                _arrayBufferToBase64(buffer) {
                    let binary = '';
                    const bytes = new Uint8Array(buffer);
                    const len = bytes.byteLength;
                    for (let i = 0; i < len; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return btoa(binary);
                }

                _base64ToArrayBuffer(base64) {
                    const binary_string = atob(base64);
                    const len = binary_string.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binary_string.charCodeAt(i);
                    }
                    return bytes.buffer;
                }

                // ================================================================
                // Modal Manager Methods
                // ================================================================

                async showDbManagerModal() {
                    this.updateDbStats();
                    this.updateDbFileList();

                    const checkbox = document.getElementById('persistent-storage-checkbox');
                    if (navigator.storage && navigator.storage.persisted) {
                        checkbox.parentElement.style.display = ''; // Ensure it's visible
                        const isPersisted = await navigator.storage.persisted();
                        checkbox.checked = isPersisted;
                        checkbox.disabled = isPersisted; // ADD THIS LINE to lock the checkbox
                    } else {
                        // If the API isn't supported, hide the option entirely.
                        checkbox.parentElement.style.display = 'none';
                    }


                    document.getElementById('db-manager-modal').style.display = 'flex';
                }

                closeDbManagerModal() {
                    document.getElementById('db-manager-modal').style.display = 'none';
                }

                async updateDbStats() {
                    const dbSizeEl = document.getElementById('db-usage');
                    const dbQuotaEl = document.getElementById('db-quota');
                    const dbButtonCountEl = document.getElementById('db-button-count');

                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    dbButtonCountEl.textContent = soundData.length;

                    if (navigator.storage && navigator.storage.estimate) {
                        const { quota, usage } = await navigator.storage.estimate();
                        dbSizeEl.textContent = this._formatBytes(usage);
                        dbQuotaEl.textContent = this._formatBytes(quota);
                    } else {
                        dbSizeEl.textContent = 'N/A';
                        dbQuotaEl.textContent = 'N/A';
                    }
                }

                async updateDbFileList() {
                    const fileListEl = document.getElementById('db-file-list');
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    fileListEl.innerHTML = '';
                    if (soundData.length === 0) {
                        fileListEl.innerHTML = '<li><small>No sounds found.</small></li>';
                        return;
                    }

                    soundData.forEach(item => {
                        const li = document.createElement('li');
                        li.textContent = `Button ${item.id + 1}: ${item.files.length} file(s)`;
                        fileListEl.appendChild(li);
                    });
                }

                async handleClearDatabase() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';

                    if (boardId === 'default') {
                        // --- NEW LOGIC FOR WIPING THE DEFAULT BOARD ---
                        const confirmed = await this.showConfirmModal("This will wipe all cards and settings from the default board but will PRESERVE your list of other boards. Are you sure?");
                        if (confirmed) {
                            try {
                                // 1. Read the board list and keep it in memory.
                                const boardList = await BoardManager.getBoardList();

                                // 2. Clear both object stores completely.
                                await this.db.clear();

                                // 3. Write the board list back to the now-empty database.
                                await BoardManager.saveBoardList(boardList);

                                // 4. Reload the page to show the fresh default board.
                                window.location.reload();

                            } catch (e) {
                                console.error("Failed to wipe default board:", e);
                            }
                        }
                    } else {
                        // --- EXISTING LOGIC FOR DELETING OTHER BOARDS ---
                        const confirmed = await this.showConfirmModal(`This will permanently delete the entire "${boardId}" board. Are you sure?`);
                        if (confirmed) {
                            try {
                                await this.db.clear();
                                await BoardManager.removeBoardId(boardId);
                                window.location.href = window.location.pathname;
                            } catch (e) {
                                console.error("Failed to clear database:", e);
                            }
                        }
                    }
                }

                showConfirmModal(message) {
                    return new Promise(resolve => {
                        const modal = document.getElementById('confirm-modal');
                        const messageEl = document.getElementById('confirm-modal-message');
                        const yesBtn = document.getElementById('confirm-yes-btn');
                        const noBtn = document.getElementById('confirm-no-btn');
                        messageEl.textContent = message;
                        const handler = (e) => {
                            if (e.target === yesBtn) resolve(true);
                            else if (e.target === noBtn) resolve(false);
                            yesBtn.removeEventListener('click', handler);
                            noBtn.removeEventListener('click', handler);
                            modal.style.display = 'none';
                        };
                        yesBtn.addEventListener('click', handler);
                        noBtn.addEventListener('click', handler);
                        modal.style.display = 'flex';
                        modal.style.zIndex = 1001;
                    });
                }

                _formatBytes(bytes, decimals = 2) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const dm = decimals < 0 ? 0 : decimals;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
                }

                // helper bug more stuff

                async initBugMovement() {
                    const checkbox = document.getElementById('toggle-bug-movement-checkbox');
                    const bug = document.getElementById('help-bug-btn');

                    // Load the state and set the initial UI
                    const state = await this.db.get("bug-movement");
                    const isStill = state ? state.state : false; // Default to false (bug is moving)
                    checkbox.checked = isStill;

                    // Invert the logic: if the bug is 'still', remove the 'bug-moving' class
                    bug.classList.toggle('bug-moving', !isStill);

                    // Attach the single listener for all future changes
                    checkbox.addEventListener('change', async () => {
                        const isNowStill = checkbox.checked;
                        await this.db.save("bug-movement", { id: "bug-movement", state: isNowStill });
                        bug.classList.toggle('bug-moving', !isNowStill);
                    });
                }

            }

    </script>
    <script name="ReallySimpleSoundboard">

        document.addEventListener('DOMContentLoaded', () => {

            // --- PWA INSTALL HANDLER ---
            let deferredPrompt; // This variable will save the event
            const installButton = document.getElementById('install-pwa-btn');

            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent the mini-infobar from appearing on mobile
                e.preventDefault();
                // Stash the event so it can be triggered later.
                deferredPrompt = e;
                // Update UI to notify the user they can install the PWA
                if (installButton) {
                    installButton.disabled = false;
                }
            });

            if (installButton) {
                installButton.addEventListener('click', async () => {
                    if (!deferredPrompt) {
                        return; // The prompt isn't available
                    }
                    // Show the install prompt
                    deferredPrompt.prompt();
                    // Wait for the user to respond to the prompt
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    // We've used the prompt, and can't use it again, throw it away
                    deferredPrompt = null;
                    // Hide the button
                    installButton.disabled = true;
                });
            }

            // Listen for the appinstalled event to know when the PWA was successfully installed
            window.addEventListener('appinstalled', () => {
                // Clear the deferredPrompt so it can be garbage collected
                deferredPrompt = null;
                console.log('PWA was installed');
            });

            const app = new SoundboardManager(new SoundboardDB());
            app.initialize();
        });
    </script>


    <!-- THE HELPFUL BUG -->
    <button id="help-bug-btn" title="Help">
        <svg width="100%" height="100%" viewBox="0 0 224 240" version="1.1" xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/"
            style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;">
            <g id="Layer3"></g>
            <rect id="Artboard1" x="0" y="0" width="224" height="240" style="fill:none;" />
            <clipPath id="_clip1">
                <rect x="0" y="0" width="224" height="240" />
            </clipPath>
            <g clip-path="url(#_clip1)">
                <g id="Layer4">
                    <path
                        d="M60.644,104.58c-11.256,-5.528 -12.727,-5.926 -26.493,-14.801c-13.766,-8.874 -18.652,-15.658 -20.973,-18.747"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M95.436,55.756c-13.129,-12.407 2.698,-28.163 -0.73,-38.025c-5.141,-14.784 -20.837,-13.943 -29.852,-4.11c-5.483,5.98 -8.152,13.151 -7.828,22.714"
                        style="fill:none;stroke:#00a200;stroke-width:6.64px;" />
                    <path
                        d="M127.345,55.361c13.72,-11.75 -1.318,-28.262 2.589,-37.944c5.858,-14.515 21.493,-12.908 30.017,-2.645c5.184,6.241 7.499,13.533 6.708,23.07"
                        style="fill:none;stroke:#00a200;stroke-width:6.64px;" />
                    <path d="M57.333,140.553c-25.39,8.88 -28.701,38.481 -44.155,44.402"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M76.551,178.048c-12.254,11.196 -24.092,15.043 -26.945,27.627c-2.853,12.585 -12.143,20.721 -22.078,31.575"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M163.356,104.58c11.256,-5.528 12.727,-5.926 26.493,-14.801c13.766,-8.874 18.652,-15.658 20.973,-18.747"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path d="M166.667,140.553c25.39,8.88 28.701,38.481 44.155,44.402"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M147.449,178.048c12.254,11.196 24.092,15.043 26.945,27.627c2.853,12.585 12.143,20.721 22.078,31.575"
                        style="fill:none;stroke:#00a200;stroke-width:8.23px;" />
                    <path
                        d="M111.527,48.602c19.855,0 35.975,1.319 35.975,15.263c-0,13.945 -16.12,43.015 -35.975,43.015c-19.856,0 -35.521,-29.07 -35.521,-43.015c-0,-13.944 15.665,-15.263 35.521,-15.263Z"
                        style="fill:#00a200;" />
                    <path
                        d="M110.517,76.417c33.618,-0 60.195,16.364 60.195,55.302c0,38.937 -26.577,85.797 -60.195,85.797c-33.618,-0 -61.263,-46.86 -61.263,-85.797c0,-38.938 27.645,-55.302 61.263,-55.302Z"
                        style="fill:#00a200;" />
                    <path
                        d="M110.517,115.143l-36.286,83.255c-0,-0 13.666,19.426 37.464,19.118c21.992,-0.285 36.807,-21.893 36.807,-21.893l-37.985,-80.48Z"
                        style="fill:#a7b700;" />
                    <circle cx="108.983" cy="193.638" r="14.362" style="fill:#e2ff00;" />
                    <path
                        d="M89.067,113.981c2.248,-8.99 10.114,-17.981 22.21,-17.981c10.381,-0 20.733,6.575 21.619,19.105c0.887,12.53 -14.482,22.051 -20.679,23.6c-4.495,1.124 -4.045,11.614 -4.045,22.852"
                        style="fill:none;stroke:#e2ff00;stroke-width:25.54px;" />
                </g>
            </g>
        </svg>
    </button>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Soundboard Help & Info</h3>
            </div>

            <div class="help-accordion">

                <div class="accordion-item">
                    <button class="accordion-header active">Really Simple Overview</button>
                    <div class="accordion-content active"><p>Welcome to the "Really Simple" Soundboard!

                            I made this for the daily "morning radio" style <a href="https://bugandmoss.com/" target="_blank" rel="noopener noreferrer">podcast</a> that my wife Bug and I make, but then I got carried away...

                            I think this thing is SUPER useful! Not only for podcasting, but for loads of stuff (like my friend Ty who uses it for D&D).

                            The driving principle behind this project was to create a dashboard that is designed to be used WHILE recording.

                            It's a simple, customizable soundboard that works in your browser and can be installed as a Progressive Web App (PWA) to use offline. (There's an install button in the section about this!)

                            It's also all packed into ONE big HTML file (which I know is bad practice lol) so if you want to copy this whole thing over to your site, all you have to do is save this page.

                            All of your files stay on your device - nothing is uploaded anywhere except your local browser storage!

                            Initially, it was just a customizable local soundboard, but it has since grown to have different kinds of cards with various features that you can explore in the list below!

                            <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html"
                                target="_blank" rel="noopener noreferrer">Steal this, change it, use it however you'd like!</a> I don't care what you do with it, except for ONE rule: you cannot monetize it.

                            (Tip: click the title at the top to change it to whatever you want!)

                            Created with love by Mason Amadeus for Bug JennettðŸ’– (and you)

                            <a href="https://bugandmoss.com/" target="_blank" rel="noopener noreferrer"><i>Listen to "Bug & Moss" every weekday morning!</i></a>
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">The Control Card</button>
                    <div class="accordion-content"><p>This is the card with a bunch of buttons. It's the main hub for managing your soundboard.</p>
                        <ul><li><b>Add Sound/Timer/Note:</b> Creates a new card of that type!
                                
                                They'll spawn immediately to the LEFT of the control card.

                                (More details about each type can be found in their own dropdowns.)
                            </li>
                            
                            <li><b>Rearrange:</b> Toggles rearrange mode. Click and drag cards to SWAP their positions.

                                I know this is a bit of a PITA. Someday I hope to make it so you can drop cards in-between, and they'll scoot over instead of swapping. If you wanna help, this thing is <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html" target="_blank">on github</a>.
                            </li>

                            <li><b>Upload/Download:</b> Save or load your entire board configuration, INCLUDING THE SOUNDS, to a JSON file!

                                It'll pop into your downloads without a popup (probably), and the title will be whatever your board title is.

                                (Nerds: the files are stored as an array buffer in IndexedDB, and converted to base64 when they go into the json)
                            </li>

                            <li><b>Storage:</b> An overview of how much of your browser storage is being used, as well as a setting to toggle "storage durability" which should provide a little extra protection against accidental data loss!

                                This is also where you go to delete your entire board, if you want to do that! It also deletes the associated sound files.
                            </li>

                            <li><b>Cosmetics:</b> Change the colors and font of your soundboard.

                                This is probably the jankiest cosmetic menu on earth, and I'm particularly proud of the font selector lmao.
                            </li>

                            <li><b>Switch Board:</b> Switch between different soundboards, or create new ones!

                                Make as many boards as you want! Just beware that I haven't tested any of this with an extreme amount of buttons/boards/data, so I have no idea what happens if it gets too big.</li>
                                (Nerds: This works by changing the url to have a parameter named after the board name you choose, which causes a new IndexedDB database to be created. I dunno what happens if you make two boards with the same name, but it probably breaks.)
                        </ul>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Sound Buttons</button>
                    <div class="accordion-content"><p>
                            <b>Play a sound</b> by clicking the big button.

                            <b>Stop a sound</b> by clicking the button while a sound is playing. If there are multiple files in the button, this will skip to the next file (depending on the other options explained below).

                            <b>Volume</b> affects how loud the sound plays.

                            <b>Speed</b> affects the playback speed of the sound. It's a bit jank, but it's pretty fun.

                            <b>Edit the button</b> by clicking the colorful triangle corner in the bottom right of the button.

                            Inside the settings menu you can:

                            <b>Change the button color</b> using the little colored square to the left of the button title field.

                            <b>Change the button name</b> by clicking on the title field and typing a new name.

                            <b>Multiple sounds</b> can be added to a button. There is no limit! You can remove individual files from the list, or clear them all using labeled buttons.

                            <b>Random</b> will randomly select a file from that button each time it is clicked to play.

                            <b>Autoplay</b> will automatically play the next sound when the currently playing sound ends.

                            <b>Priority</b> is useful for situations like playing a bumper over music. Any buttons with "Priority" will temporarly turn down any non-priority buttons until the priority sound finishes. It's auto-ducking, basically!

                            <b>Loop</b> will loop whatever sound is playing, restarting it when it ends.
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Timers</button>
                    <div class="accordion-content"><p>Timers run a countdown, and can also trigger buttons at the start and end!

                            <b>Start</b> will start the timer.

                            <b>Reset</b> will stop and reset the timer to its initial time, but WILL NOT reset any other settings (like Starts & Ends With cues).

                            Uncheck "Lock Timer Settings" to edit the following timer properties:

                            <b>"Starts With"</b> lets you select a button to play when the timer starts.

                            <b>"Ends With"</b> lets you select a button to play at the end of the timer -- with a catch!

                            When you have selected an "Ends With" sound, <b><i>the timer will hit 0:00 exactly as the "Ends With" sound FINISHES playing!</b></i>

                            This makes it a powerful tool for timed segments, as you can input the desired segment length and your outro cue will 'play you out' automagically!

                            Sometimes this function fails to calculate the length of the end cue (I've only had it fail on mobile), and as a fallback - it will play when the timer ends. But 99% of the time, the Timer Card should end WITH the sound.
                            
                            The timer is pretty darn accurate, and stays running even if the tab is in the background or the page is refreshed!
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Notepads</button>
                    <div class="accordion-content"><p>A simple place to keep notes!

                            I like to use it to copy/paste URLs for articles or stuff we talk about on the show. Or to jot down stuff to talk about on future shows.

                            You can even store multiple notes in a single card. Click the little "+" button to add a new tab inside the note card.

                            You can edit the title of a note by clicking the text "New Note" and changing it to whatever you want.

                            Other than that it's just a text box. Go crazy!
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Offline Use (PWA)</button>
                    <div class="accordion-content"><p>This soundboard is an installable Progressive Web App (PWA).

                            <b>IMPORTANT:</b> When you install this as an app, your boards will NOT transfer over automatically. You will not lose any data, but any boards you have already created will need to be downloaded from the website and then uploaded to the app.

            <button id="install-pwa-btn" class="install-button-modal" disabled>Install App for Offline Use</button>
                            <b>If the install button is greyed-out or disabled,</b> it means your browser isn't ready. Sometimes this takes a second. Try waiting a minute and reloading the page.

                            If you're on mobile, you might have to go to "Share Page" and then "Add to Home Screen" (or something like that).
                            
                            As always, ALL of your data is stored ONLY on your device. Even if you use the website version. I don't want to pay for a server lmao.

                            Your data is stored locally and can be double-protected from automatic cleanup by enabling "Storage Durability" in the Storage menu. Mobile doesn't seem to like that.

                            IndexedDB is pretty robust, and doesn't tend to clear out unless you're REALLY low on space - so you probably don't even need to worry about it.

                            (Tip: if you REALLY want to use this soundboard on mobile, create the boards on a computer first, download your config, email it to yourself, download it from the email on your phone, and upload the config to the mobile site/app. Badaboom, it works.)

                        </p>
                    </div>
                </div>

                <div class="modal-checkbox-group" style="margin-top: 1rem">
                    <label>
                        <input type="checkbox" id="toggle-bug-movement-checkbox">
                        Hold still, Bug!
                    </label>
                </div>

            </div>
        </div>
</body>

</html>
