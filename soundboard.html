<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soundboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General body and container styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #152238;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }

        /* The main grid container for all buttons */
        .soundboard-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px;
            max-width: 900px;
            width: 100%;
        }

        /* Container for control buttons */
        .control-buttons-container {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Styling for all control buttons */
        .control-button-primary,
        .control-button-secondary,
        .control-button-tertiary {
            padding: 12px 24px;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .control-button-primary {
            background-color: #2b6cb0;
        }

        .control-button-secondary {
            background-color: #e53e3e;
        }

        .control-button-tertiary {
            background-color: #48bb78;
        }

        .control-button-primary:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }

        .control-button-secondary:hover {
            background-color: #f56565;
            transform: translateY(-2px);
        }

        .control-button-tertiary:hover {
            background-color: #68d391;
            transform: translateY(-2px);
        }

        .control-button-primary:active,
        .control-button-secondary:active,
        .control-button-tertiary:active {
            transform: translateY(0);
        }

        /* Container for each button and its controls */
        .sound-button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2A3B53;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            width: 250px;
            height: 250px;
            box-sizing: border-box;
            transition: transform 0.2s ease-in-out;
        }

        .sound-button-container:hover {
            transform: translateY(-5px);
        }

        .sound-button {
            width: 100%;
            height: 120px; /* Increased height to accommodate two lines of text */
            padding: 10px;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            background-color: var(--unplayed-color);
            text-align: center;
            box-sizing: border-box;
        }

        .sound-button:active {
            transform: scale(0.98);
        }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background-color: var(--played-color);
            z-index: 1;
            transition: width 0.1s linear;
        }

        .sound-button-text {
            position: relative;
            z-index: 2;
            /* New properties for 2-line text */
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Clip after 2 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis; /* Use ellipsis instead of clip for better user experience */
            line-height: 1.3em;
            height: 2.6em; /* Set a fixed height for 2 lines */
            
            white-space: normal; /* Allow wrapping */
            text-align: center;
            width: 100%;
            padding: 0;
            margin: 0;
        }

        .volume-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #a0aec0;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
            margin-top: 10px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #63b3ed;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #63b3ed;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            gap: 5px; /* Added gap between buttons */
            align-items: center;
            width: 100%;
            margin-top: 10px;
        }

        .control-button {
            display: flex;
            flex-grow: 1; /* Makes buttons fill space */
            align-items: center;
            justify-content: center;
            padding: 8px;
            background-color: #718096;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
            text-align: center;
        }

        .control-button:hover {
            background-color: #5a677e;
        }

        .control-button svg {
            margin-right: 5px;
            width: 18px;
            height: 18px;
        }

        .file-input {
            display: none;
        }

        .button-name-edit-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            border: none;
            text-align: center;
            padding: 0 10px;
            box-sizing: border-box;
            outline: none;
            z-index: 3;
        }

        .hidden {
            display: none !important;
        }
        
        /* New styling for the combined color/clear controls */
        .color-clear-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            width: 100%;
            justify-content: center;
            align-items: center;
        }

        .color-picker-container {
            position: relative;
            width: 100px;
            height: 40px;
        }

        .color-picker-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8rem;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: 2px solid #a0aec0;
            padding: 0;
            cursor: pointer;
            overflow: hidden;
            box-sizing: border-box;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 992px) {
            .soundboard-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .sound-button-container {
                width: 100%;
                height: auto;
            }
        }
        @media (max-width: 576px) {
            .soundboard-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="soundboard-grid">
        <!-- Buttons will be dynamically generated here -->
    </div>
    
    <div class="control-buttons-container">
        <button id="add-row-btn" class="control-button-primary">Add Row</button>
        <button id="remove-row-btn" class="control-button-secondary">Remove Row</button>
        <button id="download-config-btn" class="control-button-tertiary">Download Config</button>
        <button id="upload-config-btn" class="control-button-tertiary">Upload Config</button>
    </div>
    <input type="file" id="upload-file-input" class="hidden" accept="application/json">

    <script>
        // Get the soundboard grid container
        const soundboardGrid = document.querySelector('.soundboard-grid');
        const addRowBtn = document.getElementById('add-row-btn');
        const removeRowBtn = document.getElementById('remove-row-btn');
        const downloadConfigBtn = document.getElementById('download-config-btn');
        const uploadConfigBtn = document.getElementById('upload-config-btn');
        const uploadFileInput = document.getElementById('upload-file-input');

        let numButtons = parseInt(localStorage.getItem('numButtons')) || 9;

        let audioPlayers = [];

        // IndexedDB variables
        const DB_NAME = 'SoundboardDB';
        const DB_VERSION = 7;
        const SOUNDS_OBJECT_STORE_NAME = 'sounds';
        let db = null;
        let dbPromise = null;

        const buttonAndProgressColorScheme = {
            played: '#FF9800',
            unplayed: '#4CAF50'
        };

        const getDb = () => {
            if (db && db.readyState === 'open') {
                return Promise.resolve(db);
            }
            if (dbPromise) {
                return dbPromise;
            }

            dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(SOUNDS_OBJECT_STORE_NAME)) {
                        db.createObjectStore(SOUNDS_OBJECT_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    db.onversionchange = (event) => {
                        db.close();
                        displayMessageBox("Database updated in another tab. Please refresh this page.");
                        db = null;
                        dbPromise = null;
                    };
                    db.onclose = () => {
                        db = null;
                        dbPromise = null;
                    };
                    db.onerror = (event) => {
                        db = null;
                        dbPromise = null;
                        reject(event.target.error);
                    };
                    resolve(db);
                };
                request.onerror = (event) => {
                    db = null;
                    dbPromise = null;
                    reject(event.target.error);
                };
            });
            return dbPromise;
        };

        /**
         * Saves sound data to IndexedDB.
         * @param {number} index The index of the button (used as the ID).
         * @param {Object} data The audio, name, and color data to save.
         */
        const saveSoundData = (index, data) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const currentDb = await getDb();
                    const transaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                    const request = objectStore.put({
                        id: Number(index),
                        audioArrayBuffer: data.audioArrayBuffer,
                        mimeType: data.mimeType,
                        name: data.name,
                        buttonColor: data.buttonColor || '#4CAF50'
                    });
                    request.onsuccess = () => {};
                    request.onerror = (event) => { reject(event.target.error); };
                    transaction.oncomplete = () => { resolve(); };
                    transaction.onerror = (event) => { reject(event.target.error); };
                } catch (e) {
                    reject(e);
                }
            });
        };

        /**
         * Loads sound data from IndexedDB.
         * @param {number} index The index of the button (used as the ID).
         */
        const loadSoundData = (index) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const currentDb = await getDb();
                    const transaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readonly');
                    const objectStore = transaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                    const request = objectStore.get(Number(index));
                    request.onsuccess = () => {
                        if (request.result && request.result.audioArrayBuffer && request.result.mimeType) {
                            resolve(request.result);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = (event) => { resolve(null); };
                } catch (e) {
                    resolve(null);
                }
            });
        };

        /**
         * Deletes a sound from IndexedDB.
         * @param {number} index The index of the button (used as the ID).
         */
        const deleteSoundData = (index) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const currentDb = await getDb();
                    const transaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                    const request = objectStore.delete(Number(index));
                    request.onsuccess = () => { resolve(); };
                    request.onerror = (event) => { reject(event.target.error); };
                } catch (e) {
                    reject(e);
                }
            });
        };

        const saveVolumeData = (index, volume) => {
            try {
                localStorage.setItem(`soundboard_volume_${index}`, volume);
            } catch (e) {
                console.error("Error saving volume to localStorage:", e);
            }
        };

        const loadVolumeData = (index) => {
            try {
                const volume = localStorage.getItem(`soundboard_volume_${index}`);
                return volume !== null ? parseFloat(volume) : 1.0;
            } catch (e) {
                console.error("Error loading volume from localStorage:", e);
                return 1.0;
            }
        };

        const updateButtonText = (buttonTextSpan, player) => {
            const text = player.baseName;
            buttonTextSpan.textContent = text;
            buttonTextSpan.title = text;
        };

        const displayMessageBox = (message) => {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: #333;
                color: white;
                padding: 20px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
                z-index: 1000;
                font-family: 'Inter', sans-serif;
                text-align: center;
                max-width: 80%;
            `;
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                document.body.removeChild(messageBox);
            }, 3000);
        };
        
        /**
         * Creates all the soundboard buttons based on the current number of buttons.
         * @param {number} count The number of buttons to create.
         */
        const createSoundboardButtons = (count) => {
            soundboardGrid.innerHTML = '';
            audioPlayers = [];

            for (let i = 0; i < count; i++) {
                const container = document.createElement('div');
                container.classList.add('sound-button-container');

                const button = document.createElement('button');
                button.classList.add('sound-button');
                button.dataset.index = i;

                const buttonTextSpan = document.createElement('span');
                buttonTextSpan.classList.add('sound-button-text');
                buttonTextSpan.dataset.index = i;
                button.appendChild(buttonTextSpan);

                const progressOverlay = document.createElement('div');
                progressOverlay.classList.add('progress-overlay');
                button.insertBefore(progressOverlay, buttonTextSpan);

                const buttonNameEditInput = document.createElement('input');
                buttonNameEditInput.type = 'text';
                buttonNameEditInput.classList.add('button-name-edit-input', 'hidden');
                buttonNameEditInput.placeholder = 'Enter name';
                buttonNameEditInput.dataset.index = i;
                button.appendChild(buttonNameEditInput);

                const controlsContainer = document.createElement('div');
                controlsContainer.classList.add('controls-container');

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'audio/*';
                fileInput.id = `file-input-${i}`;
                fileInput.classList.add('file-input');
                fileInput.dataset.index = i;

                const loadButton = document.createElement('button');
                loadButton.classList.add('control-button', 'load-btn');
                loadButton.title = 'Load Sound File';
                loadButton.dataset.index = i;
                loadButton.addEventListener('click', () => fileInput.click());

                const renameButton = document.createElement('button');
                renameButton.classList.add('control-button', 'rename-btn');
                renameButton.title = 'Rename Button';
                renameButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                    <span>Rename</span>
                `;
                renameButton.dataset.index = i;
                renameButton.addEventListener('click', () => {
                    const player = audioPlayers[i];
                    player.isRenaming = true;
                    player.elements.progressOverlay.style.width = '0%';
                    player.elements.buttonTextSpan.classList.add('hidden');
                    player.elements.buttonNameEditInput.classList.remove('hidden');
                    player.elements.buttonNameEditInput.value = player.baseName;
                    player.elements.buttonNameEditInput.focus();
                    player.elements.buttonNameEditInput.select();
                });

                const colorClearControlsContainer = document.createElement('div');
                colorClearControlsContainer.classList.add('color-clear-controls');

                const colorPickerContainer = document.createElement('div');
                colorPickerContainer.classList.add('color-picker-container');
                
                const colorPickerLabel = document.createElement('label');
                colorPickerLabel.classList.add('color-picker-label');
                colorPickerLabel.textContent = 'Color';
                colorPickerLabel.htmlFor = `color-picker-${i}`;

                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.id = `color-picker-${i}`;
                colorPicker.classList.add('color-picker');
                colorPicker.dataset.index = i;
                colorPicker.value = '#4CAF50';
                
                colorPickerContainer.appendChild(colorPickerLabel);
                colorPickerContainer.appendChild(colorPicker);
                
                const clearButton = document.createElement('button');
                clearButton.classList.add('control-button', 'clear-btn');
                clearButton.title = 'Clear Sound';
                clearButton.style.width = '100px';
                clearButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zM18 9l-6 6M12 9l6 6"/>
                    </svg>
                    <span>Clear</span>
                `;
                clearButton.dataset.index = i;
                clearButton.addEventListener('click', async () => {
                    const buttonIndex = clearButton.dataset.index;
                    const player = audioPlayers[buttonIndex];
                    if (player.objectUrl) {
                        URL.revokeObjectURL(player.objectUrl);
                        player.objectUrl = null;
                    }
                    player.audio.pause();
                    player.audio.currentTime = 0;
                    player.audio.src = '';
                    player.fileLoaded = false;
                    player.isPlaying = false;
                    await deleteSoundData(buttonIndex);
                    player.baseName = `Sound ${parseInt(buttonIndex) + 1}`;
                    updateButtonText(player.elements.buttonTextSpan, player);
                    player.elements.progressOverlay.style.width = '0%';
                    loadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14.899V20a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5.101M16 16l-4-4-4 4M12 12v9"/></svg><span>Upload</span>`;
                });

                colorClearControlsContainer.appendChild(colorPickerContainer);
                colorClearControlsContainer.appendChild(clearButton);

                const volumeSlider = document.createElement('input');
                volumeSlider.type = 'range';
                volumeSlider.min = '0';
                volumeSlider.max = '1';
                volumeSlider.step = '0.01';
                volumeSlider.value = loadVolumeData(i);
                volumeSlider.classList.add('volume-slider');
                volumeSlider.dataset.index = i;

                controlsContainer.appendChild(loadButton);
                controlsContainer.appendChild(renameButton);

                container.appendChild(button);
                container.appendChild(volumeSlider);
                container.appendChild(controlsContainer);
                container.appendChild(colorClearControlsContainer);
                container.appendChild(fileInput);
                soundboardGrid.appendChild(container);

                const audio = new Audio();
                audio.volume = volumeSlider.value;

                button.style.setProperty('--played-color', buttonAndProgressColorScheme.played);
                button.style.backgroundColor = colorPicker.value;

                audioPlayers[i] = {
                    audio: audio,
                    isPlaying: false,
                    fileLoaded: false,
                    baseName: `Sound ${i + 1}`,
                    elements: {
                        button: button,
                        buttonTextSpan: buttonTextSpan,
                        buttonNameEditInput: buttonNameEditInput,
                        fileInput: fileInput,
                        progressOverlay: progressOverlay,
                        colorPicker: colorPicker
                    },
                    isRenaming: false,
                    objectUrl: null
                };

                loadSoundData(i).then(data => {
                    if (data) {
                        const blob = new Blob([data.audioArrayBuffer], { type: data.mimeType });
                        const objectUrl = URL.createObjectURL(blob);
                        audioPlayers[i].audio.src = objectUrl;
                        audioPlayers[i].fileLoaded = true;
                        audioPlayers[i].objectUrl = objectUrl;
                        audioPlayers[i].baseName = data.name;
                        loadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14.899V20a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5.101M16 16l-4-4-4 4M12 12v9"/></svg><span>Change</span>`;
                        const savedColor = data.buttonColor || '#4CAF50';
                        button.style.backgroundColor = savedColor;
                        colorPicker.value = savedColor;
                    } else {
                        audioPlayers[i].audio.src = '';
                        audioPlayers[i].fileLoaded = false;
                        loadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14.899V20a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5.101M16 16l-4-4-4 4M12 12v9"/></svg><span>Upload</span>`;
                    }
                    updateButtonText(buttonTextSpan, audioPlayers[i]);
                });

                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) {
                        // User cancelled file selection, do nothing.
                        return;
                    }

                    const buttonIndex = event.target.dataset.index;
                    const player = audioPlayers[buttonIndex];
                    if (player.objectUrl) {
                        URL.revokeObjectURL(player.objectUrl);
                        player.objectUrl = null;
                    }
                    
                    if (!file.type.startsWith('audio/')) {
                        displayMessageBox('Please select an audio file.');
                        event.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const arrayBuffer = e.target.result;
                        const mimeType = file.type;
                        const blob = new Blob([arrayBuffer], { type: mimeType });
                        const objectUrl = URL.createObjectURL(blob);
                        player.audio.src = objectUrl;
                        player.fileLoaded = true;
                        player.objectUrl = objectUrl;
                        loadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14.899V20a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5.101M16 16l-4-4-4 4M12 12v9"/></svg><span>Change</span>`;
                        const newFileName = file.name.split('.').slice(0, -1).join('.');
                        player.baseName = newFileName || file.name;
                        saveSoundData(buttonIndex, {
                            audioArrayBuffer: arrayBuffer,
                            mimeType: mimeType,
                            name: player.baseName,
                            buttonColor: player.elements.colorPicker.value
                        });
                        updateButtonText(player.elements.buttonTextSpan, player);
                    };
                    reader.readAsArrayBuffer(file);
                });

                button.addEventListener('click', (event) => {
                    const buttonIndex = event.currentTarget.dataset.index;
                    const player = audioPlayers[buttonIndex];
                    if (player.isRenaming) { return; }
                    if (!player.fileLoaded) {
                        displayMessageBox('Please load a sound file first!');
                        return;
                    }
                    if (player.isPlaying) {
                        player.audio.pause();
                        player.audio.currentTime = 0;
                        player.isPlaying = false;
                        player.elements.progressOverlay.style.width = '0%';
                    } else {
                        player.audio.play().catch(e => console.error("Error playing sound:", e));
                        player.isPlaying = true;
                    }
                });

                volumeSlider.addEventListener('input', (event) => {
                    const buttonIndex = event.target.dataset.index;
                    const newVolume = parseFloat(event.target.value);
                    audioPlayers[buttonIndex].audio.volume = newVolume;
                    saveVolumeData(buttonIndex, newVolume);
                });
                
                colorPicker.addEventListener('change', async (event) => {
                    const buttonIndex = event.target.dataset.index;
                    const newColor = event.target.value;
                    const player = audioPlayers[buttonIndex];
                    player.elements.button.style.backgroundColor = newColor;
                    try {
                        const data = await loadSoundData(buttonIndex);
                        if (data) {
                            data.buttonColor = newColor;
                            await saveSoundData(buttonIndex, data);
                        }
                    } catch (e) {
                        console.error("Failed to save button color:", e);
                    }
                });

                audio.addEventListener('ended', () => {
                    const buttonIndex = Array.from(soundboardGrid.children).indexOf(container);
                    if (audioPlayers[buttonIndex]) {
                        audioPlayers[buttonIndex].isPlaying = false;
                        audioPlayers[buttonIndex].elements.progressOverlay.style.width = '0%';
                    }
                });

                audio.addEventListener('timeupdate', () => {
                    const buttonIndex = Array.from(soundboardGrid.children).indexOf(container);
                    const player = audioPlayers[buttonIndex];
                    if (player && player.audio.duration > 0 && player.isPlaying && !player.isRenaming) {
                        const progress = (player.audio.currentTime / player.audio.duration) * 100;
                        player.elements.progressOverlay.style.width = `${progress}%`;
                    }
                });

                buttonNameEditInput.addEventListener('blur', (event) => {
                    const buttonIndex = event.target.dataset.index;
                    const player = audioPlayers[buttonIndex];
                    const newName = event.target.value.trim();
                    if (newName) {
                        player.baseName = newName;
                        loadSoundData(buttonIndex).then(data => {
                            if (data) {
                                data.name = newName;
                                saveSoundData(buttonIndex, data);
                            }
                        });
                    } else {
                        player.baseName = `Sound ${parseInt(buttonIndex) + 1}`;
                         loadSoundData(buttonIndex).then(data => {
                            if (data) {
                                data.name = player.baseName;
                                saveSoundData(buttonIndex, data);
                            }
                        });
                    }
                    player.elements.buttonTextSpan.textContent = player.baseName;
                    player.elements.buttonTextSpan.classList.remove('hidden');
                    player.elements.buttonNameEditInput.classList.add('hidden');
                    updateButtonText(player.elements.buttonTextSpan, player);
                    setTimeout(() => {
                        player.isRenaming = false;
                        if (player.isPlaying && player.audio.duration > 0) {
                            const progress = (player.audio.currentTime / player.audio.duration) * 100;
                            player.elements.progressOverlay.style.width = `${progress}%`;
                        }
                    }, 50);
                });

                buttonNameEditInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        event.target.blur();
                    }
                });
            }
        };

        const downloadConfig = async () => {
            try {
                const currentDb = await getDb();
                const transaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                const allDataRequest = objectStore.getAll();
                
                allDataRequest.onsuccess = () => {
                    const allData = allDataRequest.result;
                    const exportableData = allData.map(item => {
                        const { audioArrayBuffer, ...rest } = item;
                        return {
                            ...rest,
                            audioBase64: btoa(String.fromCharCode(...new Uint8Array(audioArrayBuffer)))
                        };
                    });
                    const config = {
                        numButtons: numButtons,
                        sounds: exportableData
                    };
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "soundboard_config.json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    displayMessageBox('Soundboard configuration downloaded!');
                };
                allDataRequest.onerror = () => {
                    displayMessageBox('Failed to read data from IndexedDB.');
                };
            } catch (error) {
                console.error("Download failed:", error);
                displayMessageBox('An error occurred during download.');
            }
        };

        const uploadConfig = () => {
            uploadFileInput.click();
        };

        const handleUploadFile = (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    if (!config.sounds || !Array.isArray(config.sounds)) {
                        throw new Error('Invalid configuration file.');
                    }
                    
                    // Clear existing data before loading new
                    const currentDb = await getDb();
                    const clearTransaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readwrite');
                    const clearObjectStore = clearTransaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                    clearObjectStore.clear();

                    // Load new data
                    const transaction = currentDb.transaction([SOUNDS_OBJECT_STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(SOUNDS_OBJECT_STORE_NAME);
                    config.sounds.forEach(sound => {
                        if (sound.audioBase64) {
                            const binaryString = atob(sound.audioBase64);
                            const len = binaryString.length;
                            const bytes = new Uint8Array(len);
                            for (let i = 0; i < len; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            const data = {
                                id: sound.id,
                                audioArrayBuffer: bytes.buffer,
                                mimeType: sound.mimeType,
                                name: sound.name,
                                buttonColor: sound.buttonColor
                            };
                            objectStore.put(data);
                        }
                    });

                    await new Promise(resolve => transaction.oncomplete = resolve);
                    
                    // Update the number of buttons and refresh the UI
                    numButtons = config.numButtons || 9;
                    localStorage.setItem('numButtons', numButtons);
                    createSoundboardButtons(numButtons);
                    displayMessageBox('Soundboard configuration uploaded successfully!');
                } catch (error) {
                    console.error("Upload failed:", error);
                    displayMessageBox(`Error uploading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
        };

        document.addEventListener('DOMContentLoaded', async () => {
            if (!window.indexedDB) {
                displayMessageBox("Your browser doesn't support IndexedDB. Sound persistence will not work.");
                return;
            }
            try {
                await getDb();
                createSoundboardButtons(numButtons);
            } catch (error) {
                console.error("Failed to initialize soundboard due to IndexedDB error:", error);
                displayMessageBox("Could not initialize soundboard. Please check browser console for details.");
            }
        });

        addRowBtn.addEventListener('click', () => {
            numButtons += 3;
            localStorage.setItem('numButtons', numButtons);
            createSoundboardButtons(numButtons);
        });

        removeRowBtn.addEventListener('click', async () => {
            if (numButtons > 3) {
                const oldNumButtons = numButtons;
                numButtons -= 3;
                localStorage.setItem('numButtons', numButtons);
                
                // CRITICAL FIX: Delete the old button data from the database
                for (let i = numButtons; i < oldNumButtons; i++) {
                    await deleteSoundData(i);
                }
                
                createSoundboardButtons(numButtons);
            } else {
                displayMessageBox("You must have at least one row of three buttons.");
            }
        });

        downloadConfigBtn.addEventListener('click', downloadConfig);
        uploadConfigBtn.addEventListener('click', uploadConfig);
        uploadFileInput.addEventListener('change', handleUploadFile);

        window.addEventListener('beforeunload', () => {
            audioPlayers.forEach(player => {
                if (player.objectUrl) {
                    URL.revokeObjectURL(player.objectUrl);
                }
            });
            if (db && db.readyState === 'open') {
                db.close();
            }
        });
    </script>
</body>
</html>
