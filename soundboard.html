<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Soundboard | B&M Really Simple Soundboard</title>
    <style>
        /* Define a color palette using CSS variables */
        :root {
            --background-color: #f7fafc;
            /* Not-Quite White */
            --panel-color: #e3f0ff;
            /* Powdered Bug */
            --accent-color: #3bb273;
            /* Mossy Green */
            --highlight-color: #ff914d;
            /* Chewy Orange */
            --primary-color: #234e70;
            /* Bug Blue */
            --secondary-color: #cce0ec;

            --font-family-primary: 'Wellfleet', sans-serif;
        }

        body {
            font-family: var(--font-family-primary);
            background-color: var(--background-color);
            color: var(--primary-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }

        button {
            font-family: var(--font-family-primary);
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .global-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            background-color: var(--panel-color);
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        .global-controls button,
        .modal button,
        .confirm-modal button {
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            margin-bottom: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .global-controls button:hover,
        .modal button:hover,
        .confirm-modal button:hover {
            filter: brightness(50%);
        }

        button.danger,
        .confirm-modal button.danger {

            padding: 0.75rem 1.5rem;
            margin-bottom: 0.5rem;
            background-color: red;
            color: white;
        }

        .global-controls button.danger:hover,
        .confirm-modal button.danger:hover {
            filter: brightness(50%);
        }

        .soundboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .soundboard-grid.rearrange-mode {
            cursor: grab;
        }

        .sound-card {
            background-color: var(--panel-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-self: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .soundboard-grid.rearrange-mode .sound-card:hover {
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .soundboard-grid.rearrange-mode .sound-card {
            transform: rotate(2deg);
            border: 2px solid var(--highlight-color);
            cursor: grab;
        }

        .sound-card.dragging {
            opacity: 0.5;
        }

        .soundboard-grid.rearrange-mode .sound-card.drag-over {
            border: 2px dashed var(--highlight-color);
            transform: scale(1.05);
            transition: transform 0.2s ease;
        }

        .sound-button {
            position: relative;
            width: 100%;
            height: 100px;
            background-color: var(--accent-color);
            color: var(--primary-color);
            font-size: 1.25rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            overflow: hidden;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .soundboard-grid.rearrange-mode .sound-button {
            cursor: grab;
        }

        .soundboard-grid.rearrange-mode .sound-button:hover {
            opacity: 1;
        }

        .sound-button:hover {
            opacity: 0.9;
        }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            transition: width 0.1s linear;
        }

        .button-text {
            position: relative;
            z-index: 1;
            font-family: var(--font-family-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sound-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .slider-group label {
            width: 60px;
            font-size: 0.875rem;
            color: var(--primary-color);
        }

        .sound-controls input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: #a8d5e5;
            outline: none;
        }

        .sound-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        .sound-controls input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        .sound-controls input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        .sound-controls input[type="range"]::-moz-range-thumb:active {
            cursor: grabbing;
        }

        .settings-triangle-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            cursor: pointer;
            width: 0;
            height: 0;
            border-bottom: 40px solid var(--highlight-color);
            border-left: 40px solid transparent;
            z-index: 2;
        }

        .settings-triangle-btn svg {
            position: absolute;
            top: -30px;
            left: 10px;
            z-index: 3;
            width: 20px;
            height: 20px;
            color: #ffffff;
        }

        .modal,
        .confirm-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            align-items: center;
            justify-content: center;
        }

        .modal-content,
        .confirm-modal-content {
            background-color: var(--panel-color);
            margin: 5% auto;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            max-height: 75%;
            overflow-y: auto;
        }

        .confirm-modal button.confirm-yes-btn {
            /* yeah I know this is shitty */
            background-color: var(--accent-color);
            color: #FFFFFF;
        }

        .confirm-modal button.confirm-no-btn {
            background-color: var(--highlight-color);
            color: auto;
        }

        .confirm-modal-content {
            text-align: center;
            padding: 2rem;
            max-width: 400px;
        }

        .modal-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-section {
            margin-bottom: 1.5rem;
        }

        .modal-section h3 {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.25rem;
            color: var(--primary-color);
        }

        .modal-section input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            background-color: var(--background-color);
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }

        .modal-section label {
            display: block;
            margin-bottom: 0.5rem;
        }

        .title-and-color {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #button-color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            padding: 0;
            border: 2px solid var(--primary-color);
            background-color: transparent;
            /* The actual color comes from the swatch inside */
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        #button-color-picker:hover {
            border-color: var(--highlight-color);
        }

        /* These pseudo-elements style the color preview part of the input */
        #button-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #button-color-picker::-webkit-color-swatch {
            border: none;
        }

        #button-color-picker::-moz-color-swatch {
            border: none;
        }

        .hidden {
            display: none;
        }

        .file-list {
            list-style: none;
            max-height: 40vh;
            overflow-y: auto;
            padding: 0;
            list-style-type: none;
        }

        .file-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--background-color);
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid var(--panel-color);
        }

        .file-list button {
            background-color: var(--highlight-color);
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .file-list button:hover {
            filter: brightness(50%);
        }

        .file-input-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .file-input-container label {
            flex-grow: 1;
            background-color: var(--accent-color);
            color: var(--background-color);
            padding: 0.75rem 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .file-input-container label:hover {
            filter: brightness(50%);
        }

        .modal-actions-row {
            display: flex;
            justify-content: space-between;

        }

        .modal-checkbox-group {
            display: flex;
            gap: 1.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .modal-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
            color: var(--primary-color);
        }

        .modal-checkbox-group input[type="checkbox"] {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid var(--primary-color);
            cursor: pointer;
            position: relative;
        }

        .modal-checkbox-group input[type="checkbox"]:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .modal-checkbox-group input[type="checkbox"]:checked::after {
            content: '✔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--background-color);
            font-size: 1rem;
        }

        .modal-checkbox-group h4 {
            margin: 0;
            font-size: 1.1rem;
            /* Matches other h3/h4 elements */
            font-weight: bold;
        }

        /* New styles for the Database Manager modal */
        #db-manager-modal .modal-content {
            max-width: 500px;
        }

        #db-stats-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            font-size: 1.1rem;
        }

        #db-stats-container p {
            margin: 0;
            padding: 0.5rem;
            background-color: var(--background-color);
            border: 1px solid var(--secondary-color);
        }

        #db-file-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #db-file-list li {
            background-color: var(--panel-color);
            padding: 0.75rem;
            border-bottom: 1px solid var(--panel-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #db-file-list li:last-child {
            border-bottom: none;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--panel-color);
        }

        .stat-line:last-of-type {
            border-bottom: none;
        }

        .spacer {
            margin: 0 1rem;
        }

        #soundboard-title {
            text-align: center;
            cursor: pointer;
            padding: 1rem;
            transition: background-color 0.3s ease;
        }

        #soundboard-title:hover,
        #soundboard-title:focus {
            background-color: var(--panel-color);
            outline: none;
        }

        #control-card-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            padding-top: 0.5rem;
        }

        /* New rule for the rearrange button */
        .span-two-columns {
            /* Span across two grid columns */
            grid-column: span 2;
        }

        #control-card-actions button {

            font-family: var(--font-family-primary);
            padding: 0.5rem;
            font-size: 1rem;
            text-align: center;
            background-color: var(--accent-color);
            color: var(--background-color);
            border-color: var(--highlight-color);
            border-style: none;
        }

        #control-card-actions button:hover {
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        /* New styles for the Cosmetics modal */
        .color-picker-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .color-picker-group input[type="color"] {
            width: 2rem;
            height: 2rem;
            border: none;
            cursor: pointer;
        }

        .color-palette-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 1rem;
        }

        .color-box {
            position: relative;
            width: 100%;
            padding-top: 100%;
            /* Creates a square aspect ratio */
            display: flex;
            flex-direction: column-reverse;
            justify-content: flex-end;
            align-items: center;
        }

        .color-box input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 0;
            border: none;
            cursor: pointer;
            z-index: 1;
            /* Puts the color picker behind the label */
        }

        .color-box label {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            text-align: center;
            padding: 0.25rem;
            font-size: 0.75rem;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent background */
            color: white;
            z-index: 2;
            /* Puts the label in front of the color picker */
        }

        /* Styles for the timer card */
        .timer-card {
            background-color: var(--panel-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-self: start;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .timer-display {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            padding: 0.5rem;
            background-color: var(--background-color);
            color: var(--primary-color);
            border: 2px solid var(--secondary-color);
        }

        .timer-display.running {
            color: var(--accent-color);
        }

        .timer-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .timer-controls .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-controls .slider-group label {
            width: 60px;
            font-size: 0.875rem;
            color: var(--primary-color);
            text-align: right;
        }

        .timer-controls .slider-group span {
            min-width: 25px;
            text-align: center;
        }

        .timer-controls input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 4px;
            background: #a8d5e5;
            outline: none;
        }

        .timer-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        .timer-controls input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
        }

        .timer-controls .timer-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .timer-controls .timer-buttons button {
            flex-grow: 1;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .timer-controls .timer-buttons button:hover {
            filter: brightness(50%);
        }

        .timer-controls .timer-buttons .start-timer-btn {
            background-color: var(--accent-color);
            color: white;
        }

        .timer-controls .timer-buttons .stop-timer-btn {
            background-color: var(--highlight-color);
            color: white;
        }

        .timer-options-container.hidden-options {
            display: none;
        }

        .confirm-modal-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            color: var(--background-color);
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .add-timer-btn:hover {
            filter: brightness(50%);
        }

        .timer-options-container.hidden-options {
            display: none;
        }

        .timer-title {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
            cursor: default;
            border: 2px solid transparent;
            /* invisible border for focus */
            transition: border-color 0.2s ease;
        }

        .timer-title[contenteditable="true"] {
            background-color: var(--background-color);
            border-color: var(--highlight-color);
            outline: none;
            cursor: text;
        }

        .timer-options-toggle {
            user-select: none;
        }

        /* Style the new remove timer button */
        .remove-timer-btn {
            width: 100%;
            margin-bottom: 1rem;
            font-weight: bold;
            padding: 0.75rem;
            margin-top: 1rem;
            background-color: var(--highlight-color);
            color: white;
        }

        .timer-sound-select {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-sound-select label {
            flex-shrink: 0;
            /* Prevents the label from shrinking */
        }

        .timer-sound-select select {
            width: 100%;
            /* This is the key: it allows the dropdown to shrink
       smaller than its own content, preventing overflow. */
            min-width: 0;
        }

        /* UPDATED Styles for the compact Notepad Card */
        .notepad-card {
            display: flex;
            flex-direction: column;
            padding: 0.5rem;
            /* Reduced padding on the card itself */
            align-self: stretch;
        }

        .notepad-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
        }


        .notepad-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--secondary-color);
            flex-shrink: 0;
            /* Prevent tabs from shrinking */
        }

        .notepad-tab {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border: 1px solid var(--secondary-color);
            background-color: var(--background-color);
            padding: 0.1rem 0.4rem;
            /* Smaller tabs */
            cursor: pointer;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .notepad-tab-title {
            cursor: pointer;
            outline: none;
            font-size: 1rem;
            white-space: nowrap;
            /* Prevent title from wrapping */
            user-select: none;
        }

        .notepad-tab-title[contenteditable="true"] {
            cursor: text;
            user-select: text
        }

        .add-page-btn {
            border: 1px solid var(--secondary-color);
            background-color: var(--background-color);
            padding: 0.1rem 0.4rem;
            /* Smaller button */
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            border-radius: 4px;
        }

        .notepad-tab.active {
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            border-color: var(--accent-color);
            cursor: text;
        }

        .notepad-tab.active {
            color: white;
        }

        .delete-page-btn {
            color: darkred;
            font-weight: bold;
            font-size: 0.9rem;
            padding: 2px 4px;
            border-radius: 50%;
            line-height: 1;
        }

        .delete-page-btn:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .notepad-content {
            flex-grow: 1;
            width: 100%;
            border: none;
            background-color: var(--background-color);
            padding: 0.5rem;
            font-family: sans-serif;
            font-size: 1rem;
            color: var(--primary-color);
            resize: vertical;
            box-sizing: border-box;
        }

        .notepad-content:focus {
            outline: 1px solid var(--highlight-color);
        }

        
        .help-accordion {
            width: 100%;
        }

        .accordion-item {
            border-bottom: 1px solid var(--secondary-color);
        }

        .accordion-item:last-of-type {
            border-bottom: none;
        }

        .accordion-header {
            width: 100%;
            background-color: transparent;
            border: none;
            text-align: left;

            padding: 1rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            color: var(--primary-color);
        }

        .accordion-header::after {
            content: '+';
            position: absolute;
            right: 1rem;
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        .accordion-header.active::after {
            transform: rotate(45deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            background-color: var(--background-color);
            padding: 0 1rem;
            white-space: pre-line;
        }

        .accordion-content p, .accordion-content ul {
            margin-block-start: 0;
        }

        .accordion-content.active {
            max-height: 200px;
            /* Set a max height for the open panel */
            overflow-y: auto;
            /* Allow content to scroll if it's too long */
            padding: 1rem 1rem;
        }

        .accordion-content ul {
            padding-left: 1.5rem;
        }

        .accordion-content li {
            margin-bottom: 0.5rem;
        }

        #help-bug-btn {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 50;
            /* Above content, below modals */
            width: 50px;
            height: 50px;
            border-radius: 0;
            padding: 8px;
            cursor: pointer;
            background: transparent;
            border: none;
        }

        .bug-moving {
            animation: skitter 8s ease-in-out infinite;
        }

        #help-bug-btn svg {
            width: 100%;
            height: 100%;
        }

        @keyframes skitter {
  /* Start and end in the original position */
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  
  /* Quick dash and turn */
  4% { transform: translate(15px, 5px) rotate(25deg); }
  /* Pause */
  8% { transform: translate(15px, 5px) rotate(25deg); }
  
  /* Fast dash back across the screen */
  15% { transform: translate(-10px, -10px) rotate(-15deg); }
  
  /* A small, quick jitter */
  18% { transform: translate(-8px, -12px) rotate(-20deg); }
  20% { transform: translate(-10px, -10px) rotate(-15deg); }
  
  /* Another dash and a longer pause */
  28% { transform: translate(20px, -5px) rotate(40deg); }
  35% { transform: translate(20px, -5px) rotate(40deg); }
  
  /* A long, slow drift down */
  50% { transform: translate(-15px, 20px) rotate(-30deg); }
  
  /* Pause again */
  60% { transform: translate(-15px, 20px) rotate(-30deg); }

  /* Jitter in place */
  63% { transform: translate(-12px, 22px) rotate(-35deg); }
  65% { transform: translate(-15px, 20px) rotate(-30deg); }

  /* Final quick dash before returning home */
  75% { transform: translate(10px, 10px) rotate(15deg); }
  85% { transform: translate(10px, 10px) rotate(15deg); }

  /* Settle back to origin */
  95% { transform: translate(2px, 2px) rotate(5deg); }
}
    </style>
</head>

<body>
    <div class="container">
        <h1 id="soundboard-title" contenteditable="true">Bug & Moss Really Simple Soundboard</h1>

        <div id="soundboard-grid" class="soundboard-grid">
        </div>

    </div>

    <template id="notepad-card-template">
        <div class="sound-card special-function-card notepad-card">
            <div class="notepad-tabs">
                <button class="add-page-btn">+</button>
            </div>
            <textarea class="notepad-content" placeholder="Type your notes here..."></textarea>
        </div>
    </template>

    <template id="timer-card-template">
        <div class="sound-card special-function-card timer-card">
            <div class="timer-title" contenteditable="false">New Timer</div>
            <div class="timer-display">00:00</div>
            <div class="timer-controls">
                <div class="timer-options-toggle">
                    <label>
                        <input type="checkbox" class="hide-timer-options-toggle" value="false">
                        Lock Timer Settings
                    </label>
                </div>
                <div class="timer-options-container">
                    <div class="slider-group">
                        <label>Minutes:</label>
                        <input type="range" class="timer-minutes-range" min="0" max="60" value="0">
                        <span class="timer-minutes-value">0</span>
                    </div>
                    <div class="slider-group">
                        <label>Seconds:</label>
                        <input type="range" class="timer-seconds-range" min="0" max="59" value="0">
                        <span class="timer-seconds-value">0</span>
                    </div>
                    <div class="timer-sound-select">
                        <label>Start with:</label>
                        <select class="timer-start-sound"></select>
                    </div>
                    <div class="timer-sound-select">
                        <label>End with:</label>
                        <select class="timer-end-sound"></select>
                    </div>
                    <button class="remove-timer-btn danger">Remove Timer</button>
                </div>
                <div class="timer-buttons">
                    <button class="start-timer-btn">Start</button>
                    <button class="stop-timer-btn">Reset</button>
                </div>
            </div>
        </div>
    </template>

    <div id="control-card" class="sound-card special-function-card" data-card-type="control" data-card-id="control-card"
        style="display: none;">
        <div id="control-card-actions">
            <button id="add-btn-plus" title="Add a new button" class="span-two-columns">Add Sound</button>
            <button id="add-timer-btn">Add Timer</button>
            <button id="add-notepad-btn">Add Note</button>
            <button id="rearrange-mode-btn" style="background-color:var(--highlight-color)"
                class="span-two-columns">Rearrange</button>
            <button id="upload-config-btn">Upload</button>
            <button id="download-config-btn">Download</button>
            <button id="switch-board-btn" class="span-two-columns" style="background-color:var(--primary-color);">Switch
                Board</button>
            <button id="cosmetics-btn">Cosmetics</button>
            <button id="db-manager-btn">Storage</button>

        </div>
    </div>


    <input type="file" id="upload-config-input" accept="application/json" style="display: none;">

    <div id="confirm-modal" class="confirm-modal">
        <div class="confirm-modal-content">
            <p id="confirm-modal-message"></p>
            <div class="confirm-modal-actions">
                <button id="confirm-yes-btn" class="confirm-yes-btn">Yes</button>
                <button id="confirm-no-btn" class="confirm-no-btn">No</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div id="modal-content" class="modal-content">


            <div class="modal-section">
                <h3>Button Settings</h3>
                <div class="title-and-color">
                    <input type="color" id="button-color-picker">
                    <input type="text" style="font-size: 1rem;" id="button-name-input">
                </div>
            </div>


            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <label>
                        <input type="checkbox" id="shuffle-checkbox">
                        Random
                    </label>
                    <label>
                        <input type="checkbox" id="autoplay-checkbox">
                        Autoplay
                    </label>
                    <label>
                        <input type="checkbox" id="priority-checkbox">
                        Priority
                    </label>
                    <label>
                        <input type="checkbox" id="loop-checkbox">
                        Loop
                    </label>

                </div>
            </div>

            <div class="modal-section">
                <h3>Audio Files</h3>
                <div class="file-input-container">
                    <label for="add-file-input" class="file-input-label">Add Audio File</label>
                    <input type="file" id="add-file-input" accept="audio/*" multiple style="display: none;">
                </div>
                <ul id="file-list" class="file-list"></ul>
                <div class="modal-actions-row">
                    <button id="remove-button-modal" class="danger">Delete Button</button>
                    <button id="clear-files-btn"
                        style="margin-left:auto; background-color:var(--highlight-color); color:var(--primary-color)">Clear
                        All</button>
                </div>
            </div>



        </div>
    </div>



    <div id="db-manager-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Local Database Manager</h3>
            </div>
            <div class="modal-section">
                <div id="db-stats-container">
                    <div class="stat-line">
                        <span>Total Buttons:</span> <span id="db-button-count">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>IndexedDB Usage:</span> <span id="db-usage">Calculating...</span>
                    </div>
                    <div class="stat-line">
                        <span>Available Quota:</span> <span id="db-quota">Calculating...</span>
                    </div>
                </div>
            </div>
            <div class="modal-section">
                <h3>Stored Sounds</h3>
                <ul id="db-file-list">
                    <li><small>No sounds found.</small></li>
                </ul>
            </div>
            <div class="modal-section">
                <div class="modal-checkbox-group">
                    <input type="checkbox" id="persistent-storage-checkbox">
                    <h4>Storage Durability</h4>
                </div>
                <small>Recommended for offline use. Your browser may ask for permission.</small>
            </div>

            <div class="modal-section">
                <button id="clear-database-btn" class="danger">Delete Everything & Try Again</button>
            </div>
        </div>
    </div>

    <div id="cosmetics-modal" class="modal">
        <div class="modal-content">
            <div class="modal-section">
                <h4>Font Selection</h4>
                <label for="font-input">Enter a font name:</label>
                <input type="text" id="font-input" placeholder="Wellfleet">
                <small>You can use any font from <a href="https://fonts.google.com/" target="_blank">Google
                        Fonts</a>.</small>
            </div>
            <div class="modal-section">
                <h4>Color Palette</h4>
                <div class="color-palette-grid">

                    <div class="color-picker-group color-box">
                        <input type="color" id="primary-color-picker" data-css-var="--primary-color">
                        <label for="primary-color-picker">Dark Text</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="secondary-color-picker" data-css-var="--secondary-color">
                        <label for="secondary-color-picker">Light Text</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="panel-color-picker" data-css-var="--panel-color">
                        <label for="panel-color-picker">Panel</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="background-color-picker" data-css-var="--background-color">
                        <label for="background-color-picker">Background</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="accent-color-picker" data-css-var="--accent-color">
                        <label for="accent-color-picker">Accent</label>
                    </div>
                    <div class="color-picker-group color-box">
                        <input type="color" id="highlight-color-picker" data-css-var="--highlight-color">
                        <label for="highlight-color-picker">Highlight</label>
                    </div>
                    <button id="delete-cosmetics-key-btn" class="danger">Reset Appearance</button>
                </div>
            </div>
        </div>

    </div>
    <div id="board-switcher-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Switch Soundboard</h3>
            </div>
            <div class="modal-section">
                <ul id="board-list" class="file-list">
                </ul>
            </div>

            <div class="modal-section" style="border-top: 1px solid var(--secondary-color); padding-top: 1.5rem;">
                <h4>Create New Board</h4>
                <div class="title-and-color">
                    <input type="text" id="new-board-name-input" placeholder="New board name...">
                    <button id="create-new-board-btn">Create</button>
                </div>
            </div>

        </div>
    </div>
    <script>

        function formatIdAsTitle(id) {
            if (!id) return '';
            return id
                .replace(/-/g, ' ') // my-gaming-sounds -> my gaming sounds
                .split(' ')          // -> ['my', 'gaming', 'sounds']
                .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // -> ['My', 'Gaming', 'Sounds']
                .join(' ');          // -> "My Gaming Sounds"
        }

        function slugify(text) {
            return text.toString().toLowerCase().trim()
                .replace(/\s+/g, '-')           // Replace spaces with -
                .replace(/[^\w\-]+/g, '')       // Remove all non-word chars except -
                .replace(/\-\-+/g, '-');          // Replace multiple - with single -
        }

        function loadGoogleFonts(fontNames) {
            if (!fontNames || fontNames.length === 0) {
                console.warn("No font names provided to loadGoogleFonts.");
                return;
            }
            const formattedNames = fontNames.map(name => name.replace(/\s+/g, '+'));
            const fontUrl = `https://fonts.googleapis.com/css?family=${formattedNames.join('|')}&display=swap`;
            const link = document.createElement('link');
            link.href = fontUrl;
            link.rel = 'stylesheet';
            document.head.appendChild(link);
        };

        function getContrastColor(hexColor) {
            // 1. Remove '#' and convert hex to R, G, B numbers
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            // 2. Calculate the luminance using the standard formula
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // 3. Return dark or light color based on a threshold
            return luminance > 0.5 ? 'var(--primary-color)' : 'var(--secondary-color)'; // Returns dark for light backgrounds, and vice-versa
        }

        document.addEventListener('DOMContentLoaded', () => {

            function getRandom(min, max) {
                const minCeiled = Math.ceil(min);
                const maxFloored = Math.floor(max);
                let value = Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
                return value // The maximum is exclusive and the minimum is inclusive
            }

            function randomButNot(min, max, notThis) {
                const minCeiled = Math.ceil(min);
                const maxFloored = Math.floor(max);

                // If the range of possible numbers is 1 or less,
                // we might get an infinite loop.
                if (maxFloored - minCeiled <= 1) {
                    // If the only possible value is the one we're trying to avoid,
                    // we have no choice but to return it (or a default).
                    if (minCeiled === notThis) {
                        // This scenario should be handled based on desired behavior.
                        // Returning `notThis` is one option, returning null is another.
                        return notThis;
                    }
                    return minCeiled;
                }

                let value;
                do {
                    value = getRandom(min, max);
                } while (value === notThis);
                return value;
            }


            // ====================================================================
            // SECTION: Audio Player Class
            // I'm so fucking tired ddude
            // ====================================================================

            class AudioPlayer {
                constructor(audioElement) {
                    this.audio = audioElement || new Audio();
                    this.isPlaying = false;
                    this.duckAmount = 0.4;
                    this.fadeSpeed = 200;
                    this.playback = {
                        currentFileIndex: 0,
                    };
                    this.progressOverlay = null; // A reference to the progress bar element
                    this.setupListeners();
                }

                setupListeners() {
                    this.audio.onplaying = () => this.isPlaying = true;
                    this.audio.onpause = () => {
                        this.isPlaying = false;
                        this.resetProgress();
                    };
                    this.audio.onended = () => {
                        // This is for local cleanup ONLY
                        this.isPlaying = false;
                        this.resetProgress();
                        this.audio.currentTime = 0; // Rewind the audio element
                    };
                    this.audio.ontimeupdate = () => this.updateProgress();
                }

                updateProgress() {
                    if (this.progressOverlay && this.audio.duration > 0) {
                        const progress = (this.audio.currentTime / this.audio.duration) * 100;
                        this.progressOverlay.style.width = `${progress}%`;
                    }
                }

                resetProgress() {
                    if (this.progressOverlay) {
                        this.progressOverlay.style.width = '0%';
                    }
                }

                // A method to properly clean up the audio object and its URL
                cleanup() {
                    this.audio.pause();
                    if (this.audio.src) {
                        URL.revokeObjectURL(this.audio.src);
                        this.audio.src = '';
                        this.audio.load();
                    }
                    this.isPlaying = false;
                    this.resetProgress();
                }
            }

            class BoardManager {
                // A helper to temporarily open a connection to the default DB
                static _getDefaultDB() {
                    const db = new SoundboardDB('default');
                    return db.openDB().then(() => db);
                }

                // Gets the list of board IDs from the default DB
                static async getBoardList() {
                    const defaultDB = await this._getDefaultDB();
                    const listData = await defaultDB.get('board-list');
                    return listData ? listData.ids : [];
                }

                // Adds a new board ID to the list in the default DB
                static async addBoardId(boardId) {
                    const defaultDB = await this._getDefaultDB();
                    const boardIds = await this.getBoardList();
                    if (!boardIds.includes(boardId)) {
                        boardIds.push(boardId);
                        await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                    }
                }

                static async saveBoardList(boardIds) {
                    const defaultDB = await this._getDefaultDB();
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }

                static async removeBoardId(boardIdToRemove) {
                    const defaultDB = await this._getDefaultDB();
                    let boardIds = await this.getBoardList();
                    // Filter the list to exclude the board we're removing
                    boardIds = boardIds.filter(id => id !== boardIdToRemove);
                    // Save the new, shorter list back to the database
                    await defaultDB.save('board-list', { id: 'board-list', ids: boardIds });
                }
            }


            // ====================================================================
            // SECTION: Database Manager Class
            // ====================================================================

            class SoundboardDB {
                constructor(boardIdOverride = null) {
                    let boardId;
                    // If a boardId is explicitly passed, use it. Otherwise, get it from the URL.
                    if (boardIdOverride) {
                        boardId = boardIdOverride;
                    } else {
                        const urlParams = new URLSearchParams(window.location.search);
                        boardId = urlParams.get('board') || 'default';

                        // We'll move the "guest book" logic to be called after the constructor.
                    }

                    this.DB_NAME = `BugAndMossSoundboardDB_${boardId}`;
                    this.DB_VERSION = 9; // Increment version for this structural change idea
                    this.SOUNDS_STORE = 'sounds';
                    this.CONFIG_STORE = 'config';
                    this.CONFIG_KEY = 'global-config';
                    this.COSMETICS_KEY = 'cosmetics-config';
                    this.db = null;
                }
                async openDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                        request.onupgradeneeded = event => {
                            this.db = event.target.result;
                            if (!this.db.objectStoreNames.contains(this.SOUNDS_STORE)) {
                                this.db.createObjectStore(this.SOUNDS_STORE, {
                                    keyPath: 'id'
                                });
                            }
                            if (!this.db.objectStoreNames.contains(this.CONFIG_STORE)) {
                                this.db.createObjectStore(this.CONFIG_STORE, {
                                    keyPath: 'id'
                                });
                            }
                        };
                        request.onsuccess = event => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };
                        request.onerror = event => reject(event.target.error);
                    });
                }

                _dbRequest(storeName, mode, action, data) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) {
                            reject("Database not initialized.");
                            return;
                        }
                        const transaction = this.db.transaction(storeName, mode);
                        const store = transaction.objectStore(storeName);
                        let request;
                        if (data !== undefined) {
                            request = store[action](data);
                        } else {
                            request = store[action]();
                        }
                        transaction.oncomplete = () => resolve(request.result);
                        transaction.onerror = () => reject(transaction.error);
                    });
                }

                async save(id, data) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    const saveData = { id, ...(data.id !== undefined ? data : { ...data, id }) };
                    return this._dbRequest(storeName, 'readwrite', 'put', saveData);
                }


                async get(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readonly', 'get', id);
                }

                async getAll() {
                    const soundData = await this._dbRequest(this.SOUNDS_STORE, 'readonly', 'getAll');
                    const configData = await this._dbRequest(this.CONFIG_STORE, 'readonly', 'getAll');
                    return [...soundData, ...configData];
                }

                async delete(id) {
                    const storeName = typeof id === 'number' ? this.SOUNDS_STORE : this.CONFIG_STORE;
                    return this._dbRequest(storeName, 'readwrite', 'delete', id);
                }

                async clear() {
                    await this._dbRequest(this.SOUNDS_STORE, 'readwrite', 'clear');
                    await this._dbRequest(this.CONFIG_STORE, 'readwrite', 'clear');
                }
            }



            class NotepadCard {
                constructor(element, soundboardManager, dbInstance) {
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.cardId);

                    // DOM Elements
                    this.contentElement = this.cardElement.querySelector('.notepad-content');
                    this.tabsContainer = this.cardElement.querySelector('.notepad-tabs');
                    this.addPageButton = this.cardElement.querySelector('.add-page-btn');

                    // state
                    this.pages = [{ title: 'New Note', content: '' }];
                    this.currentPageIndex = 0;
                    this.height = null;

                    this.attachListeners();
                    this.loadState();
                }

                attachListeners() {
                    this.contentElement.addEventListener('input', () => {
                        this.pages[this.currentPageIndex].content = this.contentElement.value;
                        this.saveState();
                    });

                    this.contentElement.addEventListener('mouseup', () => {
                        // Only save if a height style was actually set by resizing
                        if (this.contentElement.style.height) {
                            this.height = this.contentElement.style.height;
                            this.saveState();
                        }
                    });

                    this.addPageButton.addEventListener('click', () => this.addPage());

                    this.tabsContainer.addEventListener('click', (e) => {
                        // First, handle the delete button action
                        if (e.target.classList.contains('delete-page-btn')) {
                            const tab = e.target.closest('.notepad-tab');
                            if (tab) {
                                this.deletePage(parseInt(tab.dataset.pageIndex));
                            }
                            return; // Stop processing
                        }

                        // Now, handle the page switch action
                        const tabToSwitchTo = e.target.closest('.notepad-tab');
                        if (tabToSwitchTo) {
                            const targetIndex = parseInt(tabToSwitchTo.dataset.pageIndex);

                            // Only switch pages if the clicked tab is not already the active one.
                            if (targetIndex !== this.currentPageIndex) {
                                this.switchPage(targetIndex);
                            }
                            // If it IS the active tab, we do nothing, which lets you click to edit the title.
                        }
                    });

                    this.tabsContainer.addEventListener('input', (e) => {
                        if (e.target.classList.contains('notepad-tab-title')) {
                            const tab = e.target.closest('.notepad-tab');
                            const pageIndex = parseInt(tab.dataset.pageIndex);
                            this.pages[pageIndex].title = e.target.textContent;
                            this.saveState();
                        }
                    });
                }

                async loadState() {
                    const state = await this.db.get(`notepad-${this.id}`);
                    if (state) {
                        this.pages = state.pages.map(p => ({ title: 'Note', content: '', ...p }));
                        this.currentPageIndex = state.currentPageIndex;
                        this.height = state.height || null; // UPDATED: Load the card's height
                    }
                    this.render();
                }

                async saveState() {
                    const state = {
                        pages: this.pages,
                        currentPageIndex: this.currentPageIndex,
                        height: this.height // UPDATED: Save the card's height
                    };
                    await this.db.save(`notepad-${this.id}`, state);
                }

                addPage() {
                    this.pages.push({ title: 'New Note', content: '' });
                    this.currentPageIndex = this.pages.length - 1;
                    this.render();
                    this.saveState();
                }

                deletePage(index) {
                    // If there is more than one page, just delete the page
                    if (this.pages.length > 1) {
                        this.pages.splice(index, 1);
                        if (this.currentPageIndex >= index) {
                            this.currentPageIndex = Math.max(0, this.currentPageIndex - 1);
                        }
                        this.render();
                        this.saveState();
                    } else {
                        // If it's the last page, delete the entire note card
                        this.soundboardManager.removeNotepad(this.id);
                    }
                }

                switchPage(index) {
                    if (index >= 0 && index < this.pages.length) {
                        this.currentPageIndex = index;
                        this.render();
                        this.saveState();
                    }
                }

                render() {
                    const currentPage = this.pages[this.currentPageIndex];
                    this.contentElement.value = currentPage.content;

                    if (this.height) {
                        this.contentElement.style.height = this.height;
                    } else {
                        this.contentElement.style.height = '';
                    }

                    this.tabsContainer.querySelectorAll('.notepad-tab').forEach(tab => tab.remove());

                    this.pages.forEach((page, index) => {
                        const tab = document.createElement('div');
                        tab.className = 'notepad-tab';
                        tab.dataset.pageIndex = index;

                        const tabTitle = document.createElement('span');
                        tabTitle.className = 'notepad-tab-title';
                        tabTitle.textContent = page.title;

                        // UPDATED: Explicitly use strings for contentEditable for better compatibility
                        tabTitle.contentEditable = (index === this.currentPageIndex) ? 'true' : 'false';

                        const deleteBtn = document.createElement('span');
                        deleteBtn.className = 'delete-page-btn';
                        deleteBtn.textContent = 'x';

                        tab.appendChild(tabTitle);
                        tab.appendChild(deleteBtn);

                        if (index === this.currentPageIndex) {
                            tab.classList.add('active');
                        }
                        this.tabsContainer.insertBefore(tab, this.addPageButton);
                    });
                }
            }

            class TimerCard {
                constructor(element, soundboardManager, dbInstance) {
                    // Pass a reference to the main manager and the element to access its methods
                    this.cardElement = element;
                    this.soundboardManager = soundboardManager;
                    this.db = dbInstance;
                    this.id = parseInt(this.cardElement.dataset.timerId);

                    this.timerTitle = this.cardElement.querySelector('.timer-title');
                    this.timerDisplay = this.cardElement.querySelector('.timer-display');
                    this.startTimerBtn = this.cardElement.querySelector('.start-timer-btn');
                    this.stopTimerBtn = this.cardElement.querySelector('.stop-timer-btn');
                    this.removeTimerBtn = this.cardElement.querySelector('.remove-timer-btn');

                    this.timerStartSoundSelect = this.cardElement.querySelector('.timer-start-sound');
                    this.timerEndSoundSelect = this.cardElement.querySelector('.timer-end-sound');
                    this.timerMinutesRange = this.cardElement.querySelector('.timer-minutes-range');
                    this.timerSecondsRange = this.cardElement.querySelector('.timer-seconds-range');
                    this.timerMinutesValue = this.cardElement.querySelector('.timer-minutes-value');
                    this.timerSecondsValue = this.cardElement.querySelector('.timer-seconds-value');
                    this.hideOptionsToggle = this.cardElement.querySelector('.hide-timer-options-toggle');
                    this.optionsContainer = this.cardElement.querySelector('.timer-options-container');

                    this.timerInterval = null;
                    this.timerCountdown = 0; // This will be set on load or via sliders
                    this.isTimerRunning = false; // Add a state flag for clarity

                    // fancy outro logic
                    this.hasPlayedEndSound = false;
                    this.preloadedEndSound = null;

                    this.attachListeners();
                    this.loadTimerState(); // Call the new loading function
                }

                attachListeners() {
                    this.startTimerBtn.addEventListener('click', () => this.startTimer(false));
                    this.stopTimerBtn.addEventListener('click', () => this.stopTimer(false));
                    // REFACTOR: The remove button now calls the manager, which handles all state and UI updates.
                    this.removeTimerBtn.addEventListener('click', () => this.soundboardManager.removeTimer(this.id));
                    this.timerMinutesRange.addEventListener('input', this.updateTimerDisplay.bind(this));
                    this.timerSecondsRange.addEventListener('input', this.updateTimerDisplay.bind(this));
                    this.hideOptionsToggle.addEventListener('change', () => {
                        const isShowing = this.hideOptionsToggle.checked;
                        this.optionsContainer.classList.toggle('hidden-options', isShowing);
                        this.timerTitle.contentEditable = !isShowing;
                        this.saveTimerState();
                    });
                    // Save state on change
                    this.cardElement.addEventListener('input', () => this.saveTimerState());
                    this.timerStartSoundSelect.addEventListener('change', () => this.saveTimerState());
                    this.timerEndSoundSelect.addEventListener('change', () => this.saveTimerState());
                }

                async saveTimerState() {
                    const state = {
                        title: this.timerTitle.textContent,
                        minutes: this.timerMinutesRange.value,
                        seconds: this.timerSecondsRange.value,
                        startSound: this.timerStartSoundSelect.value,
                        endSound: this.timerEndSoundSelect.value,
                        optionsHidden: this.hideOptionsToggle.checked,
                        countdown: this.timerCountdown, // Save the current countdown
                        isTimerRunning: this.isTimerRunning, // Save the running state
                        hasPlayedEndSound: this.hasPlayedEndSound,
                        preloadedEndSound: this.preloadedEndSound
                    };
                    this.db.save(`timer-${this.id}`, state);
                }

                async loadTimerState() {
                    const state = await this.db.get(`timer-${this.id}`);
                    if (state) {
                        // Explicitly apply the loaded values to the UI elements
                        this.timerTitle.textContent = state.title;
                        this.timerMinutesRange.value = state.minutes;
                        this.timerSecondsRange.value = state.seconds;
                        this.timerMinutesValue.textContent = state.minutes;
                        this.timerSecondsValue.textContent = state.seconds;
                        this.timerStartSoundSelect.value = state.startSound;
                        this.timerEndSoundSelect.value = state.endSound;
                        this.hideOptionsToggle.checked = state.optionsHidden;
                        this.optionsContainer.classList.toggle('hidden-options', state.optionsHidden);
                        this.timerTitle.contentEditable = !state.optionsHidden;
                        this.hasPlayedEndSound = state.hasPlayedEndSound;
                        this.preloadedEndSound = state.preloadedEndSound;

                        // Set the countdown from the loaded state
                        // If the timer was running, resume from the saved countdown
                        if (state.isTimerRunning && state.countdown > 0) {
                            this.timerCountdown = state.countdown;
                            this.startTimer(true); // Immediately resume the timer
                        } else {
                            // Otherwise, set the countdown from the slider values
                            this.timerCountdown = (parseInt(this.timerMinutesRange.value) * 60) + parseInt(this.timerSecondsRange.value);
                        }
                    } else {
                        // Initialize for a new timer
                        this.timerCountdown = (parseInt(this.timerMinutesRange.value) * 60) + parseInt(this.timerSecondsRange.value);
                    }
                    this.renderTimerDisplay();
                }

                updateTimerDisplay() {
                    const minutes = this.timerMinutesRange.value;
                    const seconds = this.timerSecondsRange.value;
                    this.timerMinutesValue.textContent = minutes;
                    this.timerSecondsValue.textContent = seconds;

                    // Only update countdown from sliders if the timer is not running
                    if (!this.isTimerRunning) {
                        this.timerCountdown = (parseInt(minutes) * 60) + parseInt(seconds);
                    }

                    this.renderTimerDisplay();
                }

                renderTimerDisplay() {
                    const minutes = Math.floor(this.timerCountdown / 60);
                    const seconds = this.timerCountdown % 60;
                    const displayString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    this.timerDisplay.textContent = displayString;
                }

                async preloadEndSound(index) {
                    if (isNaN(index)) { return; }
                    const buttonData = this.soundboardManager.buttonsData[index];
                    const player = this.soundboardManager._getAudioPlayer(index);
                    if (buttonData.files.length === 0) return;

                    if (player.playback.currentFileIndex >= buttonData.files.length) {
                        player.playback.currentFileIndex = 0;
                    }
                    const fileIndex = buttonData.shuffle
                        ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                        : player.playback.currentFileIndex;

                    player.playback.currentFileIndex = fileIndex;
                    const outroDuration = await this.getAudioDuration(buttonData.files[fileIndex].arrayBuffer);

                    console.log(outroDuration)
                    this.preloadedEndSound = { index: index, fileIndex: fileIndex, priority: buttonData.priority, duration: outroDuration };
                    return;
                }

                getAudioDuration(arrayBuffer) {
                    return new Promise((resolve, reject) => {
                        const blob = new Blob([arrayBuffer]);
                        const audio = new Audio();
                        const objectURL = URL.createObjectURL(blob);

                        audio.addEventListener('loadedmetadata', () => {
                            const duration = audio.duration;
                            URL.revokeObjectURL(objectURL); // Clean up the URL
                            resolve(duration);
                        }, { once: true }); // Use { once: true } for automatic cleanup

                        audio.addEventListener('error', (e) => {
                            URL.revokeObjectURL(objectURL);
                            console.error('Error loading audio file:', e);
                            reject(new Error('Failed to load audio file for duration calculation.'));
                        }, { once: true });

                        audio.src = objectURL;
                    });
                }

                startTimer(isResume = false) {
                    if (this.isTimerRunning || this.timerCountdown <= 0) return;

                    // Reset state for a new run
                    this.hasPlayedEndSound = false;
                    this.endSoundData = null;

                    const totalDurationInMs = this.timerCountdown * 1000;
                    this.endTime = Date.now() + totalDurationInMs;

                    const endSoundId = parseInt(this.timerEndSoundSelect.value);
                    // 1. Get the essential sound data immediately (synchronously).
                    if (!isNaN(endSoundId)) {
                        const buttonData = this.soundboardManager.buttonsData[endSoundId];
                        if (buttonData && buttonData.files.length > 0) {
                            const player = this.soundboardManager._getAudioPlayer(endSoundId);
                            const fileIndex = buttonData.shuffle
                                ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                                : player.playback.currentFileIndex;

                            this.endSoundData = {
                                index: endSoundId,
                                fileIndex: fileIndex,
                                priority: buttonData.priority,
                                duration: null // Duration is still unknown
                            };

                            // 2. Start calculating the duration in the background, but DO NOT wait for it.
                            this.getAudioDuration(buttonData.files[fileIndex].arrayBuffer)
                                .then(duration => {
                                    if (this.endSoundData) { // Check if timer is still relevant
                                        this.endSoundData.duration = duration;
                                    }
                                }).catch(err => console.error("Could not get audio duration:", err));
                        }
                    }

                    // Play the start sound (if any)
                    const startSoundId = parseInt(this.timerStartSoundSelect.value);
                    if (!isNaN(startSoundId) && startSoundId !== '' && !isResume) {
                        this.soundboardManager.togglePlay(startSoundId).catch(error => {
                            console.error('Failed to play start sound:', error);
                        });
                    }

                    this.isTimerRunning = true;
                    this.timerDisplay.classList.add('running');

                    // 3. The timer starts ticking immediately.
                    this.timerInterval = setInterval(() => {
                        const remainingMs = this.endTime - Date.now();
                        this.timerCountdown = Math.max(0, Math.round(remainingMs / 1000));

                        this.renderTimerDisplay();
                        this.saveTimerState();

                        if (this.endSoundData && this.endSoundData.duration && !this.hasPlayedEndSound && this.timerCountdown <= this.endSoundData.duration) {
                            this.playEndSound();
                            this.hasPlayedEndSound = true;
                        }

                        if (remainingMs <= 0) { // Check against the precise remaining time
                            if (!this.hasPlayedEndSound) {
                                this.playEndSound();
                            }
                            this.stopTimer(true);
                        }
                    }, 1000);

                    this.saveTimerState();
                }

                stopTimer(isEnded = false) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                    this.isTimerRunning = false;
                    this.timerDisplay.classList.remove('running');

                    // Only reset the countdown if the timer was manually stopped or on page load
                    if (!isEnded) {
                        this.timerCountdown = (parseInt(this.timerMinutesRange.value) * 60) + parseInt(this.timerSecondsRange.value);
                        this.renderTimerDisplay();
                    }

                    this.saveTimerState(); // Save the final, stopped state
                }

                updateTimerSoundSelectors(sounds) {
                    this.timerStartSoundSelect.innerHTML = '<option value="">None</option>';
                    this.timerEndSoundSelect.innerHTML = '<option value="">None</option>';
                    sounds.forEach((sound, index) => {
                        if (sound.name !== "Default Name") {
                            const optionStart = document.createElement('option');
                            optionStart.value = index;
                            optionStart.textContent = sound.name;
                            this.timerStartSoundSelect.appendChild(optionStart);
                            const optionEnd = document.createElement('option');
                            optionEnd.value = index;
                            optionEnd.textContent = sound.name;
                            this.timerEndSoundSelect.appendChild(optionEnd);
                        }
                    });
                    this.loadTimerState();
                }

                playEndSound() {
                    // This now uses the new endSoundData object
                    if (this.endSoundData) {
                        this.soundboardManager.playFile(this.endSoundData.index, this.endSoundData.fileIndex, this.endSoundData.priority).catch(error => {
                            console.error('Failed to play end sound:', error);
                        });
                        this.hasPlayedEndSound = true; // Mark as played
                    }
                }

                async removeTimer() {
                    const confirmed = await this.soundboardManager.showConfirmModal('Are you sure you want to delete this timer?');
                    if (confirmed) {
                        this.stopTimer();
                        this.cardElement.remove();
                        this.soundboardManager.removeTimerCardInstance(this.id);
                    }
                }
            }

            // ====================================================================
            // SECTION: Application Manager Class
            // Manages the state and business logic of the soundboard.
            // UI interactions trigger methods on this manager.
            // ====================================================================

            class SoundboardManager {
                constructor(dbInstance) {
                    this.db = dbInstance;
                    this.soundboardGrid = document.getElementById('soundboard-grid');
                    this.controlCardElement = document.getElementById('control-card');
                    this.buttonsData = [];
                    this.players = new Map();
                    this.timerCards = [];
                    this.notepadCards = [];

                    this.gridLayout = [];
                    this.GRID_LAYOUT_KEY = 'grid-layout';
                    this.activeModalIndex = null;
                    this.isRearranging = false;
                    this.draggedItem = null;
                    this.cosmeticsData = {};

                }

                // ================================================================
                // Core Manager Methods
                // ================================================================

                async _loadBoardData() {
                    await this.loadTitle();
                    await this.loadCosmetics();
                    await this.loadStateFromDB(); // Loads sound buttons
                    await this.loadTimers();
                    await this.loadNotepads();
                    await this.initBugMovement();
                    await this.loadLayout();

                }

                async initialize() {
                    loadGoogleFonts(['Wellfleet']);
                    await this.db.openDB();

                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';
                    await BoardManager.addBoardId(boardId);
                    await this._loadBoardData();
                    this.attachGlobalEventListeners();
                    this.renderGrid();
                }

                async createNewBoard() {
                    const input = document.getElementById('new-board-name-input');
                    const boardName = input.value.trim();

                    if (!boardName) {
                        alert("Please enter a name for the new board.");
                        return;
                    }

                    const boardId = slugify(boardName);
                    if (!boardId) {
                        alert("Please enter a valid name (letters and numbers).");
                        return;
                    }

                    const existingBoardIds = await BoardManager.getBoardList(); // UPDATED
                    if (existingBoardIds.includes(boardId)) {
                        alert(`A board with the ID "${boardId}" already exists.`);
                        return;
                    }

                    window.location.href = `?board=${boardId}`;
                }

                async loadTitle() {
                    const titleData = await this.db.get('soundboard-title');

                    if (titleData && titleData.title) {
                        // If a title is already saved in the database, use it.
                        document.getElementById('soundboard-title').textContent = titleData.title;
                    } else {
                        // NEW: If no title is saved, get the board ID from the URL
                        // and use that as the default title.
                        const urlParams = new URLSearchParams(window.location.search);
                        const boardId = formatIdAsTitle(urlParams.get('board')) || 'The Bug & Moss Simple Soundboard';
                        document.getElementById('soundboard-title').textContent = boardId;
                        document.title = boardId + " | B&M RSS";
                    }
                }

                // REFACTOR: New method to load the grid layout from DB or create a default.
                async loadLayout() {
                    const layoutData = await this.db.get(this.GRID_LAYOUT_KEY);
                    if (layoutData && Array.isArray(layoutData.layout)) {
                        this.gridLayout = layoutData.layout;
                    } else {
                        this._generateDefaultLayout();
                        await this._saveLayout();
                    }
                }

                // REFACTOR: New method to save the current grid layout to DB.
                async _saveLayout() {
                    await this.db.save(this.GRID_LAYOUT_KEY, { id: this.GRID_LAYOUT_KEY, layout: this.gridLayout });
                }

                // REFACTOR: New method to create a default layout if none exists.
                _generateDefaultLayout() {
                    this.gridLayout = [];
                    this.buttonsData.forEach((btn) => this.gridLayout.push({ type: 'sound', id: btn.id }));
                    this.timerCards.forEach((timer) => this.gridLayout.push({ type: 'timer', id: timer.id }));
                    this.notepadCards.forEach((note) => this.gridLayout.push({ type: 'notepad', id: note.id }));
                    this.gridLayout.push({ type: 'control', id: 'control-card' });
                }

                async loadNotepads() {
                    const notepadCountData = await this.db.get('notepadCount');
                    const numNotepads = notepadCountData ? notepadCountData.count : 0;
                    const notepadTemplate = document.getElementById('notepad-card-template');

                    for (let i = 0; i < numNotepads; i++) {
                        // Find the highest existing ID to avoid collisions
                        const existingIds = this.notepadCards.map(n => n.id);
                        const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : i;

                        const newCard = notepadTemplate.content.cloneNode(true).querySelector('.notepad-card');
                        newCard.dataset.cardType = 'notepad';
                        newCard.dataset.cardId = nextId;
                        this.notepadCards.push(new NotepadCard(newCard, this, this.db));
                    }
                }

                // Add this new method to add a notepad
                async addNotepad() {
                    const existingIds = this.notepadCards.map(n => n.id);
                    const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 0;

                    const newCard = document.getElementById('notepad-card-template').content.cloneNode(true).querySelector('.notepad-card');
                    newCard.dataset.cardType = 'notepad';
                    newCard.dataset.cardId = nextId;

                    this.notepadCards.push(new NotepadCard(newCard, this, this.db));

                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    this.gridLayout.splice(controlCardIndex, 0, { type: 'notepad', id: nextId });

                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                // Add this new method to remove a notepad
                async removeNotepad(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this note?');
                    if (!confirmed) return;

                    this.notepadCards = this.notepadCards.filter(n => n.id !== idToRemove);
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'notepad' && item.id === idToRemove));

                    await this.db.delete(`notepad-${idToRemove}`);
                    await this.db.save('notepadCount', { id: 'notepadCount', count: this.notepadCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async loadTimers() {
                    const timerCountData = await this.db.get('timerCount');
                    const numTimers = timerCountData ? timerCountData.count : 0;
                    const timerTemplate = document.getElementById('timer-card-template');

                    for (let i = 0; i < numTimers; i++) {
                        const timerId = i;
                        const newCard = timerTemplate.content.cloneNode(true).querySelector('.timer-card');
                        newCard.dataset.timerId = timerId;
                        // REFACTOR: Add card type and ID for drag-and-drop identification.
                        newCard.dataset.cardType = 'timer';
                        newCard.dataset.cardId = timerId;
                        this.timerCards.push(new TimerCard(newCard, this, this.db));
                    }
                }

                async addTimer() {
                    const nextTimerIndex = this.timerCards.length > 0 ? Math.max(...this.timerCards.map(t => t.id)) + 1 : 0;
                    const newCard = document.getElementById('timer-card-template').content.cloneNode(true).querySelector('.timer-card');
                    newCard.dataset.timerId = nextTimerIndex;
                    newCard.dataset.cardType = 'timer';
                    newCard.dataset.cardId = nextTimerIndex;

                    this.timerCards.push(new TimerCard(newCard, this, this.db));

                    // REFACTOR: Add the new timer to the layout and re-render.
                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    if (controlCardIndex > -1) {
                        this.gridLayout.splice(controlCardIndex, 0, { type: 'timer', id: nextTimerIndex });
                    } else {
                        this.gridLayout.push({ type: 'timer', id: nextTimerIndex });
                    }

                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                // REFACTOR: New unified remove method for timers.
                async removeTimer(idToRemove) {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete this timer?');
                    if (!confirmed) return;

                    const timerInstance = this.timerCards.find(t => t.id === idToRemove);
                    if (timerInstance) {
                        timerInstance.stopTimer();
                    }

                    // Remove from instance array
                    this.timerCards = this.timerCards.filter(t => t.id !== idToRemove);

                    // Remove from layout
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'timer' && item.id === idToRemove));

                    // Delete DB entries
                    await this.db.delete(`timer-${idToRemove}`);
                    await this.db.save('timerCount', { id: 'timerCount', count: this.timerCards.length });

                    await this._saveLayout();
                    this.renderGrid();
                }

                async requestPersistentStorage() {
                    if (navigator.storage && navigator.storage.persist) {
                        const isPersisted = await navigator.storage.persisted();
                        if (!isPersisted) {
                            const granted = await navigator.storage.persist();
                            if (granted) {
                                console.log("Persistent storage granted!");
                            } else {
                                console.log("Persistent storage denied.");
                            }
                        } else {
                            console.log("Persistent storage already granted.");
                        }
                    }
                }

                async loadCosmetics() {
                    let cosmeticsData = await this.db.get(this.db.COSMETICS_KEY);
                    if (!cosmeticsData) {
                        // Default values if no settings are saved
                        cosmeticsData = {
                            id: this.db.COSMETICS_KEY,
                            fontFamily: 'Wellfleet',
                            colors: {
                                '--background-color': '#f7fafc',
                                '--panel-color': '#e3f0ff',
                                '--accent-color': '#3bb273',
                                '--highlight-color': '#ff914d',
                                '--primary-color': '#234e70',
                                '--secondary-color': '#cce0ec',
                                '--dark-accent-color': '#308d5b',
                            }
                        };
                        await this.db.save(cosmeticsData.id, cosmeticsData);
                    }
                    this.cosmeticsData = cosmeticsData;
                    this.applyCosmetics();
                }

                async deleteCosmeticsKey() {
                    const confirmed = await this.showConfirmModal('Are you sure you want to delete all cosmetic settings? This cannot be undone.');
                    if (confirmed) {
                        await this.db.delete(this.db.COSMETICS_KEY);
                        // Reload the page to reset to default settings
                        window.location.reload();
                    }
                }

                async _saveCosmetics() {
                    await this.db.save(this.cosmeticsData.id, this.cosmeticsData);
                }

                async loadStateFromDB() {
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    let configData = await this.db.get(this.db.CONFIG_KEY);
                    if (!configData) {
                        configData = { id: this.db.CONFIG_KEY, numButtons: 8 };
                        await this.db.save(configData.id, configData);
                    }

                    const numButtons = configData.numButtons;
                    const soundDataMap = new Map(soundData.map(item => [item.id, item]));

                    this.buttonsData = [];
                    for (let i = 0; i < numButtons; i++) {
                        const data = soundDataMap.get(i) || this._getInitialButtonData(i);
                        this.buttonsData.push(data);
                    }
                }

                async addButton() {
                    const nextIndex = this.buttonsData.length;
                    const newButtonData = this._getInitialButtonData(nextIndex);
                    this.buttonsData.push(newButtonData);

                    // REFACTOR: Add the new button to the layout and re-render.
                    const controlCardIndex = this.gridLayout.findIndex(item => item.type === 'control');
                    if (controlCardIndex > -1) {
                        this.gridLayout.splice(controlCardIndex, 0, { type: 'sound', id: nextIndex });
                    } else {
                        this.gridLayout.push({ type: 'sound', id: nextIndex });
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();
                    this.renderGrid();
                }

                async removeLastButton() {
                    if (this.buttonsData.length > 1) {
                        const lastIndex = this.buttonsData.length - 1;
                        this.buttonsData.pop();
                        if (this.players.has(lastIndex)) {
                            this.players.get(lastIndex).cleanup();
                            this.players.delete(lastIndex);
                        }
                        await this.db.delete(lastIndex);
                        await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });

                        // REFACTOR: Remove from layout and re-render.
                        this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === lastIndex));
                        await this._saveLayout();
                        this.renderGrid();
                    }
                }

                async updateButton(index, newData) {
                    this.buttonsData[index] = { ...this.buttonsData[index], ...newData };
                    await this.db.save(index, this.buttonsData[index]);
                    this.renderGrid();
                }

                // ================================================================
                // UI Rendering Methods
                // ================================================================

                // REFACTOR: This is the new primary rendering function.
                renderGrid() {
                    this.soundboardGrid.innerHTML = '';

                    this.gridLayout.forEach(item => {
                        let cardElement = null;
                        if (item.type === 'sound') {
                            const buttonData = this.buttonsData.find(b => b.id === item.id);
                            if (buttonData) {
                                cardElement = this._createSoundCardElement(buttonData, item.id);
                            }
                        } else if (item.type === 'timer') {
                            const timerInstance = this.timerCards.find(t => t.id === item.id);
                            if (timerInstance) {
                                cardElement = timerInstance.cardElement;
                            }
                        } else if (item.type === 'control') {
                            cardElement = this.controlCardElement;
                            cardElement.style.display = 'flex'; // Make it visible
                        } else if (item.type === 'notepad') {
                            const noteInstance = this.notepadCards.find(n => n.id === item.id);
                            if (noteInstance) {
                                cardElement = noteInstance.cardElement;
                            }
                        }

                        if (cardElement) {
                            this.soundboardGrid.appendChild(cardElement);
                        }
                    });

                    this.timerCards.forEach(timer => timer.updateTimerSoundSelectors(this.buttonsData));
                }

                _createSoundCardElement(buttonData, index) {
                    const card = document.createElement('div');
                    const textColor = getContrastColor(buttonData.color);
                    card.className = 'sound-card';
                    // REFACTOR: Use distinct data attributes for type and ID.
                    card.dataset.cardType = 'sound';
                    card.dataset.cardId = index;
                    card.dataset.index = index; // Keep for compatibility
                    card.setAttribute('draggable', this.isRearranging);
                    card.innerHTML = `
<button class="sound-button" data-action="play" style="background-color: ${buttonData.color}; color: ${textColor}">
<div class="progress-overlay" style="width: 0%;"></div>
<span class="button-text">${buttonData.name}</span>
<div class="settings-triangle-btn" data-action="settings">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
<path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
</svg>
</div>
</button>
<div class="sound-controls">
<div class="slider-group">
<label>Volume</label>
<input type="range" min="0" max="1" step="0.01" value="${buttonData.volume}" data-action="volume-change">
</div>
<div class="slider-group">
<label>Speed</label>
<input type="range" min="0.5" max="2" step="0.1" value="${buttonData.playbackRate}" data-action="speed-change" ondblclick="this.value=1.0; this.dispatchEvent(new Event('input'))">
<span class="speed-display">${buttonData.playbackRate.toFixed(1)}x</span>
</div>
</div>
`;
                    return card;
                }

                // ================================================================
                // Event Handling and Playback Logic
                // ================================================================

                attachGlobalEventListeners() {

                    document.getElementById('soundboard-title').addEventListener('blur', (e) => {
                        const newTitle = e.target.textContent.trim();
                        document.title = newTitle + " | B&M RSS";
                        this.db.save('soundboard-title', { id: 'soundboard-title', title: newTitle });
                    });

                    this.soundboardGrid.addEventListener('click', (event) => this.handleGridClick(event));
                    this.soundboardGrid.addEventListener('input', (event) => this.handleSliderChange(event));
                    this.soundboardGrid.addEventListener('dblclick', (event) => this.handleGridDoubleClick(event));

                    this.soundboardGrid.addEventListener('dragstart', (e) => this.handleDragStart(e));
                    this.soundboardGrid.addEventListener('dragover', (e) => this.handleDragOver(e));
                    this.soundboardGrid.addEventListener('dragenter', (e) => this.handleDragEnter(e));
                    this.soundboardGrid.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    this.soundboardGrid.addEventListener('drop', (e) => this.handleDrop(e));
                    this.soundboardGrid.addEventListener('dragend', (e) => this.handleDragEnd(e));

                    document.getElementById('add-notepad-btn').addEventListener('click', () => this.addNotepad());
                    document.getElementById('add-btn-plus').addEventListener('click', () => this.addButton());
                    document.getElementById('remove-button-modal').addEventListener('click', () => this._handleRemoveButton());
                    document.getElementById('add-timer-btn').addEventListener('click', () => this.addTimer());
                    document.getElementById('rearrange-mode-btn').addEventListener('click', () => this.toggleRearrangeMode());
                    document.getElementById('download-config-btn').addEventListener('click', () => this.downloadConfig());
                    document.getElementById('upload-config-btn').addEventListener('click', () => document.getElementById('upload-config-input').click());
                    document.getElementById('upload-config-input').addEventListener('change', (e) => this.uploadConfig(e));
                    document.getElementById('db-manager-btn').addEventListener('click', () => this.showDbManagerModal());

                    document.getElementById('switch-board-btn').addEventListener('click', () => this.openBoardSwitcherModal());
                    document.getElementById('create-new-board-btn').addEventListener('click', () => this.createNewBoard());

                    // ADD a listener to close the new modal when clicking the background
                    document.getElementById('board-switcher-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'board-switcher-modal') {
                            document.getElementById('board-switcher-modal').style.display = 'none';
                        }
                    });


                    document.getElementById('settings-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'settings-modal') this.closeSettingsModal();
                    });
                    document.getElementById('db-manager-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'db-manager-modal') this.closeDbManagerModal();
                    });
                    document.getElementById('persistent-storage-checkbox').addEventListener('change', (e) => {
                        if (e.target.checked) {
                            this.requestPersistentStorage();
                        }
                        // Note: Browsers do not currently allow you to programmatically "un-persist" storage.
                        // The user must do this through browser settings.
                    });
                    document.getElementById('clear-database-btn').addEventListener('click', () => this.handleClearDatabase());

                    document.getElementById('button-name-input').addEventListener('input', (e) => this.updateModalButtonData('name', e.target.value));
                    document.getElementById('button-color-picker').addEventListener('input', (e) => this.updateModalButtonData('color', e.target.value));
                    document.getElementById('add-file-input').addEventListener('change', (e) => this.addFilesToModalButton(e));
                    document.getElementById('clear-files-btn').addEventListener('click', () => this.clearModalButtonFiles());
                    document.getElementById('shuffle-checkbox').addEventListener('change', (e) => this.updateModalButtonData('shuffle', e.target.checked));
                    document.getElementById('autoplay-checkbox').addEventListener('change', (e) => this.updateModalButtonData('autoplay', e.target.checked));
                    document.getElementById('priority-checkbox').addEventListener('change', (e) => this.updateModalButtonData('priority', e.target.checked));
                    document.getElementById('loop-checkbox').addEventListener('change', (e) => this.updateModalButtonData('loop', e.target.checked));


                    document.getElementById('cosmetics-btn').addEventListener('click', () => this.openCosmeticsModal());
                    document.getElementById('delete-cosmetics-key-btn').addEventListener('click', () => this.deleteCosmeticsKey());
                    document.getElementById('file-list').addEventListener('click', (e) => {
                        // If the clicked element has the 'remove-file-button' class, then act.
                        if (e.target.classList.contains('remove-file-button')) {
                            this.removeFileFromModalButton(e);
                        }
                    });

                    document.getElementById('cosmetics-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'cosmetics-modal') {
                            document.getElementById('cosmetics-modal').style.display = 'none';
                        }
                    });

                    document.querySelectorAll('#cosmetics-modal input[type="color"]').forEach(input => {
                        input.addEventListener('input', (e) => {
                            const cssVar = e.target.dataset.cssVar;
                            this.cosmeticsData.colors[cssVar] = e.target.value;
                            this.applyCosmetics();
                            this._saveCosmetics();
                        });
                    });

                    document.getElementById('font-input').addEventListener('change', (e) => {
                        const newFont = e.target.value.trim();
                        if (newFont) {
                            this.cosmeticsData.fontFamily = newFont;
                            this.applyCosmetics();
                            this._saveCosmetics();
                        }
                    });

                    // HELPFUL BUG

                    document.getElementById('help-bug-btn').addEventListener('click', () => {
                        document.getElementById('help-modal').style.display = 'flex';
                    });

                    document.getElementById('help-modal').addEventListener('click', (event) => {
                        if (event.target.id === 'help-modal') {
                            document.getElementById('help-modal').style.display = 'none';
                        }
                    });
                    document.querySelector('.help-accordion').addEventListener('click', (e) => {
                        if (e.target.classList.contains('accordion-header')) {
                            const activeHeader = document.querySelector('.accordion-header.active');
                            // Close the already active header if it's not the one that was clicked
                            if (activeHeader && activeHeader !== e.target) {
                                activeHeader.classList.remove('active');
                                activeHeader.nextElementSibling.classList.remove('active');
                            }

                            // Toggle the clicked header and its content
                            e.target.classList.toggle('active');
                            const content = e.target.nextElementSibling;
                            content.classList.toggle('active');
                        }
                    });

                    // SERVICE WORKER
                    // WORKER IN SERVICE
                    // TREAT HIM NICELY
                    if ('serviceWorker' in navigator) {
                        window.addEventListener('load', () => {
                            navigator.serviceWorker.register('./service-worker.js').then(registration => {
                                console.log('ServiceWorker registration successful');
                            }).catch(err => {
                                console.log('ServiceWorker registration failed: ', err);
                            });
                        });
                    }
                }

                handleGridClick(event) {
                    if (this.isRearranging) return;
                    const card = event.target.closest('.sound-card[data-card-type="sound"]');
                    if (!card) return;
                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const actionElement = event.target.closest('[data-action]');
                    if (!actionElement) return;
                    const action = actionElement.dataset.action;

                    switch (action) {
                        case 'play':
                            this.togglePlay(index);
                            break;
                        case 'settings':
                            this.openSettingsModal(index);
                            break;
                    }
                }

                handleGridDoubleClick(event) {
                    const slider = event.target.closest('input[type="range"][data-action="speed-change"]');
                    if (slider) {
                        slider.value = 1.0;
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                handleSliderChange(event) {
                    const card = event.target.closest('.sound-card');
                    if (!card) return;

                    const index = parseInt(card.dataset.index);
                    if (isNaN(index)) return;

                    const action = event.target.dataset.action;
                    const value = parseFloat(event.target.value);
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    switch (action) {
                        case 'volume-change':
                            buttonData.volume = value;
                            player.audio.volume = value;
                            break;
                        case 'speed-change':
                            buttonData.playbackRate = value;
                            player.audio.playbackRate = value;
                            const speedDisplay = card.querySelector('.speed-display');
                            if (speedDisplay) {
                                speedDisplay.textContent = `${value.toFixed(1)}x`;
                            }
                            break;
                    }
                    this.db.save(index, buttonData);
                }

                handleDragStart(event) {
                    if (!this.isRearranging) return;
                    this.draggedItem = event.target.closest('.sound-card');
                    if (!this.draggedItem) return;
                    event.dataTransfer.effectAllowed = 'move';
                    // REFACTOR: Use a generic identifier for the drag data.
                    event.dataTransfer.setData('text/plain', this.draggedItem.dataset.cardId);
                    setTimeout(() => {
                        this.draggedItem.classList.add('dragging');
                    }, 0);
                }

                handleDragOver(event) {
                    event.preventDefault();
                }

                handleDragEnter(event) {
                    if (!this.isRearranging) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        targetCard.classList.add('drag-over');
                    }
                }

                handleDragLeave(event) {
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        if (!targetCard.contains(event.relatedTarget)) {
                            targetCard.classList.remove('drag-over');
                        }
                    }
                }

                // REFACTOR: The drop handler now manipulates the gridLayout array.
                async handleDrop(event) {
                    event.preventDefault();
                    if (!this.isRearranging || !this.draggedItem) return;
                    const targetCard = event.target.closest('.sound-card');
                    if (targetCard && targetCard !== this.draggedItem) {
                        const fromType = this.draggedItem.dataset.cardType;
                        const fromId = fromType === 'control' ? 'control-card' : parseInt(this.draggedItem.dataset.cardId);
                        const toType = targetCard.dataset.cardType;
                        const toId = toType === 'control' ? 'control-card' : parseInt(targetCard.dataset.cardId);

                        const fromIndex = this.gridLayout.findIndex(item => item.type === fromType && item.id === fromId);
                        const toIndex = this.gridLayout.findIndex(item => item.type === toType && item.id === toId);

                        if (fromIndex > -1 && toIndex > -1) {
                            [this.gridLayout[fromIndex], this.gridLayout[toIndex]] = [this.gridLayout[toIndex], this.gridLayout[fromIndex]];
                            await this._saveLayout();
                            this.renderGrid();
                        }
                    }
                }

                handleDragEnd() {
                    if (this.draggedItem) {
                        this.draggedItem.classList.remove('dragging');
                        this.draggedItem = null;
                        this.soundboardGrid.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    }
                }

                // REFACTOR: Toggle rearrange mode for ALL cards.
                toggleRearrangeMode() {
                    this.isRearranging = !this.isRearranging;
                    const btn = document.getElementById('rearrange-mode-btn');
                    const grid = document.getElementById('soundboard-grid');
                    grid.classList.toggle('rearrange-mode', this.isRearranging);
                    btn.textContent = this.isRearranging ? 'Done Rearranging' : 'Rearrange';

                    grid.querySelectorAll('.sound-card').forEach(card => {
                        card.setAttribute('draggable', this.isRearranging);
                    });
                }

                async togglePlay(index) {
                    if (isNaN(index)) {
                        console.error("Invalid index provided:", index);
                        return;
                    }
                    const buttonData = this.buttonsData[index];
                    const player = this._getAudioPlayer(index);
                    if (buttonData.files.length === 0) return;

                    if (player.playback.currentFileIndex >= buttonData.files.length) {
                        player.playback.currentFileIndex = 0;
                    }

                    if (player.isPlaying) {
                        player.cleanup();
                        this.handlePlaybackCompletion(index);

                    } else {

                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;

                        player.playback.currentFileIndex = fileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    }
                }

                _lerpVolume(audio, slider, from, to, duration) {
                    const start = performance.now();

                    function step(now) {
                        const t = Math.min((now - start) / duration, 1); // 0 → 1
                        audio.volume = Math.max(0, Math.min(1, from + (to - from) * t));
                        slider.value = audio.volume;

                        if (t < 1) {
                            requestAnimationFrame(step);
                        }
                    }

                    requestAnimationFrame(step);
                }

                handlePriorityDucking() {
                    this.players.forEach((player, playerIndex) => {

                        const playerButtonData = this.buttonsData[playerIndex];
                        if (!playerButtonData.priority) {
                            const duckTarget = playerButtonData.volume * player.duckAmount;
                            const slider = this._getVolumeSlider(playerIndex);
                            this._lerpVolume(player.audio, slider, player.audio.volume, duckTarget, player.fadeSpeed);

                        }
                    });
                }

                _getVolumeSlider(index) {
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        return card.querySelector('input[data-action="volume-change"]');
                    }
                    return null;
                }

                _checkForPriorityPlaying() {
                    for (const [playerIndex, player] of this.players.entries()) {
                        // Check if the sound is actually playing AND belongs to a priority button.
                        if (player.isPlaying && this.buttonsData[playerIndex]?.priority) {
                            return true; // Found another priority sound playing, so stop checking.
                        }
                    }
                    return false; // No other priority sounds are playing.
                };


                handlePlaybackCompletion(index) {
                    const buttonData = this.buttonsData[index];
                    const player = this.players.get(index);
                    if (!player) return;

                    // Check if the sound that just ended was a priority sound.
                    if (buttonData.priority) {
                        // Check if any OTHER priority sounds are still playing.
                        let isOtherPriorityPlaying = this._checkForPriorityPlaying();

                        // If no other priority sounds are running, it's safe to un-duck.
                        if (!isOtherPriorityPlaying) {
                            // NEW: This loop now correctly gets the index for each ducked player.
                            this.players.forEach((duckedPlayer, duckedPlayerIndex) => {
                                const duckedPlayerButtonData = this.buttonsData[duckedPlayerIndex];

                                // Only restore volume on sounds that were actually ducked (i.e., non-priority and still playing).
                                if (duckedPlayer.isPlaying && !duckedPlayerButtonData.priority) {
                                    const targetVolume = duckedPlayerButtonData.volume;
                                    const slider = this._getVolumeSlider(duckedPlayerIndex);
                                    this._lerpVolume(duckedPlayer.audio, slider, duckedPlayer.audio.volume, targetVolume, duckedPlayer.fadeSpeed);
                                }
                            });
                        }
                    }

                    // This handles the autoplay/loop logic after the ducking is resolved.
                    if (buttonData.loop) {
                        this.playFile(index, player.playback.currentFileIndex, buttonData.priority);
                    } else if (buttonData.autoplay) {
                        player.playback.currentFileIndex++;
                        if (player.playback.currentFileIndex >= buttonData.files.length) {
                            player.playback.currentFileIndex = 0;
                        }
                        const fileIndex = buttonData.shuffle
                            ? randomButNot(0, buttonData.files.length, player.playback.currentFileIndex)
                            : player.playback.currentFileIndex;
                        this.playFile(index, fileIndex, buttonData.priority);
                    }
                }

                async playFile(buttonIndex, fileIndex, isPriority) {
                    const buttonData = this.buttonsData[buttonIndex];
                    const player = this._getAudioPlayer(buttonIndex);
                    const fileData = buttonData.files[fileIndex];
                    if (!fileData) {
                        console.error("No file found at index:", fileIndex);
                        return;
                    }
                    player.cleanup();
                    const blob = new Blob([fileData.arrayBuffer], { type: fileData.mimeType });
                    player.audio.src = URL.createObjectURL(blob);
                    player.audio.volume = buttonData.volume;
                    player.audio.playbackRate = buttonData.playbackRate;

                    player.audio.play().catch(e => console.error("Playback error:", e));
                    if (isPriority) {
                        this.handlePriorityDucking();
                    }
                }

                _getAudioPlayer(index) {
                    let player = this.players.get(index);
                    if (!player) {
                        const audio = new Audio();
                        player = new AudioPlayer(audio);
                        this.players.set(index, player);

                        audio.onended = () => {
                            this.handlePlaybackCompletion(index);
                        };
                    }
                    const card = this.soundboardGrid.querySelector(`[data-index="${index}"]`);
                    if (card) {
                        player.progressOverlay = card.querySelector('.progress-overlay');
                    }
                    return player;
                }

                _getInitialButtonData(index) {
                    return {
                        id: index,
                        name: `Button ${index + 1}`,
                        color: "#3bb273",
                        volume: 1.0,
                        playbackRate: 1.0,
                        shuffle: false,
                        loop: false,
                        priority: false,
                        files: []
                    };
                }

                _shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                }

                // ================================================================
                // COSMETICS MODAL METHODS
                // ================================================================
                applyCosmetics() {
                    const root = document.documentElement;
                    for (const [key, value] of Object.entries(this.cosmeticsData.colors)) {
                        root.style.setProperty(key, value);
                    }
                    loadGoogleFonts([this.cosmeticsData.fontFamily]);
                    root.style.setProperty('--font-family-primary', `'${this.cosmeticsData.fontFamily}', sans-serif`);
                    document.querySelectorAll('#cosmetics-modal input[type="color"]').forEach(input => {
                        const cssVar = input.dataset.cssVar;
                        input.value = this.cosmeticsData.colors[cssVar];
                    });
                    const fontSelect = document.getElementById('font-input');
                    fontSelect.value = this.cosmeticsData.fontFamily;
                }

                openCosmeticsModal() {
                    this.applyCosmetics();
                    document.getElementById('cosmetics-modal').style.display = 'flex';
                }

                // ================================================================
                // Settings Modal Methods
                // ================================================================

                openSettingsModal(index) {
                    this.activeModalIndex = index;
                    const buttonData = this.buttonsData[index];
                    const modal = document.getElementById('settings-modal');

                    // Set the initial value of the color picker
                    document.getElementById('button-color-picker').value = buttonData.color;

                    document.getElementById('button-name-input').value = buttonData.name;
                    document.getElementById('shuffle-checkbox').checked = buttonData.shuffle;
                    document.getElementById('autoplay-checkbox').checked = buttonData.autoplay;
                    document.getElementById('priority-checkbox').checked = buttonData.priority;
                    document.getElementById('loop-checkbox').checked = buttonData.loop;
                    this._renderFileList(buttonData.files);

                    modal.style.display = 'flex';
                }

                closeSettingsModal() {
                    const modal = document.getElementById('settings-modal');
                    modal.style.display = 'none';
                    this.activeModalIndex = null;
                    this.renderGrid();
                }

                updateModalButtonData(key, value) {
                    if (this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        buttonData[key] = value;
                        this.updateButton(this.activeModalIndex, buttonData);
                    }
                }

                _renderFileList(files) {
                    const fileListElement = document.getElementById('file-list');
                    fileListElement.innerHTML = ''; // Clear the list first

                    if (files.length === 0) {
                        const emptyItem = document.createElement('li');
                        emptyItem.innerHTML = '<small>No files added yet.</small>';
                        fileListElement.appendChild(emptyItem);
                        return;
                    }

                    files.forEach((file, index) => {
                        const listItem = document.createElement('li');
                        // The button is now just part of the HTML string. The single,
                        // delegated listener on the parent list will handle its click.
                        listItem.innerHTML = `
            <span>${file.fileName}</span>
            <button data-file-index="${index}" class="remove-file-button">Remove</button>
        `;
                        fileListElement.appendChild(listItem);
                        // The old, buggy addEventListener call that was here has been removed.
                    });
                }
                async addFilesToModalButton(event) {
                    if (this.activeModalIndex === null) return;
                    const files = event.target.files;
                    if (files.length === 0) return;
                    const buttonData = this.buttonsData[this.activeModalIndex];
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const arrayBuffer = await file.arrayBuffer();
                        const fileData = { fileName: file.name, mimeType: file.type, arrayBuffer: arrayBuffer };
                        buttonData.files.push(fileData);
                    }
                    await this.updateButton(this.activeModalIndex, buttonData);
                    this._renderFileList(buttonData.files);
                }

                async clearModalButtonFiles() {
                    const confirmed = await this.showConfirmModal("Are you sure you want to clear all audio files for this button?");
                    if (confirmed && this.activeModalIndex !== null) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        player.cleanup();
                        buttonData.files = [];
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                async removeFileFromModalButton(event) {
                    const fileIndex = parseInt(event.target.dataset.fileIndex);
                    if (!isNaN(fileIndex)) {
                        const buttonData = this.buttonsData[this.activeModalIndex];
                        if (!buttonData || !buttonData.files) return;
                        const player = this._getAudioPlayer(this.activeModalIndex);
                        if (player) { player.cleanup(); }
                        buttonData.files.splice(fileIndex, 1);
                        if (buttonData.files.length > 0) { player.playback.currentFileIndex = 0; }
                        await this.db.save(this.activeModalIndex, buttonData);
                        this._renderFileList(buttonData.files);
                    }
                }

                // ================================================================
                // Global Functionality Methods
                // ================================================================

                async openBoardSwitcherModal() {
                    const boardIds = await BoardManager.getBoardList(); // UPDATED
                    const boardListElement = document.getElementById('board-list');
                    const modal = document.getElementById('board-switcher-modal');

                    boardListElement.innerHTML = ''; // Clear previous list

                    if (boardIds.length === 0) {
                        boardListElement.innerHTML = '<li><small>No other boards found. Create one by adding "?board=board-name" to the URL.</small></li>';
                    } else {
                        boardIds.forEach(id => {
                            const listItem = document.createElement('li');
                            const link = document.createElement('a');
                            link.textContent = id;
                            // The 'default' board links to the base URL
                            link.href = (id === 'default') ? window.location.pathname : `?board=${id}`;
                            listItem.appendChild(link);
                            boardListElement.appendChild(listItem);
                        });
                    }

                    modal.style.display = 'flex';
                }

                async _handleRemoveButton() {
                    if (this.activeModalIndex === null) return;
                    const confirmed = await this.showConfirmModal("Are you sure you want to permanently remove this button?");
                    if (confirmed) {
                        await this.removeButton(this.activeModalIndex);
                    }
                }

                // REFACTOR: This method now updates the gridLayout as well.
                async removeButton(indexToRemove) {
                    if (this.buttonsData.length <= 1) {
                        return;
                    }

                    this.buttonsData.splice(indexToRemove, 1);
                    if (this.players.has(indexToRemove)) {
                        this.players.get(indexToRemove).cleanup();
                        this.players.delete(indexToRemove);
                    }

                    // Remove from layout
                    this.gridLayout = this.gridLayout.filter(item => !(item.type === 'sound' && item.id === indexToRemove));

                    // Re-index subsequent button IDs in both data and layout
                    this.buttonsData.forEach((button, i) => {
                        if (i >= indexToRemove) button.id = i;
                    });
                    this.gridLayout.forEach(item => {
                        if (item.type === 'sound' && item.id > indexToRemove) {
                            item.id--;
                        }
                    });

                    // Clear and re-write the database to maintain consistency
                    await this.db._dbRequest(this.db.SOUNDS_STORE, 'readwrite', 'clear');
                    for (const button of this.buttonsData) {
                        await this.db.save(button.id, button);
                    }

                    await this.db.save(this.db.CONFIG_KEY, { id: this.db.CONFIG_KEY, numButtons: this.buttonsData.length });
                    await this._saveLayout();

                    this.closeSettingsModal();
                    this.renderGrid();
                }

                async downloadConfig() {
                    const allData = await this.db.getAll();
                    const soundboardTitle = document.getElementById('soundboard-title').textContent.trim();
                    const serializableData = allData.map(item => {
                        if (item.files && item.files.length > 0) {
                            const serializableFiles = item.files.map(file => ({ ...file, arrayBuffer: this._arrayBufferToBase64(file.arrayBuffer) }));
                            return { ...item, files: serializableFiles };
                        }
                        return item;
                    });
                    const json = JSON.stringify(serializableData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${Date.now()}_${soundboardTitle}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                async uploadConfig(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            const confirmed = await this.showConfirmModal("This will overwrite your current soundboard configuration. Are you sure?");
                            if (confirmed) {
                                const deserializedData = data.map(item => {
                                    if (item.files && item.files.length > 0) {
                                        const deserializedFiles = item.files.map(file => ({ ...file, arrayBuffer: this._base64ToArrayBuffer(file.arrayBuffer) }));
                                        return { ...item, files: deserializedFiles };
                                    }
                                    return item;
                                });

                                await this.db.clear();
                                for (const item of deserializedData) {
                                    await this.db.save(item.id, item);
                                }

                                await this._loadBoardData();
                                alert("Configuration uploaded successfully!");
                            }
                        } catch (e) {
                            alert("Failed to read file. Please ensure it is a valid JSON configuration file.");
                            console.error("Upload error:", e);
                        }
                    };
                    reader.readAsText(file);
                }

                _arrayBufferToBase64(buffer) {
                    let binary = '';
                    const bytes = new Uint8Array(buffer);
                    const len = bytes.byteLength;
                    for (let i = 0; i < len; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return btoa(binary);
                }

                _base64ToArrayBuffer(base64) {
                    const binary_string = atob(base64);
                    const len = binary_string.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binary_string.charCodeAt(i);
                    }
                    return bytes.buffer;
                }

                // ================================================================
                // Modal Manager Methods
                // ================================================================

                async showDbManagerModal() {
                    this.updateDbStats();
                    this.updateDbFileList();

                    const checkbox = document.getElementById('persistent-storage-checkbox');
                    if (navigator.storage && navigator.storage.persisted) {
                        checkbox.parentElement.style.display = ''; // Ensure it's visible
                        const isPersisted = await navigator.storage.persisted();
                        checkbox.checked = isPersisted;
                        checkbox.disabled = isPersisted; // ADD THIS LINE to lock the checkbox
                    } else {
                        // If the API isn't supported, hide the option entirely.
                        checkbox.parentElement.style.display = 'none';
                    }


                    document.getElementById('db-manager-modal').style.display = 'flex';
                }

                closeDbManagerModal() {
                    document.getElementById('db-manager-modal').style.display = 'none';
                }

                async updateDbStats() {
                    const dbSizeEl = document.getElementById('db-usage');
                    const dbQuotaEl = document.getElementById('db-quota');
                    const dbButtonCountEl = document.getElementById('db-button-count');

                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    dbButtonCountEl.textContent = soundData.length;

                    if (navigator.storage && navigator.storage.estimate) {
                        const { quota, usage } = await navigator.storage.estimate();
                        dbSizeEl.textContent = this._formatBytes(usage);
                        dbQuotaEl.textContent = this._formatBytes(quota);
                    } else {
                        dbSizeEl.textContent = 'N/A';
                        dbQuotaEl.textContent = 'N/A';
                    }
                }

                async updateDbFileList() {
                    const fileListEl = document.getElementById('db-file-list');
                    const soundData = await this.db._dbRequest(this.db.SOUNDS_STORE, 'readonly', 'getAll');
                    fileListEl.innerHTML = '';
                    if (soundData.length === 0) {
                        fileListEl.innerHTML = '<li><small>No sounds found.</small></li>';
                        return;
                    }

                    soundData.forEach(item => {
                        const li = document.createElement('li');
                        li.textContent = `Button ${item.id + 1}: ${item.files.length} file(s)`;
                        fileListEl.appendChild(li);
                    });
                }

                async handleClearDatabase() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const boardId = urlParams.get('board') || 'default';

                    if (boardId === 'default') {
                        // --- NEW LOGIC FOR WIPING THE DEFAULT BOARD ---
                        const confirmed = await this.showConfirmModal("This will wipe all cards and settings from the default board but will PRESERVE your list of other boards. Are you sure?");
                        if (confirmed) {
                            try {
                                // 1. Read the board list and keep it in memory.
                                const boardList = await BoardManager.getBoardList();

                                // 2. Clear both object stores completely.
                                await this.db.clear();

                                // 3. Write the board list back to the now-empty database.
                                await BoardManager.saveBoardList(boardList);

                                // 4. Reload the page to show the fresh default board.
                                window.location.reload();

                            } catch (e) {
                                console.error("Failed to wipe default board:", e);
                            }
                        }
                    } else {
                        // --- EXISTING LOGIC FOR DELETING OTHER BOARDS ---
                        const confirmed = await this.showConfirmModal(`This will permanently delete the entire "${boardId}" board. Are you sure?`);
                        if (confirmed) {
                            try {
                                await this.db.clear();
                                await BoardManager.removeBoardId(boardId);
                                window.location.href = window.location.pathname;
                            } catch (e) {
                                console.error("Failed to clear database:", e);
                            }
                        }
                    }
                }

                showConfirmModal(message) {
                    return new Promise(resolve => {
                        const modal = document.getElementById('confirm-modal');
                        const messageEl = document.getElementById('confirm-modal-message');
                        const yesBtn = document.getElementById('confirm-yes-btn');
                        const noBtn = document.getElementById('confirm-no-btn');
                        messageEl.textContent = message;
                        const handler = (e) => {
                            if (e.target === yesBtn) resolve(true);
                            else if (e.target === noBtn) resolve(false);
                            yesBtn.removeEventListener('click', handler);
                            noBtn.removeEventListener('click', handler);
                            modal.style.display = 'none';
                        };
                        yesBtn.addEventListener('click', handler);
                        noBtn.addEventListener('click', handler);
                        modal.style.display = 'flex';
                        modal.style.zIndex = 1001;
                    });
                }

                _formatBytes(bytes, decimals = 2) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const dm = decimals < 0 ? 0 : decimals;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
                }

                // helper bug more stuff

                async initBugMovement() {
    const checkbox = document.getElementById('toggle-bug-movement-checkbox');
    const bug = document.getElementById('help-bug-btn');

    // Load the state and set the initial UI
    const state = await this.db.get("bug-movement");
    const isStill = state ? state.state : false; // Default to false (bug is moving)
    checkbox.checked = isStill;
    
    // Invert the logic: if the bug is 'still', remove the 'bug-moving' class
    bug.classList.toggle('bug-moving', !isStill);

    // Attach the single listener for all future changes
    checkbox.addEventListener('change', async () => {
        const isNowStill = checkbox.checked;
        await this.db.save("bug-movement", { id: "bug-movement", state: isNowStill });
        bug.classList.toggle('bug-moving', !isNowStill);
    });
}

            }





            const app = new SoundboardManager(new SoundboardDB());
            app.initialize();
        });
    </script>


    <!-- THE HELPFUL BUG -->
    <button id="help-bug-btn" title="Help">
        <svg width="100%" height="100%" viewBox="0 0 224 240" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;"><g id="Layer3"></g><rect id="Artboard1" x="0" y="0" width="224" height="240" style="fill:none;"/><clipPath id="_clip1"><rect x="0" y="0" width="224" height="240"/></clipPath><g clip-path="url(#_clip1)"><g id="Layer4"><path d="M60.644,104.58c-11.256,-5.528 -12.727,-5.926 -26.493,-14.801c-13.766,-8.874 -18.652,-15.658 -20.973,-18.747" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M95.436,55.756c-13.129,-12.407 2.698,-28.163 -0.73,-38.025c-5.141,-14.784 -20.837,-13.943 -29.852,-4.11c-5.483,5.98 -8.152,13.151 -7.828,22.714" style="fill:none;stroke:#00a200;stroke-width:6.64px;"/><path d="M127.345,55.361c13.72,-11.75 -1.318,-28.262 2.589,-37.944c5.858,-14.515 21.493,-12.908 30.017,-2.645c5.184,6.241 7.499,13.533 6.708,23.07" style="fill:none;stroke:#00a200;stroke-width:6.64px;"/><path d="M57.333,140.553c-25.39,8.88 -28.701,38.481 -44.155,44.402" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M76.551,178.048c-12.254,11.196 -24.092,15.043 -26.945,27.627c-2.853,12.585 -12.143,20.721 -22.078,31.575" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M163.356,104.58c11.256,-5.528 12.727,-5.926 26.493,-14.801c13.766,-8.874 18.652,-15.658 20.973,-18.747" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M166.667,140.553c25.39,8.88 28.701,38.481 44.155,44.402" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M147.449,178.048c12.254,11.196 24.092,15.043 26.945,27.627c2.853,12.585 12.143,20.721 22.078,31.575" style="fill:none;stroke:#00a200;stroke-width:8.23px;"/><path d="M111.527,48.602c19.855,0 35.975,1.319 35.975,15.263c-0,13.945 -16.12,43.015 -35.975,43.015c-19.856,0 -35.521,-29.07 -35.521,-43.015c-0,-13.944 15.665,-15.263 35.521,-15.263Z" style="fill:#00a200;"/><path d="M110.517,76.417c33.618,-0 60.195,16.364 60.195,55.302c0,38.937 -26.577,85.797 -60.195,85.797c-33.618,-0 -61.263,-46.86 -61.263,-85.797c0,-38.938 27.645,-55.302 61.263,-55.302Z" style="fill:#00a200;"/><path d="M110.517,115.143l-36.286,83.255c-0,-0 13.666,19.426 37.464,19.118c21.992,-0.285 36.807,-21.893 36.807,-21.893l-37.985,-80.48Z" style="fill:#a7b700;"/><circle cx="108.983" cy="193.638" r="14.362" style="fill:#e2ff00;"/><path d="M89.067,113.981c2.248,-8.99 10.114,-17.981 22.21,-17.981c10.381,-0 20.733,6.575 21.619,19.105c0.887,12.53 -14.482,22.051 -20.679,23.6c-4.495,1.124 -4.045,11.614 -4.045,22.852" style="fill:none;stroke:#e2ff00;stroke-width:25.54px;"/></g></g></svg>
    </button>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Soundboard Help & Info</h3>
            </div>

            <div class="help-accordion">

                <div class="accordion-item">
                    <button class="accordion-header active">The Really Simple Soundboard</button>
                    <div class="accordion-content active">
                        <p>Welcome to the Really Simple Soundboard! I made this for my own needs, but then got excited and wanted to make it into something I could share.

                            The driving principle behind this project was to create a dashboard that is designed to be used WHILE recording.

                            It's a simple, customizable soundboard that works in your browser and can be installed as a Progressive Web App (PWA) to use offline.
                            
                            It's also all packed into ONE big HTML file (which I know is bad practice lol) so if you want to copy this whole thing over to your site, all you have to do is save this page.
                            
                            All of your files stay on your device - nothing is uploaded anywhere except your local browser storage! 
                            
                            Initially, it was just a customizable local soundboard, but it has since grown to have different kinds of cards with various features that you can explore in the list below!

                            <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html" target="_blank">Steal this, change it, use it however you'd like!</a> I don't care what you do with it, except for ONE rule: you cannot monetize it.

                            (Tip: click the title at the top to change it to whatever you want!)

                            Created with love by Mason Amadeus for Bug Jennett💖 (and you)
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">The Control Card</button>
                    <div class="accordion-content">
                        <p>This is the card with a bunch of buttons. It's the main hub for managing your soundboard.</p>
                        <ul>
                            <li><b>Add Sound/Timer/Note:</b> Creates a new card of that type!

                                They'll spawn immediately to the LEFT of the control card.

                                (More details about each type can be found in their own dropdowns.)
                            </li>
                            <li><b>Rearrange:</b> Toggles rearrange mode. Click and drag cards to SWAP their positions.
                                
                                I know this is a bit of a PITA. Someday I hope to make it so you can drop cards in-between, and they'll scoot over instead of swapping. If you wanna help, this thing is <a href="https://github.com/masonamadeus/bugandmoss/blob/main/soundboard.html" target="_blank">on github</a>.
                            </li>
                            <li><b>Upload/Download:</b> Save or load your entire board configuration, INCLUDING THE SOUNDS, to a JSON file!
                                
                                It'll pop into your downloads without a popup (probably), and the title will be whatever your board title is.
                                
                                (Nerds: the files are stored as an array buffer in IndexedDB, and converted to base64 when they go into the json)
                            </li>
                            <li><b>Storage:</b> An overview of how much of your browser storage is being used, as well as a setting to toggle "storage durability" which should provide a little extra protection against accidental data loss!
                            
                                This is also where you go to delete your entire board, if you want to do that! It also deletes the associated sound files.
                            </li>
                            <li><b>Cosmetics:</b> Change the colors and font of your soundboard.
                                
                                This is probably the jankiest cosmetic menu on earth, and I'm particularly proud of the font selector lmao.</li>
                            <li><b>Switch Board:</b> Switch between different soundboards, or create new ones!
                                
                                Make as many boards as you want! Just beware that I haven't tested any of this with an extreme amount of buttons/boards/data, so I have no idea what happens if it gets too big.</li>

                                (Nerds: This works by changing the url to have a parameter named after the board name you choose, which causes a new IndexedDB database to be created. I dunno what happens if you make two boards with the same name, but it probably breaks.)
                        </ul>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Sound Buttons</button>
                    <div class="accordion-content">
                    <p>
                        <b>Play a sound</b> by clicking the big button.

                        <b>Stop a sound</b> by clicking the button while a sound is playing.

                        If there are multiple files, this will skip to the next file (depending on the other options explained below).

                        <b>Volume</b> affects how loud the sound plays.

                        <b>Speed</b> affects the playback speed of the sound. It's a bit jank, but it's pretty fun.

                        <b>Edit the button</b> by clicking the colorful triangle corner in the bottom right of the button.

                        Inside the settings menu you can:

                        <b>Change the button color</b> using the little colored square to the left of the button title field.

                        <b>Change the button name</b> by clicking on the title field and typing a new name.

                        <b>Multiple sounds</b> can be added to a button. There is no limit! You can remove individual files from the list, or clear them all using labeled buttons.

                        <b>Random</b> will randomly select a file from that button each time it is clicked to play.

                        <b>Autoplay</b> will automatically play the next sound when the currently playing sound ends.

                        <b>Priority</b> is useful for situations like playing a bumper over music. Any buttons with "Priority" will temporarly turn down any non-priority buttons until the priority sound finishes.
                        It's auto-ducking, basically!

                        <b>Loop</b> will loop whatever sound is playing, restarting it when it ends.
                    </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Timers</button>
                    <div class="accordion-content">
                        <p>Timers run a countdown, and can also trigger buttons at the start and end!
                            
                            Uncheck "Lock Timer Settings" to edit the timer properties:

                            <b>"Starts With"</b> lets you select a button to play when the timer starts.

                            <b>"Ends With"</b> lets you select a button to play at the end of the timer -- with a catch!

                            When you have selected an "Ends With" sound, <b><i>the timer will hit 0:00 exactly as the "Ends With" sound FINISHES playing!</b></i>
                            
                            This makes it a powerful tool for timed segments, as you can input the desired segment length and your outro cue will 'play you out' automagically!
                            
                            Sometimes this function fails to calculate the length of the end cue (I've only had it fail on mobile), and as a fallback - it will play when the timer ends. But 99% of the time, the Timer Card should end WITH the sound.
                            The timer is pretty accurate, and stays running even if the tab is in the background or the page is refreshed!

                            <b>Start</b> will start the timer

                            <b>Reset</b> will stop and reset the timer to its initial time, but WILL NOT reset any other settings (like Starts & Ends With cues)
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Notepads</button>
                    <div class="accordion-content">
                        <p>A simple place to keep notes!
                            
                            I like to use it to copy/paste URLs for articles or stuff we talk about on the show. Or to jot down stuff to talk about on future shows.

                            You can even store multiple notes in a single card. Click the little "+" button to add a new tab inside the note card.
                            
                            You can edit the title of a note by clicking the text "New Note" and changing it to whatever you want.

                            Other than that it's just a text box. Go crazy!
                        </p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">Offline Use (PWA)</button>
                    <div class="accordion-content">
                        <p>This soundboard is an installable Progressive Web App (PWA).
                            
                            Use the "Install" button in your browser's address bar to add it to your desktop.
                            
                            It will work completely offline! ALL of your data is stored ONLY on your device. I don't want to pay for a server lmao.
                            
                            Your data is stored locally and can be protected from automatic cleanup by enabling "Storage Durability" in the Storage menu.

                            IndexedDB is pretty robust, and doesn't tend to clear out unless you're REALLY low on space - so you probably don't even need to worry.
                        
                        </p>
                    </div>
                </div>

                <div class="modal-checkbox-group" style="margin-top: 1rem">
                    <label>
                        <input type="checkbox" id="toggle-bug-movement-checkbox">
                        Hold still, Bug!
                    </label>
            </div>

        </div>
    </div>
</body>

</html>