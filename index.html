<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug & Moss</title>
    <!-- Podcast Player Config: Edit this block for your podcast! -->
    <script id="podcast-config">
        window.PODCAST_CONFIG = {
            name: "Waking Up with Bug & Moss",
            rssFeed: "https://pinecast.com/jsonfeed/bug-and-moss",
            rssButton: "https://pinecast.com/feed/bug-and-moss",
            colors: {
                background: "#f7fafc",      // backgrounds
                panel: "#e3f0ff",           // panels/lists
                accent: "#3bb273",          // accent
                highlight: "#ff914d",       // highlight
                primary: "#234e70"          // deep blue
            },
            fonts: {
                body: "'Wellfleet', sans-serif",
                heading: "'Love Ya Like A Sister', cursive, sans-serif"
            },
            artFallback: "https://placehold.co/200x200/e2e8f0/475569?text=Podcast"
        };
    </script>

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta property="og:title" content="Bug & Moss" />
    <meta property="og:description" content="Every(ish) morning, wake up with Bug and Moss! Voted #1 Syndicated Morning Radio Program in the universe." />
    <meta property="og:image" content="https://bugandmoss.com/apple-touch-icon.png" />
    <meta property="og:url" content="https://bugandmoss.com/" />
    <meta property="og:type" content="website" />


    <style>
        /* General Styles */
        body {
            font-family: var(--scq-font-body);
            font-size: larger;
            background-color: var(--scq-primary);
            overflow: hidden;
            width: 100%;
            min-height: 100vh;
            /* Fallback for browsers that don't support dvh */
            min-height: 100dvh;
            /* Dynamic viewport height - adjusts for mobile browser chrome */
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0.5rem;
            box-sizing: border-box;
        }

        h1,
        h2,
        h3,
        .now-playing-title,
        .episode-list-title {
            font-family: var(--scq-font-heading);
        }

        .subscribe-section {
            display: flex;
            flex-direction: column;
            width: 100%;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .subscribe-buttons {
            width: 100%;
            justify-content: space-between;
            display: flex;
            gap: 0.75rem;
        }

        .subscribe-btn {
            display: flex;
            align-items: center;
            gap: 0.4em;
            background: var(--scq-highlight);
            color: var(--scq-background);
            font-family: var(--scq-font-body);
            font-weight: bold;
            font-size: 0.95rem;
            border: none;
            border-radius: 999px;
            padding: 0.5rem 1.1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
            text-decoration: none;
        }

        .subscribe-btn:hover {
            background: var(--scq-accent);
            color: var(--scq-background);
        }

        #container {
            width: min(95vw, 95vh);
            height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: var(--scq-background);
            border-radius: 1.25rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
        }

        .player-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 1.5rem;
            height: 100%;
            min-height: 0;
        }

        /* Audio Player Styles */
        .audio-player-section {
            padding: 0rem;
            border-radius: 0.75rem;
        }


        .now-playing-flip-container {
            perspective: 900px;
            width: 100%;
            max-width: 50%;
            min-width: 80px;
            aspect-ratio: 1/1;
            margin: 0 auto 0.5rem auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 50vh;
            transition: max-height 0.4s cubic-bezier(.4,2,.6,1);
        }
        .now-playing-flip-container.flipped {
            /* When flipped, allow the shownotes card to expand taller */
            max-height: 60vh;
        }
        .now-playing-flipper {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            height: 100%;
            transition: transform 0.6s cubic-bezier(.4,2,.6,1);
            transform-style: preserve-3d;
            min-width: 80px;
            max-width: 100%;
            max-height: 100%;
        }
        .now-playing-flip-container.flipped .now-playing-flipper {
            transform: rotateY(180deg);
        }
        .now-playing-art, .now-playing-shownotes {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 4px solid var(--scq-highlight);
            overflow: hidden;
            min-width: 80px;
            max-width: 100%;
            max-height: 100%;
        }

        /* Wiggle animation for show art */
        @keyframes wiggle {
            0% { transform: rotate(0deg); }
            10% { transform: rotate(-5deg); }
            20% { transform: rotate(4deg); }
            30% { transform: rotate(-3deg); }
            40% { transform: rotate(2deg); }
            50% { transform: rotate(0deg); }
            100% { transform: rotate(0deg); }
        }
        .now-playing-art.wiggle {
            animation: wiggle 0.7s cubic-bezier(.36,.07,.19,.97) both;
    }
        
        .now-playing-art {
            object-fit: cover;
            transition: all 0.3s;
            background: var(--scq-background);
            width: 100%;
            height: 100%;
            max-height: 100%;
        }
        .now-playing-shownotes {
            background: var(--scq-panel);
            color: var(--scq-primary);
            font-family: var(--scq-font-body);
            font-size: 1rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            transform: rotateY(180deg);
            overflow-y: auto;
            text-align: left;
            min-width: 80px;
            max-width: 100%;
            max-height: 100%;
        }

        /* Improve shownotes readability */
        .now-playing-shownotes p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            line-height: 1.5;
        }
        .now-playing-shownotes hr {
            border: none;
            border-top: 2px solid var(--scq-primary);
            width: 100%;
            margin: 1em 0;
        }
        @media (max-width: 600px) {
            #container {
                height: 100dvh;
                min-height: 100dvh;
                max-height: 100dvh;
            }
            .now-playing-flip-container {
                width: 100%;
                aspect-ratio: 1/1;
                max-width: 60%;
                max-height: 10%;
                margin-bottom: 1.2rem;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .now-playing-flip-container.flipped {
                max-height: 70%;
                aspect-ratio: unset;
            }
            .now-playing-flipper {
                width: 100%;
                aspect-ratio: 1/1;
                max-width: 100vw;
                max-height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .now-playing-art {
                aspect-ratio: 1/1;
                width: 100%;
                height: 100%;
                left: 0;
                top: 0;
                max-width: 100vw;
                max-height: 100%;
                margin: 0 auto;
            }
            .now-playing-flip-container.flipped .now-playing-shownotes {
                aspect-ratio: unset !important;
                width: 150%;
                min-height: 60%;
                max-height: 150%;
                left: 50%;
                top: 0;
                transform: translateX(-50%) rotateY(180deg);
                display: flex;
                justify-content: flex-start;
                align-items: flex-start;
            }
            .now-playing-shownotes {
                left: 0;
                transform: rotateY(180deg);
                width: 100%;
                max-width: 150%;
                max-height: 100%;
                margin: 0 auto;
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                justify-content: flex-start;
                font-size: 0.6rem;
            }
        }

        .now-playing-info {
            margin-bottom: 0.5rem;
            margin-top: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Add min-width to allow the children to shrink */
            min-width: 0;
        }

        .now-playing-title {
            /* Prevent text from wrapping and truncate it with an ellipsis */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;

            /* You can keep the clamp font size for initial scaling, but the above properties are the key to preventing wrapping */
            font-size: clamp(1rem, 4vw, 3rem);
            font-weight: bold;
            color: var(--scq-primary);
            text-align: center;
            margin: 0;
            max-width: 100%;
        }

        .controls-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .controls-container button.control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25em;
        }

        .control-button {
            background-color: var(--scq-highlight);
            color: var(--scq-background);
            font-weight: bold;
            font-size: 0.75rem;
            font-family: var(--scq-font-body);
            padding: 0.5rem 0.75rem;
            border-radius: 9999px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: all 0.15s;
            border: none;
            cursor: pointer;
        }

        .control-button:hover {
            background-color: var(--scq-primary);
        }

        .play-pause-button {
            background-color: var(--scq-accent);
            color: var(--scq-primary);
            padding: 0.5rem 1rem;
        }

        .play-pause-button:hover {
            background-color: var(--scq-primary);
            color: var(--scq-highlight);
        }

        .play-pause-button:hover #play-pause-icon svg polygon,
        .play-pause-button:hover #play-pause-icon svg rect {
            fill: var(--scq-highlight);
        }

        .progress-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0rem;
        }

        .time-label {
            font-size: 0.75rem;
            color: #718096;
            min-width: 40px;
            text-align: right;
        }

        .progress-bar-container {
            flex: 1;
            height: 0.5rem;
            background-color: var(--scq-panel);
            border-radius: 0.25rem;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 0.5rem;
            background-color: var(--scq-highlight);
            border-radius: 0.25rem;
            transition: all 0.1s;
            width: 0;
        }

        .progress-knob {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--scq-highlight);
            border: 2px solid var(--scq-primary);
            border-radius: 50%;
            width: 1rem;
            height: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            left: 0;
        }

        .audio-element {
            width: 100%;
            border-radius: 0.75rem;
            border: 2px solid var(--scq-highlight);
            background-color: var(--scq-panel);
            outline: none;
        }

        /* Loading and Error Styles */
        .loading-container,
        .error-container {
            text-align: center;
            padding: 2rem;
        }

        .loading-spinner {
            animation: spin 1s linear infinite;
            height: 2rem;
            width: 2rem;
            color: var(--scq-accent);
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 0.5rem;
            color: var(--scq-primary);
        }

        .error-container {
            background-color: #FEE2E2;
            color: #C53030;
            border-radius: 0.5rem;
        }

        .error-title {
            font-weight: bold;
        }

        .error-text {
            font-size: 0.875rem;
        }

        /* Episode List Styles */
        .episode-list-section {
            display: flex;
            flex-direction: column;
            flex: 1 1 0%;
            min-height: 0;
        }

        .episode-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0rem;
            margin-bottom: 0rem;
        }

        .episode-list-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--scq-primary);
        }

        .autoplay-toggle {
            font-family: var(--scq-font-body);
            position: relative;
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            transition: all 0.2s;
            background-color: var(--scq-background);
            color: var(--scq-highlight);
            font-weight: bold;
            font-size: 0.7rem;
            outline: none;
            cursor: pointer;
            gap: 0.5em;
            border: none;
            display: flex;
            align-items: center;
        }

        .autoplay-checkbox {
            width: 1em;
            height: 1em;
            border: 2px solid var(--scq-highlight);
            border-radius: 0.25em;
            background: var(--scq-background);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, border-color 0.2s;
        }

        .autoplay-checkbox.checked {
            background: var(--scq-highlight);
            border-color: var(--scq-highlight);
        }

        .autoplay-checkbox svg {
            display: block;
            width: 0.8em;
            height: 0.8em;
            color: var(--scq-background);
        }

        .sort-toggle {
            background-color: var(--scq-highlight);
            color: var(--scq-background);
            font-family: var(--scq-font-body);
            font-size: 0.7rem;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: all 0.15s;
            border: none;
            cursor: pointer;
        }

        .sort-toggle:hover {
            background-color: var(--scq-primary);
        }

        .episode-list {
            background-color: var(--scq-panel);
            border-radius: 0.75rem;
            padding-right: 0.5rem;
            min-height: 0;
            height: 0;
            flex-grow: 1;
            overflow-y: auto;
        }

        /* Custom scrollbar for webkit browsers */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--scq-background);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--scq-highlight);
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: var(--scq-primary);
        }

        .episode-item {
            padding: 0.2rem;
            padding-left: 1rem;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 0 0.5rem 0;
        }

        .episode-item:last-child {
            margin-bottom: 0;
        }

        .episode-item:hover {
            background-color: var(--scq-accent);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .episode-item-active {
            background-color: var(--scq-accent);
            border-left: 4px solid var(--scq-highlight);
        }

        .episode-item-title {
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--scq-primary);
            margin: 0
        }

        .episode-item-date {
            font-size: 0.5rem;
            color: var(--scq-highlight);
            margin: 0
        }

        /* Footer Styles */
        .footer {
            margin-top: 0.5rem;
            text-align: right;
            font-family: var(--scq-font-heading);
            color: #1768da;
            font-style: italic;
            font-size: 0.625rem;
            flex-shrink: 0;
            text-decoration: none;
        }

        .hidden {
            display: none !important;
        }

        .controls-container svg {
            vertical-align: middle;
            position: static;
            top: 0;
            /* Remove previous top adjustment */
        }

        @media (max-width: 600px) {
            .autoplay-toggle {
                font-size: 0.55rem;
                padding: 0.4rem 0.5rem;
            }

            .autoplay-checkbox {
                width: 0.9em;
                height: 0.9em;
            }

            #autoplay-label {
                font-size: 0.9em;
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="player-container">
            <!-- Audio Player Section -->
            <div class="audio-player-section">
                <!-- Now Playing Art and Title -->

                <div class="now-playing-info">
                    <div class="now-playing-flip-container" id="now-playing-flip-container">
                        <div class="now-playing-flipper">
                            <img id="now-playing-art" src="" alt="Now Playing Art" class="now-playing-art">
                            <div id="now-playing-shownotes" class="now-playing-shownotes" style="display: flex;"></div>
                        </div>
                    </div>
                    <h2 id="now-playing-title" class="now-playing-title"></h2>
                </div>
                <!-- Audio Controls -->
                <div class="controls-container">
                    <button id="jump-back" title="Jump Back" class="control-button">
                        <!-- SVG for rewind -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" style="vertical-align:middle">
                            <path d="M11 18V6L2 12l9 6zm1-6l9 6V6l-9 6z" fill="currentColor" />
                        </svg>
                        <span id="jump-back-label"></span>
                    </button>
                    <button id="play-pause" title="Play/Pause" class="control-button play-pause-button">
                        <!-- SVG for play (default, JS will swap for pause as needed) -->
                        <span id="play-pause-icon">
                            <svg width="28" height="28" viewBox="0 0 28 28" fill="none" style="vertical-align:middle">
                                <polygon points="7,5 23,14 7,23" fill="currentColor" />
                            </svg>
                        </span>
                    </button>
                    <button id="jump-forward" title="Jump Forward" class="control-button">
                        <!-- SVG for fast forward -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" style="vertical-align:middle">
                            <path d="M13 6v12l9-6-9-6zm-1 6L3 6v12l9-6z" fill="currentColor" />
                        </svg>
                        <span id="jump-forward-label"></span>
                    </button>
                </div>

                <!-- Progress Bar -->
                <div id="progress-container" class="progress-container">
                    <span id="current-time" class="time-label">0:00</span>
                    <div class="progress-bar-container">
                        <div id="progress-bar" class="progress-bar"></div>
                        <div id="progress-knob" class="progress-knob"></div>
                    </div>
                    <span id="duration" class="time-label">0:00</span>
                </div>
                <audio id="audio-player" class="audio-element">
                    Your browser does not support the audio element.
                </audio>
            </div>
            <!-- Loading Spinner -->
            <div id="loading" class="loading-container hidden">
                <svg class="loading-spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                <p class="loading-text">Loading episodes...</p>
            </div>
            <!-- Error Message -->
            <div id="error-message" class="error-container hidden">
                <h3 class="error-title">Oops! Something went wrong.</h3>
                <p id="error-text" class="error-text">Could not fetch the podcast feed. Please check the RSS URL and
                    your
                    network connection.</p>
            </div>
            <!-- Episode List Section -->
            <div class="episode-list-section">
                <div class="episode-list-header">
                    <div class="flex items-center gap-3">
                        <h3 class="episode-list-title">Episodes</h3>

                    </div>
                    <button id="autoplay-toggle" class="autoplay-toggle" aria-pressed="false" type="button">
                        <span id="autoplay-checkbox" class="autoplay-checkbox">
                            <!-- SVG checkmark will be injected here if checked -->
                        </span>
                        <span id="autoplay-label">Autoplay Next</span>
                    </button>
                    <button id="sort-toggle" class="sort-toggle">
                        Sort: Most Recent
                    </button>
                </div>
                <div id="episode-list" class="episode-list custom-scrollbar">
                    <!-- Episodes will be dynamically inserted here -->
                </div>
                <div class="subscribe-section" style="margin-top:0.5rem; margin-bottom:0; align-items: center;">
                    <div class="subscribe-buttons">

                        <button id="rss-btn" class="subscribe-btn" type="button" title="Subscribe via RSS">
                            Subscribe via RSS
                        </button>
                <!-- RSS Copied Popup -->
                <div id="rss-popup" style="
                    display: none;
                    position: fixed;
                    left: 50%;
                    top: 10%;
                    transform: translate(-50%, 0);
                    background: var(--scq-primary, #234e70);
                    color: var(--scq-background, #f7fafc);
                    padding: 1rem 2rem;
                    border-radius: 1rem;
                    font-size: 1.1rem;
                    font-family: var(--scq-font-body, sans-serif);
                    z-index: 9999;
                    box-shadow: 0 4px 24px rgba(0,0,0,0.18);
                    text-align: center;
                ">
                    RSS Link Copied!<br>Paste this link into your podcast player of choice to subscribe.
                </div>

                        <a href="https://poweredbypodcube.com/" class="footer" style="font-family:'Nova Square'">Player by PodCube™</a>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Google Fonts: Dynamically loaded based on config -->
    <script>
        // Dynamically load Google Fonts based on config
        (function () {
            const config = window.PODCAST_CONFIG;
            if (!config || !config.fonts) return;
            // Helper to extract font names from CSS font-family string
            function extractFontNames(fontString) {
                return fontString.split(',').map(f => f.trim().replace(/^['"]|['"]$/g, ''));
            }
            // Only add Google Fonts for fonts that are not generic families
            const generic = ["serif", "sans-serif", "cursive", "monospace", "fantasy", "system-ui", "ui-sans-serif", "ui-serif", "ui-monospace", "ui-rounded", "emoji", "math", "fangsong"];
            let fontSet = new Set();
            ['body', 'heading'].forEach(key => {
                if (config.fonts[key]) {
                    extractFontNames(config.fonts[key]).forEach(f => {
                        if (f && !generic.includes(f.toLowerCase())) fontSet.add(f);
                    });
                }
            });
            if (fontSet.size > 0) {
                // Build Google Fonts URL
                const families = Array.from(fontSet).map(f => f.replace(/ /g, '+') + ':wght@400;700').join('&family=');
                const url = `https://fonts.googleapis.com/css2?family=${families}&family=Nova+Square&display=swap`;
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = url;
                document.head.appendChild(link);
            }
        })();
    </script>

    <script>
        // --- CONFIGURATION FROM PODCAST_CONFIG ---
        const CONFIG = window.PODCAST_CONFIG;
        // Set CSS variables for colors and fonts
        function setThemeVars() {
            const root = document.documentElement;
            root.style.setProperty('--scq-background', CONFIG.colors.background);
            root.style.setProperty('--scq-panel', CONFIG.colors.panel);
            root.style.setProperty('--scq-accent', CONFIG.colors.accent);
            root.style.setProperty('--scq-highlight', CONFIG.colors.highlight);
            root.style.setProperty('--scq-primary', CONFIG.colors.primary);
            root.style.setProperty('--scq-font-body', CONFIG.fonts.body);
            root.style.setProperty('--scq-font-heading', CONFIG.fonts.heading);
        }
        setThemeVars();

        

        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const RSS_FEED_URL = CONFIG.rssFeed;
            const PODCAST_NAME = CONFIG.name;
            const ART_FALLBACK = CONFIG.artFallback;
            const RSS_BUTTON_URL = CONFIG.rssButton;
            const JUMP_SECONDS = 15;

            // --- ELEMENT REFERENCES ---
            const audioPlayer = document.getElementById('audio-player');
            const episodeList = document.getElementById('episode-list');
            const nowPlayingTitle = document.getElementById('now-playing-title');
            const loadingIndicator = document.getElementById('loading');
            const errorMessage = document.getElementById('error-message');
            const errorText = document.getElementById('error-text');
            const sortToggle = document.getElementById('sort-toggle');
            const jumpBackBtn = document.getElementById('jump-back');
            const jumpForwardBtn = document.getElementById('jump-forward');
            const playPauseBtn = document.getElementById('play-pause');
            const jumpBackLabel = document.getElementById('jump-back-label');
            const jumpForwardLabel = document.getElementById('jump-forward-label');
            const nowPlayingArt = document.getElementById('now-playing-art');
            const autoplayToggle = document.getElementById('autoplay-toggle');
            const autoplayLabel = document.getElementById('autoplay-label');
            const autoplayCheckbox = document.getElementById('autoplay-checkbox');
            const rssBtn = document.getElementById('rss-btn');
            let showArtUrl = ART_FALLBACK;
            let currentShownotes = '';
            let podcastDescription = '';

            // --- STATE ---
            let feedData = null;
            let sortDescending = true; // Newest first by default
            let chronologicalEpisodes = []; // Always oldest-to-newest for autoplay
            let currentEpisodeId = null; // Use episode id for reliable lookup
            let autoplayEnabled = false; // Added

            // --- INIT JUMP LABELS ---
            jumpBackLabel.textContent = `-${JUMP_SECONDS}s`;
            jumpForwardLabel.textContent = `+${JUMP_SECONDS}s`;

            // --- SET PODCAST NAME, ART, RSS BUTTON ---
            nowPlayingTitle.textContent = PODCAST_NAME;
            nowPlayingArt.src = ART_FALLBACK;

            // Remove href, since now it's a button
            // rssBtn.href = RSS_BUTTON_URL;

            // --- RSS BUTTON COPY TO CLIPBOARD ---
            const rssPopup = document.getElementById('rss-popup');
            rssBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                try {
                    await navigator.clipboard.writeText(RSS_BUTTON_URL);
                    // Show popup
                    rssPopup.style.display = 'block';
                    setTimeout(() => {
                        rssPopup.style.display = 'none';
                    }, 3500);
                } catch (err) {
                    // fallback: alert
                    alert('Could not copy RSS link. Please copy manually: ' + RSS_BUTTON_URL);
                }
            });

            // --- HELPER FUNCTIONS ---
            const formatTime = (sec) => {
                if (isNaN(sec)) return '0:00';
                const minutes = Math.floor(sec / 60);
                const seconds = Math.floor(sec % 60).toString().padStart(2, '0');
                return `${minutes}:${seconds}`;
            };

            const clearEpisodeHighlight = () => {
                document.querySelectorAll('.episode-item').forEach(el => el.classList.remove('episode-item-active'));
            };

            const highlightNowPlaying = (episodeId) => {
                clearEpisodeHighlight();
                const episodeElement = document.querySelector(`.episode-item[data-episode-id="${episodeId}"]`);
                if (episodeElement) {
                    episodeElement.classList.add('episode-item-active');
                }
            };

            function updateAutoplayCheckbox() {
                if (autoplayEnabled) {
                    autoplayCheckbox.classList.add('checked');
                    autoplayCheckbox.innerHTML = `<svg viewBox="0 0 16 16" fill="none"><polyline points="3,8 7,12 13,4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                    autoplayToggle.setAttribute('aria-pressed', 'true');
                } else {
                    autoplayCheckbox.classList.remove('checked');
                    autoplayCheckbox.innerHTML = '';
                    autoplayToggle.setAttribute('aria-pressed', 'false');
                }
            }

            // --- CORE FUNCTIONS ---
            async function fetchPodcastFeed() {
                loadingIndicator.classList.remove('hidden');
                errorMessage.classList.add('hidden');
                episodeList.innerHTML = '';

                try {
                    const response = await fetch(RSS_FEED_URL);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    feedData = data;
                    updatePodcastInfo(data);
                    populateEpisodeList(data);
                } catch (error) {
                    console.error('Error fetching or parsing feed:', error);
                    errorText.textContent = error.message;
                    errorMessage.classList.remove('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            function updatePodcastInfo(feed) {
                showArtUrl = feed.icon || ART_FALLBACK;
                nowPlayingArt.src = showArtUrl;
                nowPlayingTitle.textContent = PODCAST_NAME;
                // Set podcast description from feed if available
                if (feed && (feed.description || feed.summary)) {
                    podcastDescription = feed.description || feed.summary;
                }
            }

            function populateEpisodeList(feed) {
                let items = feed.items || [];
                chronologicalEpisodes = [...items].sort((a, b) => new Date(a.date_published) - new Date(b.date_published));
                let displayItems = sortDescending ? [...items] : [...items].reverse();

                if (displayItems.length === 0) {
                    episodeList.innerHTML = '<p class="text-gray-500 text-center">No episodes found.</p>';
                    return;
                }

                episodeList.innerHTML = '';
                const fragment = document.createDocumentFragment();

                displayItems.forEach(item => {
                    const {
                        title = 'Untitled Episode',
                        attachments,
                        date_published,
                        image,
                        id
                    } = item;
                    const audioUrl = attachments?.[0]?.url;
                    const formattedDate = date_published ? new Date(date_published).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    }) : '';
                    const episodeArt = image || attachments?.[0]?.image || showArtUrl;

                    if (audioUrl) {
                        const episodeElement = document.createElement('div');
                        episodeElement.className = 'episode-item';
                        episodeElement.dataset.episodeId = id;
                        episodeElement.innerHTML = `
                            <p class="episode-item-title">${title}</p>
                            <p class="episode-item-date">${formattedDate}</p>
                        `;
                        episodeElement.addEventListener('click', () => {
                            playEpisode(title, audioUrl, episodeArt, id);
                        });

                        if (id === currentEpisodeId) {
                            episodeElement.classList.add('episode-item-active');
                        }
                        fragment.appendChild(episodeElement);
                    }
                });
                episodeList.appendChild(fragment);
            }


            function playEpisode(title, audioUrl, episodeArt, episodeId = null) {
                nowPlayingTitle.textContent = title;
                audioPlayer.src = audioUrl;
                audioPlayer.play();
                updatePlayPauseIcon();
                nowPlayingArt.src = episodeArt || showArtUrl;
                nowPlayingArt.onerror = () => {
                    nowPlayingArt.src = showArtUrl;
                };
                currentEpisodeId = episodeId;
                highlightNowPlaying(episodeId);

                // Update shownotes/description
                let desc = '';
                if (feedData && episodeId) {
                    const ep = feedData.items.find(item => item.id === episodeId);
                    if (ep) {
                        // Try all possible fields for description
                        desc = ep.summary || ep.description || ep.content_html || ep.content_text || ep['itunes:summary'] || '';
                        // If still empty, try to extract from content if it's an object
                        if (!desc && ep.content && typeof ep.content === 'string') desc = ep.content;
                    }
                }
                // If still empty, show fallback
                currentShownotes = desc ? desc : '<em>No description available.</em>';
                document.getElementById('now-playing-shownotes').innerHTML = currentShownotes;
                // Always reset to art side when new episode plays
                document.getElementById('now-playing-flip-container').classList.remove('flipped');
            }
            // --- FLIP ART TO SHOW SHOWNOTES ---
            const flipContainer = document.getElementById('now-playing-flip-container');
            const shownotesDiv = document.getElementById('now-playing-shownotes');
            const artImg = document.getElementById('now-playing-art');
            let flipTimeout = null;
            // Show podcast description if no episode is selected and card is flipped
            function updateShownotesForFlip() {
                if (flipContainer.classList.contains('flipped')) {
                    if (!currentEpisodeId) {
                        shownotesDiv.innerHTML = podcastDescription;
                    } else {
                        shownotesDiv.innerHTML = currentShownotes;
                    }
                } else {
                    // Optionally clear or reset shownotesDiv if needed
                }
            }
            function toggleFlip() {
                flipContainer.classList.toggle('flipped');
                // Always scroll shownotes to top when flipping (in either direction)
                shownotesDiv.scrollTop = 0;
                if (shownotesDiv.scrollTo) shownotesDiv.scrollTo({ top: 0, behavior: 'auto' });
                updateShownotesForFlip();
            }
            artImg.addEventListener('click', toggleFlip);
            artImg.addEventListener('touchend', function(e) {
                // Prevent double tap zoom
                e.preventDefault();
                toggleFlip();
            });
            // Also update shownotes if card is flipped by other means
            flipContainer.addEventListener('transitionend', updateShownotesForFlip);
            // Also scroll to top after transition for iOS reliability
            flipContainer.addEventListener('transitionend', function() {
                shownotesDiv.scrollTop = 0;
                if (shownotesDiv.scrollTo) shownotesDiv.scrollTo({ top: 0, behavior: 'auto' });
            });
            // --- SHOWNOTES FLIP: Only flip back on tap, not on scroll ---
            let shownotesTouchStartY = null;
            let shownotesTouchMoved = false;
            shownotesDiv.addEventListener('click', toggleFlip);
            shownotesDiv.addEventListener('touchstart', function(e) {
                if (e.touches && e.touches.length === 1) {
                    shownotesTouchStartY = e.touches[0].clientY;
                    shownotesTouchMoved = false;
                }
            }, { passive: true });
            shownotesDiv.addEventListener('touchmove', function(e) {
                if (shownotesTouchStartY !== null && e.touches && e.touches.length === 1) {
                    const deltaY = Math.abs(e.touches[0].clientY - shownotesTouchStartY);
                    if (deltaY > 10) shownotesTouchMoved = true;
                }
            }, { passive: true });
            shownotesDiv.addEventListener('touchend', function(e) {
                // Only flip if it was a tap, not a scroll
                if (!shownotesTouchMoved) {
                    e.preventDefault();
                    toggleFlip();
                }
                shownotesTouchStartY = null;
                shownotesTouchMoved = false;
            });

            function updatePlayPauseIcon() {
                if (audioPlayer.paused) {
                    playPauseBtn.innerHTML = `
                <span id="play-pause-icon">
                    <svg width="28" height="28" viewBox="0 0 28 28" fill="none" style="vertical-align:middle"><polygon points="7,5 23,14 7,23" fill="currentColor"/></svg>
                </span>
            `;
                } else {
                    playPauseBtn.innerHTML = `
                <span id="play-pause-icon">
                    <svg width="28" height="28" viewBox="0 0 28 28" fill="none" style="vertical-align:middle"><rect x="6" y="5" width="5" height="18" fill="currentColor"/><rect x="17" y="5" width="5" height="18" fill="currentColor"/></svg>
                </span>
            `;
                }
            }

            // --- EVENT LISTENERS ---

            sortToggle.addEventListener('click', () => {
                sortDescending = !sortDescending;
                sortToggle.textContent = sortDescending ? 'Sort: Most Recent' : 'Sort: Release Order';
                if (feedData) populateEpisodeList(feedData);
            });

            jumpBackBtn.addEventListener('click', () => {
                audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - JUMP_SECONDS);
            });

            jumpForwardBtn.addEventListener('click', () => {
                audioPlayer.currentTime = Math.min(audioPlayer.duration || 0, audioPlayer.currentTime + JUMP_SECONDS);
            });

            playPauseBtn.addEventListener('click', () => {
                // If no audio source is set, find the first episode and play it
                if (!audioPlayer.src || audioPlayer.src === window.location.href) {
                    // Find the first episode item in the list
                    const firstEpisode = document.querySelector('.episode-item');
                    if (firstEpisode) {
                        // Get the ID of the first episode
                        const firstEpisodeId = firstEpisode.dataset.episodeId;
                        // Find the corresponding episode data from the feed
                        const episodeData = feedData.items.find(item => item.id === firstEpisodeId);
                        if (episodeData) {
                            // Play the first episode using the existing playEpisode function
                            const {
                                title = 'Untitled Episode',
                                attachments,
                                image,
                                id
                            } = episodeData;
                            const audioUrl = attachments?.[0]?.url;
                            const episodeArt = image || attachments?.[0]?.image || showArtUrl;
                            if (audioUrl) {
                                playEpisode(title, audioUrl, episodeArt, id);
                            }
                        }
                    }
                } else {
                    // If an episode is already loaded, just toggle play/pause as normal
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                    } else {
                        audioPlayer.pause();
                    }
                }
            });

            audioPlayer.addEventListener('play', updatePlayPauseIcon);
            audioPlayer.addEventListener('pause', updatePlayPauseIcon);

            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressKnob = document.getElementById('progress-knob');
            const currentTimeEl = document.getElementById('current-time');
            const durationEl = document.getElementById('duration');

            function updateProgress() {
                const duration = audioPlayer.duration || 0;
                const current = audioPlayer.currentTime || 0;
                const percent = duration ? (current / duration) * 100 : 0;
                progressBar.style.width = percent + '%';
                progressKnob.style.left = `calc(${percent}% - 8px)`;
                currentTimeEl.textContent = formatTime(current);
                durationEl.textContent = formatTime(duration);
            }


            // --- SCRUBBING/DRAGGING SUPPORT FOR PROGRESS KNOB ---
            let isSeeking = false;
            let wasPlaying = false;

            // Helper to get percent from event
            function getPercentFromEvent(e) {
                const rect = progressContainer.getBoundingClientRect();
                let clientX;
                if (e.touches && e.touches.length) {
                    clientX = e.touches[0].clientX;
                } else {
                    clientX = e.clientX;
                }
                const x = clientX - rect.left;
                return Math.max(0, Math.min(1, x / rect.width));
            }

            // Mouse events
            progressKnob.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isSeeking = true;
                wasPlaying = !audioPlayer.paused;
                audioPlayer.pause();
                document.body.style.userSelect = 'none';
            });

            // Track last percent while dragging
            let lastSeekPercent = 0;
            document.addEventListener('mousemove', (e) => {
                if (isSeeking) {
                    lastSeekPercent = getPercentFromEvent(e);
                    audioPlayer.currentTime = lastSeekPercent * (audioPlayer.duration || 0);
                }
            });
            document.addEventListener('mouseup', (e) => {
                if (isSeeking) {
                    // Use lastSeekPercent to avoid jump on mouseup
                    audioPlayer.currentTime = lastSeekPercent * (audioPlayer.duration || 0);
                    isSeeking = false;
                    document.body.style.userSelect = '';
                    if (wasPlaying) audioPlayer.play();
                }
            });

            // Touch events
            progressKnob.addEventListener('touchstart', (e) => {
                isSeeking = true;
                wasPlaying = !audioPlayer.paused;
                audioPlayer.pause();
                document.body.style.userSelect = 'none';
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (isSeeking) {
                    lastSeekPercent = getPercentFromEvent(e);
                    audioPlayer.currentTime = lastSeekPercent * (audioPlayer.duration || 0);
                }
            }, { passive: false });
            document.addEventListener('touchend', (e) => {
                if (isSeeking) {
                    audioPlayer.currentTime = lastSeekPercent * (audioPlayer.duration || 0);
                    isSeeking = false;
                    document.body.style.userSelect = '';
                    if (wasPlaying) audioPlayer.play();
                }
            }, { passive: false });

            // Allow clicking anywhere on the bar to seek
            progressContainer.addEventListener('click', (e) => {
                const percent = getPercentFromEvent(e);
                audioPlayer.currentTime = percent * (audioPlayer.duration || 0);
            });

            audioPlayer.addEventListener('timeupdate', updateProgress);
            audioPlayer.addEventListener('loadedmetadata', updateProgress);
            audioPlayer.addEventListener('ended', updateProgress);

            // --- AUTOPLAY LOGIC ---

            autoplayToggle.addEventListener('click', () => {
                autoplayEnabled = !autoplayEnabled;
                updateAutoplayCheckbox();
            });

            audioPlayer.addEventListener('ended', () => {
                if (!autoplayEnabled || !currentEpisodeId) return;
                const idx = chronologicalEpisodes.findIndex(ep => ep.id === currentEpisodeId);
                if (idx !== -1 && idx + 1 < chronologicalEpisodes.length) {
                    const next = chronologicalEpisodes[idx + 1];
                    const {
                        title = 'Untitled Episode',
                        attachments,
                        image,
                        id
                    } = next;
                    const nextAudioUrl = attachments?.[0]?.url;
                    const nextArt = image || attachments?.[0]?.image || showArtUrl;
                    if (nextAudioUrl) {
                        playEpisode(title, nextAudioUrl, nextArt, id);
                    }
                }
            });

            function triggerArtWiggle() {
                    if (!flipContainer.classList.contains('flipped')) {
                        nowPlayingArt.classList.remove('wiggle');
                        // Force reflow to restart animation
                        void nowPlayingArt.offsetWidth;
                        nowPlayingArt.classList.add('wiggle');
                    }
                }
                setInterval(triggerArtWiggle, 8000);
                // Remove wiggle class after animation ends
                nowPlayingArt.addEventListener('animationend', () => {
                    nowPlayingArt.classList.remove('wiggle');
                });

            // --- INITIALIZATION ---
            fetchPodcastFeed();
        });
    </script>
</body>
</html>
